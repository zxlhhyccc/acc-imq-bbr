diff --git a/feeds.conf.default b/feeds.conf.default
index fc67933..e87a46d 100644
--- a/feeds.conf.default
+++ b/feeds.conf.default
@@ -2,6 +2,7 @@ src-git packages https://git.openwrt.org/feed/packages.git
 src-git luci https://git.openwrt.org/project/luci.git
 src-git routing https://git.openwrt.org/feed/routing.git
 src-git telephony https://git.openwrt.org/feed/telephony.git
+src-git nss_packages https://github.com/1715173329/nss-packages.git;nss-crypto
 #src-git video https://github.com/openwrt/video.git
 #src-git targets https://github.com/openwrt/targets.git
 #src-git oldpackages http://git.openwrt.org/packages.git
diff --git a/include/prereq-build.mk b/include/prereq-build.mk
index 8fbf6f2..fb08082 100644
--- a/include/prereq-build.mk
+++ b/include/prereq-build.mk
@@ -179,9 +179,6 @@ $(eval $(call SetupHostCommand,file,Please install the 'file' package, \
 $(eval $(call SetupHostCommand,rsync,Please install 'rsync', \
 	rsync --version </dev/null))
 
-$(eval $(call SetupHostCommand,which,Please install 'which', \
-	which which | grep which))
-
 $(STAGING_DIR_HOST)/bin/mkhash: $(SCRIPT_DIR)/mkhash.c
 	mkdir -p $(dir $@)
 	$(CC) -O2 -I$(TOPDIR)/tools/include -o $@ $<
diff --git a/package/boot/uboot-envtools/files/ipq807x b/package/boot/uboot-envtools/files/ipq807x
new file mode 100644
index 0000000..5611b6f
--- /dev/null
+++ b/package/boot/uboot-envtools/files/ipq807x
@@ -0,0 +1,23 @@
+[ -e /etc/config/ubootenv ] && exit 0
+
+touch /etc/config/ubootenv
+
+. /lib/uboot-envtools.sh
+. /lib/functions.sh
+
+board=$(board_name)
+
+case "$board" in
+redmi,ax6|\
+xiaomi,ax3600|\
+xiaomi,ax9000)
+	idx="$(find_mtd_index 0:appsblenv)"
+	[ -n "$idx" ] && \
+		ubootenv_add_uci_config "/dev/mtd$idx" "0x0" "0x10000" "0x20000"
+	;;
+esac
+
+config_load ubootenv
+config_foreach ubootenv_add_app_config ubootenv
+
+exit 0
diff --git a/package/firmware/ath11k-firmware/Makefile b/package/firmware/ath11k-firmware/Makefile
new file mode 100644
index 0000000..a682bb0
--- /dev/null
+++ b/package/firmware/ath11k-firmware/Makefile
@@ -0,0 +1,93 @@
+#
+# Copyright (C) 2021 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=ath11k-firmware
+PKG_SOURCE_DATE:=2021-07-20
+PKG_SOURCE_VERSION:=d4003c1921810adcc455d46f17776a3392b29436
+PKG_MIRROR_HASH:=6839081bafbc56d3b8e41d30790b20813c349cbc1732e887347ef5ed3ea717e4
+PKG_RELEASE:=$(AUTORELEASE)
+
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_URL:=https://github.com/kvalo/ath11k-firmware.git
+
+PKG_MAINTAINER:=Robert Marko <robimarko@gmail.com>
+
+include $(INCLUDE_DIR)/package.mk
+
+define Package/ath11k-firmware-default
+  SECTION:=firmware
+  CATEGORY:=Firmware
+  URL:=$(PKG_SOURCE_URL)
+  DEPENDS:=
+endef
+
+define Package/ath11k-firmware-ipq6018
+$(Package/ath11k-firmware-default)
+  TITLE:=ath11k firmware for IPQ6018 devices
+endef
+
+define Package/ath11k-firmware-ipq8074
+$(Package/ath11k-firmware-default)
+  TITLE:=ath11k firmware for IPQ8074 devices
+endef
+
+define Package/ath11k-firmware-qca6390
+$(Package/ath11k-firmware-default)
+  TITLE:=ath11k firmware for QCA6390 devices
+endef
+
+define Package/ath11k-firmware-qcn9074
+$(Package/ath11k-firmware-default)
+  TITLE:=ath11k firmware for QCN9074 devices
+endef
+
+define Build/Compile
+
+endef
+
+define Package/ath11k-firmware-ipq6018/install
+	$(INSTALL_DIR) $(1)/lib/firmware/ath11k/IPQ6018/hw1.0
+	$(INSTALL_DIR) $(1)/lib/firmware/IPQ6018
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/IPQ6018/hw1.0/board-2.bin \
+		$(1)/lib/firmware/ath11k/IPQ6018/hw1.0/
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/IPQ6018/hw1.0/2.5.0.1/WLAN.HK.2.5.0.1-01100-QCAHKSWPL_SILICONZ-1/* \
+		$(1)/lib/firmware/IPQ6018/
+endef
+
+define Package/ath11k-firmware-ipq8074/install
+	$(INSTALL_DIR) $(1)/lib/firmware/ath11k/IPQ8074/hw2.0
+	$(INSTALL_DIR) $(1)/lib/firmware/IPQ8074
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/IPQ8074/hw2.0/board-2.bin \
+		$(1)/lib/firmware/ath11k/IPQ8074/hw2.0/
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/IPQ8074/hw2.0/2.5.0.1/WLAN.HK.2.5.0.1-01100-QCAHKSWPL_SILICONZ-1/* \
+		$(1)/lib/firmware/IPQ8074/
+endef
+
+define Package/ath11k-firmware-qca6390/install
+	$(INSTALL_DIR) $(1)/lib/firmware/ath11k/QCA6390/hw2.0
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/QCA6390/hw2.0/1.0.1/WLAN.HST.1.0.1-01740-QCAHSTSWPLZ_V2_TO_X86-1/* \
+		$(1)/lib/firmware/ath11k/QCA6390/hw2.0/
+endef
+
+define Package/ath11k-firmware-qcn9074/install
+	$(INSTALL_DIR) $(1)/lib/firmware/ath11k/QCN9074/hw1.0
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/QCN9074/hw1.0/2.5.0.1/WLAN.HK.2.5.0.1-01100-QCAHKSWPL_SILICONZ-1/* \
+		$(1)/lib/firmware/ath11k/QCN9074/hw1.0/
+endef
+
+$(eval $(call BuildPackage,ath11k-firmware-ipq6018))
+$(eval $(call BuildPackage,ath11k-firmware-ipq8074))
+$(eval $(call BuildPackage,ath11k-firmware-qca6390))
+$(eval $(call BuildPackage,ath11k-firmware-qcn9074))
diff --git a/package/firmware/ipq-wifi/Makefile b/package/firmware/ipq-wifi/Makefile
index e63e3b3..2ab43fd 100644
--- a/package/firmware/ipq-wifi/Makefile
+++ b/package/firmware/ipq-wifi/Makefile
@@ -46,11 +46,15 @@ ALLWIFIBOARDS:= \
 	mikrotik_hap-ac2 \
 	mikrotik_sxtsq-5-ac \
 	mobipromo_cm520-79f \
+	p2w_r619ac \
 	nec_wg2600hp3 \
 	netgear_wac510 \
 	plasmacloud_pa1200 \
 	plasmacloud_pa2200 \
-	qxwlan_e2600ac
+	qxwlan_e2600ac \
+	redmi_ax6 \
+	xiaomi_ax3600 \
+	xiaomi_ax9000
 
 ALLWIFIPACKAGES:=$(foreach BOARD,$(ALLWIFIBOARDS),ipq-wifi-$(BOARD))
 
@@ -58,7 +62,7 @@ define Package/ipq-wifi-default
   SUBMENU:=ath10k Board-Specific Overrides
   SECTION:=firmware
   CATEGORY:=Firmware
-  DEPENDS:=@(TARGET_ipq40xx||TARGET_ipq806x)
+  DEPENDS:=@(TARGET_ipq40xx||TARGET_ipq806x||TARGET_ipq807x)
   TITLE:=Custom Board
 endef
 
@@ -67,6 +71,11 @@ define ipq-wifi-install-one-to
   $(INSTALL_DATA) $(1) $(2)/lib/firmware/ath10k/$(3)/board-2.bin
 endef
 
+define ipq-wifi-install-ath11-one-to
+  $(INSTALL_DIR)  $(2)/lib/firmware/ath11k/$(3)/
+  $(INSTALL_DATA) $(1) $(2)/lib/firmware/ath11k/$(3)/board-2.bin
+endef
+
 define ipq-wifi-install-one
   $(if $(filter $(suffix $(1)),.QCA4019 .qca4019),\
     $(call ipq-wifi-install-one-to,$(1),$(2),QCA4019/hw1.0),\
@@ -74,8 +83,12 @@ define ipq-wifi-install-one
     $(call ipq-wifi-install-one-to,$(1),$(2),QCA9888/hw2.0),\
   $(if $(filter $(suffix $(1)),.QCA9984 .qca9984),\
     $(call ipq-wifi-install-one-to,$(1),$(2),QCA9984/hw1.0),\
+  $(if $(filter $(suffix $(1)),.QCA9889 .qca9889),\
+    $(call ipq-wifi-install-one-to,$(1),$(2),QCA9887/hw1.0),\
+  $(if $(filter $(suffix $(1)),.IPQ8074 .ipq8074),\
+    $(call ipq-wifi-install-ath11-one-to,$(1),$(2),IPQ8074/hw2.0),\
     $(error Unrecognized board-file suffix '$(suffix $(1))' for '$(1)')\
-  )))
+  )))))
 
 endef
 # Blank line required at end of above define due to foreach context
@@ -132,10 +145,14 @@ $(eval $(call generate-ipq-wifi-package,luma_wrtq-329acn,Luma WRTQ-329ACN))
 $(eval $(call generate-ipq-wifi-package,mikrotik_hap-ac2,Mikrotik hAP ac2))
 $(eval $(call generate-ipq-wifi-package,mikrotik_sxtsq-5-ac,MikroTik SXTsq 5 ac))
 $(eval $(call generate-ipq-wifi-package,mobipromo_cm520-79f,MobiPromo CM520-79F))
+$(eval $(call generate-ipq-wifi-package,p2w_r619ac,P&W R619AC))
 $(eval $(call generate-ipq-wifi-package,nec_wg2600hp3,NEC Platforms WG2600HP3))
 $(eval $(call generate-ipq-wifi-package,netgear_wac510,Netgear WAC510))
 $(eval $(call generate-ipq-wifi-package,plasmacloud_pa1200,Plasma Cloud PA1200))
 $(eval $(call generate-ipq-wifi-package,plasmacloud_pa2200,Plasma Cloud PA2200))
 $(eval $(call generate-ipq-wifi-package,qxwlan_e2600ac,Qxwlan E2600AC))
+$(eval $(call generate-ipq-wifi-package,redmi_ax6,Redmi AX6))
+$(eval $(call generate-ipq-wifi-package,xiaomi_ax3600,Xiaomi AX3600))
+$(eval $(call generate-ipq-wifi-package,xiaomi_ax9000,Xiaomi AX9000))
 
 $(foreach PACKAGE,$(ALLWIFIPACKAGES),$(eval $(call BuildPackage,$(PACKAGE))))
diff --git a/package/firmware/ipq-wifi/board-redmi_ax6.ipq8074 b/package/firmware/ipq-wifi/board-redmi_ax6.ipq8074
new file mode 100644
index 0000000..98ed9c6
Binary files /dev/null and b/package/firmware/ipq-wifi/board-redmi_ax6.ipq8074 differ
diff --git a/package/firmware/ipq-wifi/board-xiaomi_ax3600.ipq8074 b/package/firmware/ipq-wifi/board-xiaomi_ax3600.ipq8074
new file mode 100644
index 0000000..db8ef4c
Binary files /dev/null and b/package/firmware/ipq-wifi/board-xiaomi_ax3600.ipq8074 differ
diff --git a/package/firmware/ipq-wifi/board-xiaomi_ax3600.qca9889 b/package/firmware/ipq-wifi/board-xiaomi_ax3600.qca9889
new file mode 100644
index 0000000..af4405c
Binary files /dev/null and b/package/firmware/ipq-wifi/board-xiaomi_ax3600.qca9889 differ
diff --git a/package/firmware/ipq-wifi/board-xiaomi_ax9000.ipq8074 b/package/firmware/ipq-wifi/board-xiaomi_ax9000.ipq8074
new file mode 100644
index 0000000..babfaa2
Binary files /dev/null and b/package/firmware/ipq-wifi/board-xiaomi_ax9000.ipq8074 differ
diff --git a/package/firmware/ipq-wifi/board-xiaomi_ax9000.qca9889 b/package/firmware/ipq-wifi/board-xiaomi_ax9000.qca9889
new file mode 100644
index 0000000..abccf93
Binary files /dev/null and b/package/firmware/ipq-wifi/board-xiaomi_ax9000.qca9889 differ
diff --git a/package/kernel/linux/modules/hwmon.mk b/package/kernel/linux/modules/hwmon.mk
index a39a891..fe82cb0 100644
--- a/package/kernel/linux/modules/hwmon.mk
+++ b/package/kernel/linux/modules/hwmon.mk
@@ -122,6 +122,22 @@ endef
 $(eval $(call KernelPackage,hwmon-drivetemp))
 
 
+define KernelPackage/hwmon-emc2305
+  TITLE:=SMSC EMC2305 fan support
+  KCONFIG:=CONFIG_SENSORS_EMC2305
+  FILES:= \
+  $(LINUX_DIR)/drivers/hwmon/emc2305.ko
+  AUTOLOAD:=$(call AutoProbe,emc2305)
+  $(call AddDepends/hwmon,+kmod-i2c-core +kmod-regmap-i2c)
+endef
+
+define KernelPackage/hwmon-emc2305/description
+ SMSC SMSC EMC2301/2/3/5 fan controllers support
+endef
+
+$(eval $(call KernelPackage,hwmon-emc2305))
+
+
 define KernelPackage/hwmon-gpiofan
   TITLE:=Generic GPIO FAN support
   KCONFIG:=CONFIG_SENSORS_GPIO_FAN
diff --git a/package/kernel/linux/modules/usb.mk b/package/kernel/linux/modules/usb.mk
index 3249b85..8cbbc63 100644
--- a/package/kernel/linux/modules/usb.mk
+++ b/package/kernel/linux/modules/usb.mk
@@ -477,7 +477,7 @@ $(eval $(call KernelPackage,usb-dwc3))
 
 define KernelPackage/usb-dwc3-qcom
   TITLE:=DWC3 Qualcomm USB driver
-  DEPENDS:=@(TARGET_ipq40xx||TARGET_ipq806x) +kmod-usb-dwc3
+  DEPENDS:=@(TARGET_ipq40xx||TARGET_ipq806x||TARGET_ipq807x) +kmod-usb-dwc3
   KCONFIG:= CONFIG_USB_DWC3_QCOM
   FILES:= $(LINUX_DIR)/drivers/usb/dwc3/dwc3-qcom.ko
   AUTOLOAD:=$(call AutoLoad,53,dwc3-qcom,1)
@@ -1123,6 +1123,7 @@ endef
 
 define KernelPackage/usb-net-aqc111
   TITLE:=Support for USB-to-Ethernet Aquantia AQtion 5/2.5GbE
+  DEPENDS:=+kmod-libphy
   KCONFIG:=CONFIG_USB_NET_AQC111
   FILES:=$(LINUX_DIR)/drivers/$(USBNET_DIR)/aqc111.ko
   AUTOLOAD:=$(call AutoProbe,aqc111)
diff --git a/package/kernel/mac80211/Makefile b/package/kernel/mac80211/Makefile
index dd39c2d..0391aa2 100644
--- a/package/kernel/mac80211/Makefile
+++ b/package/kernel/mac80211/Makefile
@@ -38,6 +38,7 @@ PKG_CONFIG_DEPENDS:= \
 	CONFIG_PACKAGE_CFG80211_TESTMODE \
 	CONFIG_PACKAGE_MAC80211_DEBUGFS \
 	CONFIG_PACKAGE_MAC80211_MESH \
+	CONFIG_PACKAGE_MAC80211_NSS_SUPPORT \
 	CONFIG_PACKAGE_MAC80211_TRACING \
 	CONFIG_PACKAGE_IWLWIFI_DEBUG \
 	CONFIG_PACKAGE_IWLWIFI_DEBUGFS \
@@ -84,6 +85,7 @@ config-$(CONFIG_PACKAGE_CFG80211_TESTMODE) += NL80211_TESTMODE
 
 config-$(call config_package,mac80211) += MAC80211
 config-$(CONFIG_PACKAGE_MAC80211_MESH) += MAC80211_MESH
+config-$(CONFIG_PACKAGE_MAC80211_NSS_SUPPORT) += MAC80211_NSS_SUPPORT
 
 include ath.mk
 include broadcom.mk
@@ -127,7 +129,7 @@ define KernelPackage/mac80211
   $(call KernelPackage/mac80211/Default)
   TITLE:=Linux 802.11 Wireless Networking Stack
   # +kmod-crypto-cmac is a runtime only dependency of net/mac80211/aes_cmac.c
-  DEPENDS+= +kmod-cfg80211 +kmod-crypto-cmac +kmod-crypto-ccm +kmod-crypto-gcm +hostapd-common
+  DEPENDS+= +kmod-cfg80211 +kmod-crypto-cmac +kmod-crypto-ccm +kmod-crypto-gcm +hostapd-common +PACKAGE_kmod-qca-nss-drv:kmod-qca-nss-drv
   KCONFIG:=\
 	CONFIG_AVERAGE=y
   FILES:= $(PKG_BUILD_DIR)/net/mac80211/mac80211.ko
@@ -159,6 +161,14 @@ define KernelPackage/mac80211/config
 		bool "Enable 802.11s mesh support"
 		default y
 
+	if PACKAGE_kmod-qca-nss-drv
+		config PACKAGE_MAC80211_NSS_SUPPORT
+			bool "Enable NSS support for IPQ platform"
+			default y
+			help
+			  This option enables support for NSS in boards.
+	endif
+
   endif
 endef
 
@@ -436,7 +446,8 @@ config-$(CONFIG_LEDS_TRIGGERS) += MAC80211_LEDS
 
 MAKE_OPTS:= -C "$(PKG_BUILD_DIR)" \
 	$(KERNEL_MAKE_FLAGS) \
-	EXTRA_CFLAGS="-I$(PKG_BUILD_DIR)/include $(IREMAP_CFLAGS)" \
+	EXTRA_CFLAGS="-I$(PKG_BUILD_DIR)/include $(IREMAP_CFLAGS) \
+		      -I$(STAGING_DIR)/usr/include/qca-nss-drv" \
 	KLIB_BUILD="$(LINUX_DIR)" \
 	MODPROBE=true \
 	KLIB=$(TARGET_MODULES_DIR) \
diff --git a/package/kernel/mac80211/ath.mk b/package/kernel/mac80211/ath.mk
index ba03ae1..411cf9c 100644
--- a/package/kernel/mac80211/ath.mk
+++ b/package/kernel/mac80211/ath.mk
@@ -1,6 +1,6 @@
 PKG_DRIVERS += \
 	ath ath5k ath6kl ath6kl-sdio ath6kl-usb ath9k ath9k-common ath9k-htc ath10k \
-	carl9170 owl-loader ar5523 wil6210
+	ath11k ath11k-ahb ath11k-pci carl9170 owl-loader ar5523 wil6210
 
 PKG_CONFIG_DEPENDS += \
 	CONFIG_PACKAGE_ATH_DEBUG \
@@ -12,6 +12,7 @@ PKG_CONFIG_DEPENDS += \
 	CONFIG_ATH9K_TX99 \
 	CONFIG_ATH10K_LEDS \
 	CONFIG_ATH10K_THERMAL \
+	CONFIG_ATH11K_MEM_PROFILE_512M \
 	CONFIG_ATH_USER_REGD
 
 ifdef CONFIG_PACKAGE_MAC80211_DEBUGFS
@@ -19,6 +20,7 @@ ifdef CONFIG_PACKAGE_MAC80211_DEBUGFS
 	ATH9K_DEBUGFS \
 	ATH9K_HTC_DEBUGFS \
 	ATH10K_DEBUGFS \
+  ATH11K_DEBUGFS \
 	CARL9170_DEBUGFS \
 	ATH5K_DEBUG \
 	ATH6KL_DEBUG \
@@ -28,6 +30,7 @@ endif
 ifdef CONFIG_PACKAGE_MAC80211_TRACING
   config-y += \
 	ATH10K_TRACING \
+  ATH11K_TRACING \
 	ATH6KL_TRACING \
 	ATH_TRACEPOINTS \
 	ATH5K_TRACER \
@@ -35,9 +38,9 @@ ifdef CONFIG_PACKAGE_MAC80211_TRACING
 endif
 
 config-$(call config_package,ath) += ATH_CARDS ATH_COMMON
-config-$(CONFIG_PACKAGE_ATH_DEBUG) += ATH_DEBUG ATH10K_DEBUG ATH9K_STATION_STATISTICS
+config-$(CONFIG_PACKAGE_ATH_DEBUG) += ATH_DEBUG ATH10K_DEBUG ATH11K_DEBUG ATH9K_STATION_STATISTICS
 config-$(CONFIG_PACKAGE_ATH_DFS) += ATH9K_DFS_CERTIFIED ATH10K_DFS_CERTIFIED
-config-$(CONFIG_PACKAGE_ATH_SPECTRAL) += ATH9K_COMMON_SPECTRAL ATH10K_SPECTRAL
+config-$(CONFIG_PACKAGE_ATH_SPECTRAL) += ATH9K_COMMON_SPECTRAL ATH10K_SPECTRAL ATH11K_SPECTRAL
 config-$(CONFIG_PACKAGE_ATH_DYNACK) += ATH9K_DYNACK
 config-$(call config_package,ath9k) += ATH9K
 config-$(call config_package,ath9k-common) += ATH9K_COMMON
@@ -52,9 +55,13 @@ config-$(CONFIG_ATH9K_TX99) += ATH9K_TX99
 config-$(CONFIG_ATH9K_UBNTHSR) += ATH9K_UBNTHSR
 config-$(CONFIG_ATH10K_LEDS) += ATH10K_LEDS
 config-$(CONFIG_ATH10K_THERMAL) += ATH10K_THERMAL
+config-$(CONFIG_ATH11K_MEM_PROFILE_512M) += ATH11K_MEM_PROFILE_512M
 
 config-$(call config_package,ath9k-htc) += ATH9K_HTC
 config-$(call config_package,ath10k) += ATH10K ATH10K_PCI
+config-$(call config_package,ath11k) += ATH11K
+config-$(call config_package,ath11k-ahb) += ATH11K_AHB
+config-$(call config_package,ath11k-pci) += ATH11K_PCI
 
 config-$(call config_package,ath5k) += ATH5K
 ifdef CONFIG_TARGET_ath25
@@ -277,10 +284,68 @@ define KernelPackage/ath10k/config
 
        config ATH10K_THERMAL
                bool "Enable thermal sensors and throttling support"
+               default y
                depends on PACKAGE_kmod-ath10k
 
 endef
 
+define KernelPackage/ath11k
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Qualcomm 802.11ax wireless chipset support (common code)
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath11k
+  DEPENDS+= +kmod-ath +@DRIVER_11N_SUPPORT +@DRIVER_11AC_SUPPORT +@DRIVER_11AX_SUPPORT \
+  +kmod-crypto-michael-mic +ATH11K_THERMAL:kmod-hwmon-core +ATH11K_THERMAL:kmod-thermal
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath11k/ath11k.ko
+  AUTOLOAD:=$(call AutoProbe,ath11k)
+endef
+
+define KernelPackage/ath11k/description
+This module adds support for Qualcomm Technologies 802.11ax family of
+chipsets.
+endef
+
+define KernelPackage/ath11k/config
+
+       config ATH11K_THERMAL
+               bool "Enable thermal sensors and throttling support"
+               depends on PACKAGE_kmod-ath11k
+               default y if TARGET_ipq807x
+
+       config ATH11K_MEM_PROFILE_512M
+               bool "Enable 512MB profile"
+               depends on PACKAGE_kmod-ath11k
+               default y if TARGET_ipq807x_generic_DEVICE_redmi_ax6 || TARGET_ipq807x_generic_DEVICE_xiaomi_ax3600
+
+endef
+
+define KernelPackage/ath11k-ahb
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Qualcomm 802.11ax AHB wireless chipset support
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath11k
+  DEPENDS+= @TARGET_ipq807x +kmod-ath11k
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath11k/ath11k_ahb.ko
+  AUTOLOAD:=$(call AutoProbe,ath11k_ahb)
+endef
+
+define KernelPackage/ath11k-ahb/description
+This module adds support for Qualcomm Technologies 802.11ax family of
+chipsets with AHB bus.
+endef
+
+define KernelPackage/ath11k-pci
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Qualcomm 802.11ax PCI wireless chipset support
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath11k
+  DEPENDS+= @PCI_SUPPORT @TARGET_ipq807x +kmod-ath11k
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath11k/ath11k_pci.ko
+  AUTOLOAD:=$(call AutoProbe,ath11k_pci)
+endef
+
+define KernelPackage/ath11k-pci/description
+This module adds support for Qualcomm Technologies 802.11ax family of
+chipsets with PCI bus.
+endef
+
 define KernelPackage/carl9170
   $(call KernelPackage/mac80211/Default)
   TITLE:=Driver for Atheros AR9170 USB sticks
diff --git a/package/kernel/mac80211/broadcom.mk b/package/kernel/mac80211/broadcom.mk
index 473bbf5..85911b6 100644
--- a/package/kernel/mac80211/broadcom.mk
+++ b/package/kernel/mac80211/broadcom.mk
@@ -450,6 +450,7 @@ define KernelPackage/brcmfmac/config
 	config BRCMFMAC_SDIO
 		bool "Enable SDIO bus interface support"
 		default y if TARGET_bcm27xx
+		default y if TARGET_rockchip
 		default y if TARGET_sunxi
 		default n
 		help
diff --git a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh b/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
index 0b7a84d..a27b0e1 100644
--- a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
+++ b/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
@@ -135,7 +135,7 @@ mac80211_hostapd_setup_base() {
 	[ -n "$acs_exclude_dfs" ] && [ "$acs_exclude_dfs" -gt 0 ] &&
 		append base_cfg "acs_exclude_dfs=1" "$N"
 
-	json_get_vars noscan ht_coex
+	json_get_vars noscan ht_coex vendor_vht
 	json_get_values ht_capab_list ht_capab tx_burst
 	json_get_values channel_list channels
 
@@ -280,7 +280,7 @@ mac80211_hostapd_setup_base() {
 	}
 	[ "$hwmode" = "a" ] || enable_ac=0
 
-	if [ "$enable_ac" != "0" ]; then
+	if [ "$enable_ac" != "0" -o "$vendor_vht" = "1" ]; then
 		json_get_vars \
 			rxldpc:1 \
 			short_gi_80:1 \
diff --git a/package/kernel/mac80211/files/lib/wifi/mac80211.sh b/package/kernel/mac80211/files/lib/wifi/mac80211.sh
index 6aa46b0..6f20f74 100644
--- a/package/kernel/mac80211/files/lib/wifi/mac80211.sh
+++ b/package/kernel/mac80211/files/lib/wifi/mac80211.sh
@@ -174,7 +174,7 @@ detect_mac80211() {
 			set wireless.radio${devidx}.channel=${channel}
 			set wireless.radio${devidx}.band=${mode_band}
 			set wireless.radio${devidx}.htmode=$htmode
-			set wireless.radio${devidx}.disabled=1
+			set wireless.radio${devidx}.disabled=0
 
 			set wireless.default_radio${devidx}=wifi-iface
 			set wireless.default_radio${devidx}.device=radio${devidx}
diff --git a/package/kernel/mac80211/patches/ath10k/983-ath10k-allow-vht-on-2g.patch b/package/kernel/mac80211/patches/ath10k/983-ath10k-allow-vht-on-2g.patch
new file mode 100644
index 0000000..eeca88a
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath10k/983-ath10k-allow-vht-on-2g.patch
@@ -0,0 +1,10 @@
+--- a/drivers/net/wireless/ath/ath10k/mac.c
++++ b/drivers/net/wireless/ath/ath10k/mac.c
+@@ -4718,6 +4718,7 @@ static void ath10k_mac_setup_ht_vht_cap(
+ 	if (ar->phy_capability & WHAL_WLAN_11G_CAPABILITY) {
+ 		band = &ar->mac.sbands[NL80211_BAND_2GHZ];
+ 		band->ht_cap = ht_cap;
++		band->vht_cap = vht_cap;
+ 	}
+ 	if (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY) {
+ 		band = &ar->mac.sbands[NL80211_BAND_5GHZ];
diff --git a/package/kernel/mac80211/patches/ath11k/001-v5.11-ath11k-search-DT-for-qcom-ath11k-calibration-variant.patch b/package/kernel/mac80211/patches/ath11k/001-v5.11-ath11k-search-DT-for-qcom-ath11k-calibration-variant.patch
new file mode 100644
index 0000000..d71ba40
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/001-v5.11-ath11k-search-DT-for-qcom-ath11k-calibration-variant.patch
@@ -0,0 +1,144 @@
+From da4ccc477bb46cc518991828ae8ac79e856f92ab Mon Sep 17 00:00:00 2001
+From: Sven Eckelmann <sven@narfation.org>
+Date: Thu, 15 Oct 2020 15:15:01 +0200
+Subject: [PATCH] ath11k: search DT for qcom,ath11k-calibration-variant
+
+Board Data File (BDF) is loaded upon driver boot-up procedure. The right
+board data file is identified on IPQ6018 using bus, qmi-chip-id and
+qmi-board-id.
+
+The problem, however, can occur when the (default) board data file cannot
+fulfill with the vendor requirements and it is necessary to use a different
+board data file.
+
+This problem was already solved on ath10k by adding a ",variant=.*" at the
+end of the board name. The same functionality must also be provided for
+ath11k.
+
+The device tree requires an additional string to define the variant name
+
+    wifi@c000000 {
+        status = "okay";
+        qcom,ath11k-calibration-variant = "Cigtech-WF-188";
+    };
+
+This would create the boarddata identifier for the board-2.bin search
+
+ *  bus=ahb,qmi-chip-id=0,qmi-board-id=18,variant=Cigtech-WF-188
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+Link: https://lore.kernel.org/r/20201015131501.1939685-2-sven@narfation.org
+---
+ drivers/net/wireless/ath/ath11k/core.c | 35 ++++++++++++++++++++++++--
+ drivers/net/wireless/ath/ath11k/core.h |  1 +
+ drivers/net/wireless/ath/ath11k/qmi.c  |  5 ++++
+ drivers/net/wireless/ath/ath11k/qmi.h  |  2 ++
+ 4 files changed, 41 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath11k/core.c
++++ b/drivers/net/wireless/ath/ath11k/core.c
+@@ -7,6 +7,7 @@
+ #include <linux/slab.h>
+ #include <linux/remoteproc.h>
+ #include <linux/firmware.h>
++#include <linux/of.h>
+ #include "core.h"
+ #include "dp_tx.h"
+ #include "dp_rx.h"
+@@ -141,14 +142,44 @@ static const struct ath11k_hw_params ath
+ 	},
+ };
+ 
++int ath11k_core_check_dt(struct ath11k_base *ab)
++{
++	size_t max_len = sizeof(ab->qmi.target.bdf_ext);
++	const char *variant = NULL;
++	struct device_node *node;
++
++	node = ab->dev->of_node;
++	if (!node)
++		return -ENOENT;
++
++	of_property_read_string(node, "qcom,ath11k-calibration-variant",
++				&variant);
++	if (!variant)
++		return -ENODATA;
++
++	if (strscpy(ab->qmi.target.bdf_ext, variant, max_len) < 0)
++		ath11k_dbg(ab, ATH11K_DBG_BOOT,
++			   "bdf variant string is longer than the buffer can accommodate (variant: %s)\n",
++			    variant);
++
++	return 0;
++}
++
+ static int ath11k_core_create_board_name(struct ath11k_base *ab, char *name,
+ 					 size_t name_len)
+ {
++	/* strlen(',variant=') + strlen(ab->qmi.target.bdf_ext) */
++	char variant[9 + ATH11K_QMI_BDF_EXT_STR_LENGTH] = { 0 };
++
++	if (ab->qmi.target.bdf_ext[0] != '\0')
++		scnprintf(variant, sizeof(variant), ",variant=%s",
++			  ab->qmi.target.bdf_ext);
++
+ 	scnprintf(name, name_len,
+-		  "bus=%s,qmi-chip-id=%d,qmi-board-id=%d",
++		  "bus=%s,qmi-chip-id=%d,qmi-board-id=%d%s",
+ 		  ath11k_bus_str(ab->hif.bus),
+ 		  ab->qmi.target.chip_id,
+-		  ab->qmi.target.board_id);
++		  ab->qmi.target.board_id, variant);
+ 
+ 	ath11k_dbg(ab, ATH11K_DBG_BOOT, "boot using board name '%s'\n", name);
+ 
+--- a/drivers/net/wireless/ath/ath11k/core.h
++++ b/drivers/net/wireless/ath/ath11k/core.h
+@@ -886,6 +886,7 @@ void ath11k_core_free(struct ath11k_base
+ int ath11k_core_fetch_bdf(struct ath11k_base *ath11k,
+ 			  struct ath11k_board_data *bd);
+ void ath11k_core_free_bdf(struct ath11k_base *ab, struct ath11k_board_data *bd);
++int ath11k_core_check_dt(struct ath11k_base *ath11k);
+ 
+ void ath11k_core_halt(struct ath11k *ar);
+ 
+--- a/drivers/net/wireless/ath/ath11k/qmi.c
++++ b/drivers/net/wireless/ath/ath11k/qmi.c
+@@ -1815,6 +1815,7 @@ static int ath11k_qmi_request_target_cap
+ 	struct qmi_wlanfw_cap_resp_msg_v01 resp;
+ 	struct qmi_txn txn = {};
+ 	int ret = 0;
++	int r;
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	memset(&resp, 0, sizeof(resp));
+@@ -1880,6 +1881,10 @@ static int ath11k_qmi_request_target_cap
+ 		    ab->qmi.target.fw_build_timestamp,
+ 		    ab->qmi.target.fw_build_id);
+ 
++	r = ath11k_core_check_dt(ab);
++	if (r)
++		ath11k_dbg(ab, ATH11K_DBG_QMI, "DT bdf variant name not set.\n");
++
+ out:
+ 	return ret;
+ }
+--- a/drivers/net/wireless/ath/ath11k/qmi.h
++++ b/drivers/net/wireless/ath/ath11k/qmi.h
+@@ -24,6 +24,7 @@
+ #define ATH11K_QMI_RESP_LEN_MAX			8192
+ #define ATH11K_QMI_WLANFW_MAX_NUM_MEM_SEG_V01	32
+ #define ATH11K_QMI_CALDB_SIZE			0x480000
++#define ATH11K_QMI_BDF_EXT_STR_LENGTH		0x20
+ 
+ #define QMI_WLFW_REQUEST_MEM_IND_V01		0x0035
+ #define QMI_WLFW_FW_MEM_READY_IND_V01		0x0037
+@@ -101,6 +102,7 @@ struct target_info {
+ 	u32 fw_version;
+ 	char fw_build_timestamp[ATH11K_QMI_WLANFW_MAX_TIMESTAMP_LEN_V01 + 1];
+ 	char fw_build_id[ATH11K_QMI_WLANFW_MAX_BUILD_ID_LEN_V01 + 1];
++	char bdf_ext[ATH11K_QMI_BDF_EXT_STR_LENGTH];
+ };
+ 
+ struct m3_mem_region {
diff --git a/package/kernel/mac80211/patches/ath11k/002-v5.12-ath11k-Update-tx-descriptor-search-index-properly.patch b/package/kernel/mac80211/patches/ath11k/002-v5.12-ath11k-Update-tx-descriptor-search-index-properly.patch
new file mode 100644
index 0000000..a6351e5
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/002-v5.12-ath11k-Update-tx-descriptor-search-index-properly.patch
@@ -0,0 +1,151 @@
+From 4b965be536eefdd16ca0a88120fee23f5b92cd16 Mon Sep 17 00:00:00 2001
+From: Karthikeyan Periyasamy <periyasa@codeaurora.org>
+Date: Mon, 8 Feb 2021 13:32:11 +0200
+Subject: ath11k: Update tx descriptor search index properly
+
+Tx descriptor search index field should be updated with hw peer id
+and not by AST Hash as per the HW/FW recommendation. Incorrect search
+index causes throughput degradation in all scenario for all the
+platforms. so updated the search index field with hw peer id, which
+is a common change applicable for all the platforms. Also no need of these
+configuration for non station type. seen 10% throughput increase in WDS
+traffic with this change.
+
+Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.4.0.1-01492-QCAHKSWPL_SILICONZ-1
+
+Signed-off-by: Karthikeyan Periyasamy <periyasa@codeaurora.org>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+Link: https://lore.kernel.org/r/1612410960-9120-1-git-send-email-periyasa@codeaurora.org
+---
+ drivers/net/wireless/ath/ath11k/core.h   | 1 +
+ drivers/net/wireless/ath/ath11k/dp_rx.c  | 8 ++++++--
+ drivers/net/wireless/ath/ath11k/dp_tx.c  | 1 +
+ drivers/net/wireless/ath/ath11k/hal_tx.c | 2 ++
+ drivers/net/wireless/ath/ath11k/hal_tx.h | 1 +
+ drivers/net/wireless/ath/ath11k/peer.c   | 9 +++++++--
+ drivers/net/wireless/ath/ath11k/peer.h   | 3 ++-
+ 7 files changed, 20 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath11k/core.h
++++ b/drivers/net/wireless/ath/ath11k/core.h
+@@ -193,6 +193,7 @@ struct ath11k_vif {
+ 	u32 beacon_interval;
+ 	u32 dtim_period;
+ 	u16 ast_hash;
++	u16 ast_idx;
+ 	u16 tcl_metadata;
+ 	u8 hal_addr_search_flags;
+ 	u8 search_type;
+--- a/drivers/net/wireless/ath/ath11k/dp_rx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
+@@ -1648,6 +1648,7 @@ void ath11k_dp_htt_htc_t2h_msg_handler(s
+ 	u8 mac_addr[ETH_ALEN];
+ 	u16 peer_mac_h16;
+ 	u16 ast_hash;
++	u16 hw_peer_id;
+ 
+ 	ath11k_dbg(ab, ATH11K_DBG_DP_HTT, "dp_htt rx msg type :0x%0x\n", type);
+ 
+@@ -1668,7 +1669,7 @@ void ath11k_dp_htt_htc_t2h_msg_handler(s
+ 					 resp->peer_map_ev.info1);
+ 		ath11k_dp_get_mac_addr(resp->peer_map_ev.mac_addr_l32,
+ 				       peer_mac_h16, mac_addr);
+-		ath11k_peer_map_event(ab, vdev_id, peer_id, mac_addr, 0);
++		ath11k_peer_map_event(ab, vdev_id, peer_id, mac_addr, 0, 0);
+ 		break;
+ 	case HTT_T2H_MSG_TYPE_PEER_MAP2:
+ 		vdev_id = FIELD_GET(HTT_T2H_PEER_MAP_INFO_VDEV_ID,
+@@ -1681,7 +1682,10 @@ void ath11k_dp_htt_htc_t2h_msg_handler(s
+ 				       peer_mac_h16, mac_addr);
+ 		ast_hash = FIELD_GET(HTT_T2H_PEER_MAP_INFO2_AST_HASH_VAL,
+ 				     resp->peer_map_ev.info2);
+-		ath11k_peer_map_event(ab, vdev_id, peer_id, mac_addr, ast_hash);
++		hw_peer_id = FIELD_GET(HTT_T2H_PEER_MAP_INFO1_HW_PEER_ID,
++				       resp->peer_map_ev.info1);
++		ath11k_peer_map_event(ab, vdev_id, peer_id, mac_addr, ast_hash,
++				      hw_peer_id);
+ 		break;
+ 	case HTT_T2H_MSG_TYPE_PEER_UNMAP:
+ 	case HTT_T2H_MSG_TYPE_PEER_UNMAP2:
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
+@@ -165,6 +165,7 @@ tcl_ring_sel:
+ 	ti.pkt_offset = 0;
+ 	ti.lmac_id = ar->lmac_id;
+ 	ti.bss_ast_hash = arvif->ast_hash;
++	ti.bss_ast_idx = arvif->ast_idx;
+ 	ti.dscp_tid_tbl_idx = 0;
+ 
+ 	if (skb->ip_summed == CHECKSUM_PARTIAL &&
+--- a/drivers/net/wireless/ath/ath11k/hal_tx.c
++++ b/drivers/net/wireless/ath/ath11k/hal_tx.c
+@@ -71,6 +71,8 @@ void ath11k_hal_tx_cmd_desc_setup(struct
+ 	tcl_cmd->info3 = FIELD_PREP(HAL_TCL_DATA_CMD_INFO3_DSCP_TID_TABLE_IDX,
+ 				    ti->dscp_tid_tbl_idx) |
+ 			 FIELD_PREP(HAL_TCL_DATA_CMD_INFO3_SEARCH_INDEX,
++				    ti->bss_ast_idx) |
++			 FIELD_PREP(HAL_TCL_DATA_CMD_INFO3_CACHE_SET_NUM,
+ 				    ti->bss_ast_hash);
+ 	tcl_cmd->info4 = 0;
+ }
+--- a/drivers/net/wireless/ath/ath11k/hal_tx.h
++++ b/drivers/net/wireless/ath/ath11k/hal_tx.h
+@@ -29,6 +29,7 @@ struct hal_tx_info {
+ 	u32 flags1; /* %HAL_TCL_DATA_CMD_INFO2_ */
+ 	u16 addr_search_flags; /* %HAL_TCL_DATA_CMD_INFO0_ADDR(X/Y)_ */
+ 	u16 bss_ast_hash;
++	u16 bss_ast_idx;
+ 	u8 tid;
+ 	u8 search_type; /* %HAL_TX_ADDR_SEARCH_ */
+ 	u8 lmac_id;
+--- a/drivers/net/wireless/ath/ath11k/peer.c
++++ b/drivers/net/wireless/ath/ath11k/peer.c
+@@ -118,7 +118,7 @@ exit:
+ }
+ 
+ void ath11k_peer_map_event(struct ath11k_base *ab, u8 vdev_id, u16 peer_id,
+-			   u8 *mac_addr, u16 ast_hash)
++			   u8 *mac_addr, u16 ast_hash, u16 hw_peer_id)
+ {
+ 	struct ath11k_peer *peer;
+ 
+@@ -132,6 +132,7 @@ void ath11k_peer_map_event(struct ath11k
+ 		peer->vdev_id = vdev_id;
+ 		peer->peer_id = peer_id;
+ 		peer->ast_hash = ast_hash;
++		peer->hw_peer_id = hw_peer_id;
+ 		ether_addr_copy(peer->addr, mac_addr);
+ 		list_add(&peer->list, &ab->peers);
+ 		wake_up(&ab->peer_mapping_wq);
+@@ -309,7 +310,11 @@ int ath11k_peer_create(struct ath11k *ar
+ 
+ 	peer->pdev_idx = ar->pdev_idx;
+ 	peer->sta = sta;
+-	arvif->ast_hash = peer->ast_hash;
++
++	if (arvif->vif->type == NL80211_IFTYPE_STATION) {
++		arvif->ast_hash = peer->ast_hash;
++		arvif->ast_idx = peer->hw_peer_id;
++	}
+ 
+ 	peer->sec_type = HAL_ENCRYPT_TYPE_OPEN;
+ 	peer->sec_type_grp = HAL_ENCRYPT_TYPE_OPEN;
+--- a/drivers/net/wireless/ath/ath11k/peer.h
++++ b/drivers/net/wireless/ath/ath11k/peer.h
+@@ -14,6 +14,7 @@ struct ath11k_peer {
+ 	int peer_id;
+ 	u16 ast_hash;
+ 	u8 pdev_idx;
++	u16 hw_peer_id;
+ 
+ 	/* protected by ab->data_lock */
+ 	struct ieee80211_key_conf *keys[WMI_MAX_KEY_INDEX + 1];
+@@ -31,7 +32,7 @@ struct ath11k_peer {
+ 
+ void ath11k_peer_unmap_event(struct ath11k_base *ab, u16 peer_id);
+ void ath11k_peer_map_event(struct ath11k_base *ab, u8 vdev_id, u16 peer_id,
+-			   u8 *mac_addr, u16 ast_hash);
++			   u8 *mac_addr, u16 ast_hash, u16 hw_peer_id);
+ struct ath11k_peer *ath11k_peer_find(struct ath11k_base *ab, int vdev_id,
+ 				     const u8 *addr);
+ struct ath11k_peer *ath11k_peer_find_by_addr(struct ath11k_base *ab,
diff --git a/package/kernel/mac80211/patches/ath11k/003-v5.12-ath11k-remove-duplicate-function-declaration.patch b/package/kernel/mac80211/patches/ath11k/003-v5.12-ath11k-remove-duplicate-function-declaration.patch
new file mode 100644
index 0000000..1522273
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/003-v5.12-ath11k-remove-duplicate-function-declaration.patch
@@ -0,0 +1,36 @@
+From cf8480d338a1b9156121e5e035e6b9721db4332a Mon Sep 17 00:00:00 2001
+From: Karthikeyan Periyasamy <periyasa@codeaurora.org>
+Date: Mon, 11 Jan 2021 19:49:30 +0200
+Subject: ath11k: remove duplicate function declaration
+
+Removed the duplicated peer related function declaration
+from core.h since those functions are already declared in peer.h
+
+Founded in code review.
+
+Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.4.0.1-01492-QCAHKSWPL_SILICONZ-1
+
+Signed-off-by: Karthikeyan Periyasamy <periyasa@codeaurora.org>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+Link: https://lore.kernel.org/r/1608304793-20612-1-git-send-email-periyasa@codeaurora.org
+---
+ drivers/net/wireless/ath/ath11k/core.h | 8 --------
+ 1 file changed, 8 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath11k/core.h
++++ b/drivers/net/wireless/ath/ath11k/core.h
+@@ -868,14 +868,6 @@ extern const struct service_to_pipe ath1
+ extern const struct ce_pipe_config ath11k_target_ce_config_wlan_qca6390[];
+ extern const struct service_to_pipe ath11k_target_service_to_ce_map_wlan_qca6390[];
+ 
+-void ath11k_peer_unmap_event(struct ath11k_base *ab, u16 peer_id);
+-void ath11k_peer_map_event(struct ath11k_base *ab, u8 vdev_id, u16 peer_id,
+-			   u8 *mac_addr, u16 ast_hash);
+-struct ath11k_peer *ath11k_peer_find(struct ath11k_base *ab, int vdev_id,
+-				     const u8 *addr);
+-struct ath11k_peer *ath11k_peer_find_by_addr(struct ath11k_base *ab,
+-					     const u8 *addr);
+-struct ath11k_peer *ath11k_peer_find_by_id(struct ath11k_base *ab, int peer_id);
+ int ath11k_core_qmi_firmware_ready(struct ath11k_base *ab);
+ int ath11k_core_pre_init(struct ath11k_base *ab);
+ int ath11k_core_init(struct ath11k_base *ath11k);
diff --git a/package/kernel/mac80211/patches/ath11k/004-v5.13-ath11k-Update-signal-filled-flag-during-sta_statisti.patch b/package/kernel/mac80211/patches/ath11k/004-v5.13-ath11k-Update-signal-filled-flag-during-sta_statisti.patch
new file mode 100644
index 0000000..6cfa1d3
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/004-v5.13-ath11k-Update-signal-filled-flag-during-sta_statisti.patch
@@ -0,0 +1,35 @@
+From f277eb0500b4ee1cbe9db8615761f19b5a5520c9 Mon Sep 17 00:00:00 2001
+From: Sriram R <srirrama@codeaurora.org>
+Date: Wed, 24 Feb 2021 14:32:41 +0530
+Subject: [PATCH] ath11k: Update signal filled flag during sta_statistics drv
+ op
+
+Currently, though the peer rssi information is updated to station dump
+from driver sta_statistics mac op, the info doesn't get updated
+since the NL80211_STA_INFO_SIGNAL filled flag is not set in station
+info. Hence update this flag while filling the rssi info.
+
+Tested on: IPQ8074 WLAN.HK.2.1.0.1-01213-QCAHKSWPL_SILICONZ-1
+
+Signed-off-by: Sriram R <srirrama@codeaurora.org>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+Link: https://lore.kernel.org/r/20210224090241.3098-1-srirrama@codeaurora.org
+---
+ drivers/net/wireless/ath/ath11k/mac.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
+index 3c1f35a204ba..32c7687d9ac2 100644
+--- a/drivers/net/wireless/ath/ath11k/mac.c
++++ b/drivers/net/wireless/ath/ath11k/mac.c
+@@ -6082,6 +6082,7 @@ static void ath11k_mac_op_sta_statistics(struct ieee80211_hw *hw,
+ 
+ 	/* TODO: Use real NF instead of default one. */
+ 	sinfo->signal = arsta->rssi_comb + ATH11K_DEFAULT_NOISE_FLOOR;
++	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);
+ }
+ 
+ static const struct ieee80211_ops ath11k_ops = {
+-- 
+2.25.1
+
diff --git a/package/kernel/mac80211/patches/ath11k/005-v5.11-ath11k-fix-ZERO-address-in-probe-request.patch b/package/kernel/mac80211/patches/ath11k/005-v5.11-ath11k-fix-ZERO-address-in-probe-request.patch
new file mode 100644
index 0000000..729aaca
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/005-v5.11-ath11k-fix-ZERO-address-in-probe-request.patch
@@ -0,0 +1,38 @@
+From fa7572c2cfe081dff82f884fa05f1b067d4beaaa Mon Sep 17 00:00:00 2001
+From: Carl Huang <cjhuang@codeaurora.org>
+Date: Fri, 6 Nov 2020 08:55:48 +0200
+Subject: [PATCH] ath11k: fix ZERO address in probe request
+
+Host needs to pass at least on bssid with all 0xff to firmware in
+WMI_START_SCAN_CMDID, otherwise the bssid and receiver address
+in probe requeste are all ZEROs.
+
+This also fixed some hidden AP connection issue because some AP
+doesn't respond to probe request which receiver address are all
+ZEROs.
+
+Tested-on: QCA6390 hw2.0 PCI WLAN.HST.1.0.1-01740-QCAHSTSWPLZ_V2_TO_X86-1
+
+Signed-off-by: Carl Huang <cjhuang@codeaurora.org>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+Link: https://lore.kernel.org/r/20201012101733.24137-1-cjhuang@codeaurora.org
+---
+ drivers/net/wireless/ath/ath11k/wmi.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/drivers/net/wireless/ath/ath11k/wmi.c b/drivers/net/wireless/ath/ath11k/wmi.c
+index 40032c2b497551..bca66c1d47ad57 100644
+--- a/drivers/net/wireless/ath/ath11k/wmi.c
++++ b/drivers/net/wireless/ath/ath11k/wmi.c
+@@ -1950,6 +1950,11 @@ void ath11k_wmi_start_scan_init(struct ath11k *ar,
+ 				  WMI_SCAN_EVENT_DEQUEUED;
+ 	arg->scan_flags |= WMI_SCAN_CHAN_STAT_EVENT;
+ 	arg->num_bssid = 1;
++
++	/* fill bssid_list[0] with 0xff, otherwise bssid and RA will be
++	 * ZEROs in probe request
++	 */
++	eth_broadcast_addr(arg->bssid_list[0].addr);
+ }
+ 
+ static inline void
diff --git a/package/kernel/mac80211/patches/ath11k/006-v5.11-ath11k-use-MHI-provided-APIs-to-allocate-and-free-MHI-con.patch b/package/kernel/mac80211/patches/ath11k/006-v5.11-ath11k-use-MHI-provided-APIs-to-allocate-and-free-MHI-con.patch
new file mode 100644
index 0000000..c82e7cc
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/006-v5.11-ath11k-use-MHI-provided-APIs-to-allocate-and-free-MHI-con.patch
@@ -0,0 +1,57 @@
+From 57449b07eafcc831343013b87b57e928c50d16b4 Mon Sep 17 00:00:00 2001
+From: Bhaumik Bhatt <bbhatt@codeaurora.org>
+Date: Tue, 17 Nov 2020 09:33:56 -0800
+Subject: [PATCH] ath11k: use MHI provided APIs to allocate and free MHI
+ controller
+
+Use MHI provided APIs to allocate and free MHI controller to
+improve MHI host driver handling. This also fixes a memory leak
+as the MHI controller was allocated but never freed.
+
+Signed-off-by: Bhaumik Bhatt <bbhatt@codeaurora.org>
+Reviewed-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+Link: https://lore.kernel.org/r/1605634436-36506-1-git-send-email-bbhatt@codeaurora.org
+---
+ drivers/net/wireless/ath/ath11k/mhi.c | 7 ++++---
+ 1 file changed, 4 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath11k/mhi.c b/drivers/net/wireless/ath/ath11k/mhi.c
+index 47a1ce1bee4f4e..8a2068456a0975 100644
+--- a/drivers/net/wireless/ath/ath11k/mhi.c
++++ b/drivers/net/wireless/ath/ath11k/mhi.c
+@@ -214,7 +214,7 @@ int ath11k_mhi_register(struct ath11k_pci *ab_pci)
+ 	struct mhi_controller *mhi_ctrl;
+ 	int ret;
+ 
+-	mhi_ctrl = kzalloc(sizeof(*mhi_ctrl), GFP_KERNEL);
++	mhi_ctrl = mhi_alloc_controller();
+ 	if (!mhi_ctrl)
+ 		return -ENOMEM;
+ 
+@@ -230,7 +230,7 @@ int ath11k_mhi_register(struct ath11k_pci *ab_pci)
+ 	ret = ath11k_mhi_get_msi(ab_pci);
+ 	if (ret) {
+ 		ath11k_err(ab, "failed to get msi for mhi\n");
+-		kfree(mhi_ctrl);
++		mhi_free_controller(mhi_ctrl);
+ 		return ret;
+ 	}
+ 
+@@ -248,7 +248,7 @@ int ath11k_mhi_register(struct ath11k_pci *ab_pci)
+ 	ret = mhi_register_controller(mhi_ctrl, &ath11k_mhi_config);
+ 	if (ret) {
+ 		ath11k_err(ab, "failed to register to mhi bus, err = %d\n", ret);
+-		kfree(mhi_ctrl);
++		mhi_free_controller(mhi_ctrl);
+ 		return ret;
+ 	}
+ 
+@@ -261,6 +261,7 @@ void ath11k_mhi_unregister(struct ath11k_pci *ab_pci)
+ 
+ 	mhi_unregister_controller(mhi_ctrl);
+ 	kfree(mhi_ctrl->irq);
++	mhi_free_controller(mhi_ctrl);
+ }
+ 
+ static char *ath11k_mhi_state_to_str(enum ath11k_mhi_state mhi_state)
diff --git a/package/kernel/mac80211/patches/ath11k/007-1-ath11k-fix-4-addr-tx-failure-for-AP-and-STA-modes.patch b/package/kernel/mac80211/patches/ath11k/007-1-ath11k-fix-4-addr-tx-failure-for-AP-and-STA-modes.patch
new file mode 100644
index 0000000..58d3d02
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/007-1-ath11k-fix-4-addr-tx-failure-for-AP-and-STA-modes.patch
@@ -0,0 +1,219 @@
+From mboxrd@z Thu Jan  1 00:00:00 1970
+Return-Path: <linux-wireless-owner@kernel.org>
+X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
+	aws-us-west-2-korg-lkml-1.web.codeaurora.org
+X-Spam-Level: 
+X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
+	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
+	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,URIBL_BLOCKED,USER_AGENT_GIT
+	autolearn=unavailable autolearn_force=no version=3.4.0
+Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
+	by smtp.lore.kernel.org (Postfix) with ESMTP id AE5DFC07E95
+	for <linux-wireless@archiver.kernel.org>; Tue, 20 Jul 2021 21:32:35 +0000 (UTC)
+Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
+	by mail.kernel.org (Postfix) with ESMTP id 8BCA960E0B
+	for <linux-wireless@archiver.kernel.org>; Tue, 20 Jul 2021 21:32:35 +0000 (UTC)
+Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
+        id S232037AbhGTUvp (ORCPT
+        <rfc822;linux-wireless@archiver.kernel.org>);
+        Tue, 20 Jul 2021 16:51:45 -0400
+Received: from so254-9.mailgun.net ([198.61.254.9]:51945 "EHLO
+        so254-9.mailgun.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
+        with ESMTP id S233404AbhGTUvb (ORCPT
+        <rfc822;linux-wireless@vger.kernel.org>);
+        Tue, 20 Jul 2021 16:51:31 -0400
+DKIM-Signature: a=rsa-sha256; v=1; c=relaxed/relaxed; d=mg.codeaurora.org; q=dns/txt;
+ s=smtp; t=1626816727; h=Content-Transfer-Encoding: MIME-Version:
+ Message-Id: Date: Subject: Cc: To: From: Sender;
+ bh=0NKtP900YLYCGbw3/GGjWWripcJNlTdjFgNVgginJt0=; b=abeQRnEIETDnBog8B8jC5dz4L/CByAwwAd4rRXQWAhj3mrSD3aI8lXlncgB6UaxCJ7IxwD7n
+ Jd43kUakxtbNRc2ljAhNOBgnVzUYc34DC9P8+cZCUyohmRMATXg9kMszaiWSrlwKfnFbNmhy
+ bB2QJmD4AKn90qUvNto1Rmu6PRY=
+X-Mailgun-Sending-Ip: 198.61.254.9
+X-Mailgun-Sid: WyI3YTAwOSIsICJsaW51eC13aXJlbGVzc0B2Z2VyLmtlcm5lbC5vcmciLCAiYmU5ZTRhIl0=
+Received: from smtp.codeaurora.org
+ (ec2-35-166-182-171.us-west-2.compute.amazonaws.com [35.166.182.171]) by
+ smtp-out-n07.prod.us-east-1.postgun.com with SMTP id
+ 60f740d4290ea35ee6638a2d (version=TLS1.2,
+ cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256); Tue, 20 Jul 2021 21:32:04
+ GMT
+Sender: jouni=codeaurora.org@mg.codeaurora.org
+Received: by smtp.codeaurora.org (Postfix, from userid 1001)
+        id 72C9CC43460; Tue, 20 Jul 2021 21:32:03 +0000 (UTC)
+Received: from jouni.codeaurora.org (85-76-67-217-nat.elisa-mobile.fi [85.76.67.217])
+        (using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
+        (No client certificate requested)
+        (Authenticated sender: jouni)
+        by smtp.codeaurora.org (Postfix) with ESMTPSA id 07C11C433F1;
+        Tue, 20 Jul 2021 21:32:00 +0000 (UTC)
+DMARC-Filter: OpenDMARC Filter v1.3.2 smtp.codeaurora.org 07C11C433F1
+Authentication-Results: aws-us-west-2-caf-mail-1.web.codeaurora.org; dmarc=none (p=none dis=none) header.from=codeaurora.org
+Authentication-Results: aws-us-west-2-caf-mail-1.web.codeaurora.org; spf=fail smtp.mailfrom=jouni@codeaurora.org
+From:   Jouni Malinen <jouni@codeaurora.org>
+To:     Kalle Valo <kvalo@codeaurora.org>
+Cc:     ath11k@lists.infradead.org, linux-wireless@vger.kernel.org,
+        Sathishkumar Muruganandam <murugana@codeaurora.org>,
+        Jouni Malinen <jouni@codeaurora.org>
+Subject: [PATCH 1/2] ath11k: fix 4-addr tx failure for AP and STA modes
+Date:   Wed, 21 Jul 2021 00:31:46 +0300
+Message-Id: <20210720213147.90042-1-jouni@codeaurora.org>
+X-Mailer: git-send-email 2.25.1
+MIME-Version: 1.0
+Content-Transfer-Encoding: 8bit
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Archive: <https://lore.kernel.org/linux-wireless/>
+
+From: Sathishkumar Muruganandam <murugana@codeaurora.org>
+
+Ath11k FW requires peer parameter WMI_PEER_USE_4ADDR to be set for
+4-addr peers allowing 4-address frame transmission to those peers.
+
+Add ath11k driver callback for sta_set_4addr() to queue new workq
+set_4addr_wk only once based on new boolean, use_4addr_set.
+
+sta_set_4addr() will be called during 4-addr STA association cases
+applicable for both AP and STA modes.
+
+In ath11k_sta_set_4addr_wk(),
+
+AP mode:
+        WMI_PEER_USE_4ADDR will be set for the corresponding
+        associated 4-addr STA(s)
+
+STA mode:
+        WMI_PEER_USE_4ADDR will be set for the AP to which the
+        4-addr STA got associated.
+
+Tested-on: IPQ8074 WLAN.HK.2.1.0.1-01238-QCAHKSWPL_SILICONZ-1
+
+Signed-off-by: Sathishkumar Muruganandam <murugana@codeaurora.org>
+Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
+---
+ drivers/net/wireless/ath/ath11k/core.h |  3 ++
+ drivers/net/wireless/ath/ath11k/mac.c  | 48 ++++++++++++++++++++++++--
+ 2 files changed, 49 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath11k/core.h b/drivers/net/wireless/ath/ath11k/core.h
+index 018fb2385f2a..11c8dffd0236 100644
+--- a/drivers/net/wireless/ath/ath11k/core.h
++++ b/drivers/net/wireless/ath/ath11k/core.h
+@@ -362,6 +362,7 @@ struct ath11k_sta {
+ 	enum hal_pn_type pn_type;
+ 
+ 	struct work_struct update_wk;
++	struct work_struct set_4addr_wk;
+ 	struct rate_info txrate;
+ 	struct rate_info last_txrate;
+ 	u64 rx_duration;
+@@ -374,6 +375,8 @@ struct ath11k_sta {
+ 	/* protected by conf_mutex */
+ 	bool aggr_mode;
+ #endif
++
++	bool use_4addr_set;
+ };
+ 
+ #define ATH11K_MIN_5G_FREQ 4150
+diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
+index e9b3689331ec..d42637ecbf1e 100644
+--- a/drivers/net/wireless/ath/ath11k/mac.c
++++ b/drivers/net/wireless/ath/ath11k/mac.c
+@@ -3155,6 +3155,31 @@ static void ath11k_sta_rc_update_wk(struct work_struct *wk)
+ 	mutex_unlock(&ar->conf_mutex);
+ }
+ 
++static void ath11k_sta_set_4addr_wk(struct work_struct *wk)
++{
++	struct ath11k *ar;
++	struct ath11k_vif *arvif;
++	struct ath11k_sta *arsta;
++	struct ieee80211_sta *sta;
++	int ret = 0;
++
++	arsta = container_of(wk, struct ath11k_sta, set_4addr_wk);
++	sta = container_of((void *)arsta, struct ieee80211_sta, drv_priv);
++	arvif = arsta->arvif;
++	ar = arvif->ar;
++
++	ath11k_dbg(ar->ab, ATH11K_DBG_MAC,
++		   "setting USE_4ADDR for peer %pM\n", sta->addr);
++
++	ret = ath11k_wmi_set_peer_param(ar, sta->addr,
++					arvif->vdev_id,
++					WMI_PEER_USE_4ADDR, 1);
++
++	if (ret)
++		ath11k_warn(ar->ab, "failed to set peer %pM 4addr capability: %d\n",
++			    sta->addr, ret);
++}
++
+ static int ath11k_mac_inc_num_stations(struct ath11k_vif *arvif,
+ 				       struct ieee80211_sta *sta)
+ {
+@@ -3234,11 +3259,13 @@ static int ath11k_mac_station_add(struct ath11k *ar,
+ 	}
+ 
+ 	if (ieee80211_vif_is_mesh(vif)) {
++		ath11k_dbg(ab, ATH11K_DBG_MAC,
++			   "setting USE_4ADDR for mesh STA %pM\n", sta->addr);
+ 		ret = ath11k_wmi_set_peer_param(ar, sta->addr,
+ 						arvif->vdev_id,
+ 						WMI_PEER_USE_4ADDR, 1);
+ 		if (ret) {
+-			ath11k_warn(ab, "failed to STA %pM 4addr capability: %d\n",
++			ath11k_warn(ab, "failed to set mesh STA %pM 4addr capability: %d\n",
+ 				    sta->addr, ret);
+ 			goto free_tx_stats;
+ 		}
+@@ -3291,8 +3318,10 @@ static int ath11k_mac_op_sta_state(struct ieee80211_hw *hw,
+ 
+ 	/* cancel must be done outside the mutex to avoid deadlock */
+ 	if ((old_state == IEEE80211_STA_NONE &&
+-	     new_state == IEEE80211_STA_NOTEXIST))
++	     new_state == IEEE80211_STA_NOTEXIST)) {
+ 		cancel_work_sync(&arsta->update_wk);
++		cancel_work_sync(&arsta->set_4addr_wk);
++	}
+ 
+ 	mutex_lock(&ar->conf_mutex);
+ 
+@@ -3301,6 +3330,7 @@ static int ath11k_mac_op_sta_state(struct ieee80211_hw *hw,
+ 		memset(arsta, 0, sizeof(*arsta));
+ 		arsta->arvif = arvif;
+ 		INIT_WORK(&arsta->update_wk, ath11k_sta_rc_update_wk);
++		INIT_WORK(&arsta->set_4addr_wk, ath11k_sta_set_4addr_wk);
+ 
+ 		ret = ath11k_mac_station_add(ar, vif, sta);
+ 		if (ret)
+@@ -3395,6 +3425,19 @@ static int ath11k_mac_op_sta_set_txpwr(struct ieee80211_hw *hw,
+ 	return ret;
+ }
+ 
++static void ath11k_mac_op_sta_set_4addr(struct ieee80211_hw *hw,
++					struct ieee80211_vif *vif,
++					struct ieee80211_sta *sta, bool enabled)
++{
++	struct ath11k *ar = hw->priv;
++	struct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;
++
++	if (enabled && !arsta->use_4addr_set) {
++		ieee80211_queue_work(ar->hw, &arsta->set_4addr_wk);
++		arsta->use_4addr_set = true;
++	}
++}
++
+ static void ath11k_mac_op_sta_rc_update(struct ieee80211_hw *hw,
+ 					struct ieee80211_vif *vif,
+ 					struct ieee80211_sta *sta,
+@@ -6180,6 +6223,7 @@ static const struct ieee80211_ops ath11k_ops = {
+ 	.cancel_hw_scan                 = ath11k_mac_op_cancel_hw_scan,
+ 	.set_key                        = ath11k_mac_op_set_key,
+ 	.sta_state                      = ath11k_mac_op_sta_state,
++	.sta_set_4addr                  = ath11k_mac_op_sta_set_4addr,
+ 	.sta_set_txpwr			= ath11k_mac_op_sta_set_txpwr,
+ 	.sta_rc_update			= ath11k_mac_op_sta_rc_update,
+ 	.conf_tx                        = ath11k_mac_op_conf_tx,
+-- 
+2.25.1
+
diff --git a/package/kernel/mac80211/patches/ath11k/007-2-ath11k-fix-4addr-multicast-packet-tx.patch b/package/kernel/mac80211/patches/ath11k/007-2-ath11k-fix-4addr-multicast-packet-tx.patch
new file mode 100644
index 0000000..f53fc57
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/007-2-ath11k-fix-4addr-multicast-packet-tx.patch
@@ -0,0 +1,199 @@
+From mboxrd@z Thu Jan  1 00:00:00 1970
+Return-Path: <linux-wireless-owner@kernel.org>
+X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
+	aws-us-west-2-korg-lkml-1.web.codeaurora.org
+X-Spam-Level: 
+X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
+	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
+	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,URIBL_BLOCKED,USER_AGENT_GIT
+	autolearn=unavailable autolearn_force=no version=3.4.0
+Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
+	by smtp.lore.kernel.org (Postfix) with ESMTP id 25420C07E9B
+	for <linux-wireless@archiver.kernel.org>; Tue, 20 Jul 2021 21:33:45 +0000 (UTC)
+Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
+	by mail.kernel.org (Postfix) with ESMTP id 01B6660E0B
+	for <linux-wireless@archiver.kernel.org>; Tue, 20 Jul 2021 21:33:44 +0000 (UTC)
+Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
+        id S231676AbhGTUw7 (ORCPT
+        <rfc822;linux-wireless@archiver.kernel.org>);
+        Tue, 20 Jul 2021 16:52:59 -0400
+Received: from so254-9.mailgun.net ([198.61.254.9]:51945 "EHLO
+        so254-9.mailgun.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
+        with ESMTP id S234001AbhGTUvt (ORCPT
+        <rfc822;linux-wireless@vger.kernel.org>);
+        Tue, 20 Jul 2021 16:51:49 -0400
+DKIM-Signature: a=rsa-sha256; v=1; c=relaxed/relaxed; d=mg.codeaurora.org; q=dns/txt;
+ s=smtp; t=1626816747; h=Content-Transfer-Encoding: MIME-Version:
+ References: In-Reply-To: Message-Id: Date: Subject: Cc: To: From:
+ Sender; bh=pTgIsAFvKI5zaKS8j6HkCt9Dr4xbghRAApcXu+jUG8M=; b=ZAAksGTytroGGn4JtQ3J6nCBuDx5xyVpnhflyyy4ZihH6zkONxlfFzdmrU9OAB7jqgetM0bw
+ aodI6LSEYmEo+yYTMvYfRD+vtYNqbnEtj3Er8kXZA+EaraVr1rhQNUCootlK9BaqAyA+ckoS
+ iUediQZtUI3serWUbPDTPAUCDn8=
+X-Mailgun-Sending-Ip: 198.61.254.9
+X-Mailgun-Sid: WyI3YTAwOSIsICJsaW51eC13aXJlbGVzc0B2Z2VyLmtlcm5lbC5vcmciLCAiYmU5ZTRhIl0=
+Received: from smtp.codeaurora.org
+ (ec2-35-166-182-171.us-west-2.compute.amazonaws.com [35.166.182.171]) by
+ smtp-out-n01.prod.us-east-1.postgun.com with SMTP id
+ 60f740d74815712f3a66316d (version=TLS1.2,
+ cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256); Tue, 20 Jul 2021 21:32:07
+ GMT
+Sender: jouni=codeaurora.org@mg.codeaurora.org
+Received: by smtp.codeaurora.org (Postfix, from userid 1001)
+        id AE3D3C43217; Tue, 20 Jul 2021 21:32:06 +0000 (UTC)
+Received: from jouni.codeaurora.org (85-76-67-217-nat.elisa-mobile.fi [85.76.67.217])
+        (using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
+        (No client certificate requested)
+        (Authenticated sender: jouni)
+        by smtp.codeaurora.org (Postfix) with ESMTPSA id BA686C433D3;
+        Tue, 20 Jul 2021 21:32:04 +0000 (UTC)
+DMARC-Filter: OpenDMARC Filter v1.3.2 smtp.codeaurora.org BA686C433D3
+Authentication-Results: aws-us-west-2-caf-mail-1.web.codeaurora.org; dmarc=none (p=none dis=none) header.from=codeaurora.org
+Authentication-Results: aws-us-west-2-caf-mail-1.web.codeaurora.org; spf=fail smtp.mailfrom=jouni@codeaurora.org
+From:   Jouni Malinen <jouni@codeaurora.org>
+To:     Kalle Valo <kvalo@codeaurora.org>
+Cc:     ath11k@lists.infradead.org, linux-wireless@vger.kernel.org,
+        Karthikeyan Periyasamy <periyasa@codeaurora.org>,
+        Jouni Malinen <jouni@codeaurora.org>
+Subject: [PATCH 2/2] ath11k: fix 4addr multicast packet tx
+Date:   Wed, 21 Jul 2021 00:31:47 +0300
+Message-Id: <20210720213147.90042-2-jouni@codeaurora.org>
+X-Mailer: git-send-email 2.25.1
+In-Reply-To: <20210720213147.90042-1-jouni@codeaurora.org>
+References: <20210720213147.90042-1-jouni@codeaurora.org>
+MIME-Version: 1.0
+Content-Transfer-Encoding: 8bit
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Archive: <https://lore.kernel.org/linux-wireless/>
+
+From: Karthikeyan Periyasamy <periyasa@codeaurora.org>
+
+In 4addr, AP wired backbone to STA wired backbone ping fails due to ARP
+request not getting answered. Here 4addr ARP multicast packet is sent in
+3addr, so that 4addr STA not honouring the 3addr ARP multicast packet.
+Fix this issue by sending out multicast packet in 4addr format, firmware
+expects peer meta flag instead of vdev meta flag in Tx descriptor.
+
+Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.4.0.1-01641-QCAHKSWPL_SILICONZ-1
+
+Signed-off-by: Karthikeyan Periyasamy <periyasa@codeaurora.org>
+Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
+---
+ drivers/net/wireless/ath/ath11k/core.h  |  1 +
+ drivers/net/wireless/ath/ath11k/dp_tx.c | 12 ++++++++++--
+ drivers/net/wireless/ath/ath11k/dp_tx.h |  2 +-
+ drivers/net/wireless/ath/ath11k/mac.c   |  6 +++++-
+ drivers/net/wireless/ath/ath11k/peer.c  | 11 +++++++++++
+ 5 files changed, 28 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath11k/core.h b/drivers/net/wireless/ath/ath11k/core.h
+index 11c8dffd0236..6a6cabdd3e30 100644
+--- a/drivers/net/wireless/ath/ath11k/core.h
++++ b/drivers/net/wireless/ath/ath11k/core.h
+@@ -377,6 +377,7 @@ struct ath11k_sta {
+ #endif
+ 
+ 	bool use_4addr_set;
++	u16 tcl_metadata;
+ };
+ 
+ #define ATH11K_MIN_5G_FREQ 4150
+diff --git a/drivers/net/wireless/ath/ath11k/dp_tx.c b/drivers/net/wireless/ath/ath11k/dp_tx.c
+index 8bba5234f81f..3acdd4050d5b 100644
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
+@@ -78,7 +78,7 @@ enum hal_encrypt_type ath11k_dp_tx_get_encrypt_type(u32 cipher)
+ }
+ 
+ int ath11k_dp_tx(struct ath11k *ar, struct ath11k_vif *arvif,
+-		 struct sk_buff *skb)
++		 struct ath11k_sta *arsta, struct sk_buff *skb)
+ {
+ 	struct ath11k_base *ab = ar->ab;
+ 	struct ath11k_dp *dp = &ab->dp;
+@@ -145,7 +145,15 @@ int ath11k_dp_tx(struct ath11k *ar, struct ath11k_vif *arvif,
+ 		     FIELD_PREP(DP_TX_DESC_ID_MSDU_ID, ret) |
+ 		     FIELD_PREP(DP_TX_DESC_ID_POOL_ID, pool_id);
+ 	ti.encap_type = ath11k_dp_tx_get_encap_type(arvif, skb);
+-	ti.meta_data_flags = arvif->tcl_metadata;
++
++	if (ieee80211_has_a4(hdr->frame_control) &&
++	    is_multicast_ether_addr(hdr->addr3) && arsta &&
++	    arsta->use_4addr_set) {
++		ti.meta_data_flags = arsta->tcl_metadata;
++		ti.flags0 |= FIELD_PREP(HAL_TCL_DATA_CMD_INFO1_TO_FW, 1);
++	} else {
++		ti.meta_data_flags = arvif->tcl_metadata;
++	}
+ 
+ 	if (ti.encap_type == HAL_TCL_ENCAP_TYPE_RAW) {
+ 		if (skb_cb->flags & ATH11K_SKB_CIPHER_SET) {
+diff --git a/drivers/net/wireless/ath/ath11k/dp_tx.h b/drivers/net/wireless/ath/ath11k/dp_tx.h
+index f8a9f9c8e444..698b907b878d 100644
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.h
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.h
+@@ -17,7 +17,7 @@ struct ath11k_dp_htt_wbm_tx_status {
+ 
+ int ath11k_dp_tx_htt_h2t_ver_req_msg(struct ath11k_base *ab);
+ int ath11k_dp_tx(struct ath11k *ar, struct ath11k_vif *arvif,
+-		 struct sk_buff *skb);
++		 struct ath11k_sta *arsta, struct sk_buff *skb);
+ void ath11k_dp_tx_completion_handler(struct ath11k_base *ab, int ring_id);
+ int ath11k_dp_tx_send_reo_cmd(struct ath11k_base *ab, struct dp_rx_tid *rx_tid,
+ 			      enum hal_reo_cmd_type type,
+diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
+index d42637ecbf1e..e8da4af82221 100644
+--- a/drivers/net/wireless/ath/ath11k/mac.c
++++ b/drivers/net/wireless/ath/ath11k/mac.c
+@@ -4356,6 +4356,7 @@ static void ath11k_mac_op_tx(struct ieee80211_hw *hw,
+ 	struct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);
+ 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+ 	struct ieee80211_key_conf *key = info->control.hw_key;
++	struct ath11k_sta *arsta = NULL;
+ 	u32 info_flags = info->flags;
+ 	bool is_prb_rsp;
+ 	int ret;
+@@ -4381,7 +4382,10 @@ static void ath11k_mac_op_tx(struct ieee80211_hw *hw,
+ 		return;
+ 	}
+ 
+-	ret = ath11k_dp_tx(ar, arvif, skb);
++	if (control->sta)
++		arsta = (struct ath11k_sta *)control->sta->drv_priv;
++
++	ret = ath11k_dp_tx(ar, arvif, arsta, skb);
+ 	if (ret) {
+ 		ath11k_warn(ar->ab, "failed to transmit frame %d\n", ret);
+ 		ieee80211_free_txskb(ar->hw, skb);
+diff --git a/drivers/net/wireless/ath/ath11k/peer.c b/drivers/net/wireless/ath/ath11k/peer.c
+index f49abefa9618..85471f8b3563 100644
+--- a/drivers/net/wireless/ath/ath11k/peer.c
++++ b/drivers/net/wireless/ath/ath11k/peer.c
+@@ -251,6 +251,7 @@ int ath11k_peer_create(struct ath11k *ar, struct ath11k_vif *arvif,
+ 		       struct ieee80211_sta *sta, struct peer_create_params *param)
+ {
+ 	struct ath11k_peer *peer;
++	struct ath11k_sta *arsta;
+ 	int ret;
+ 
+ 	lockdep_assert_held(&ar->conf_mutex);
+@@ -319,6 +320,16 @@ int ath11k_peer_create(struct ath11k *ar, struct ath11k_vif *arvif,
+ 	peer->sec_type = HAL_ENCRYPT_TYPE_OPEN;
+ 	peer->sec_type_grp = HAL_ENCRYPT_TYPE_OPEN;
+ 
++	if (sta) {
++		arsta = (struct ath11k_sta *)sta->drv_priv;
++		arsta->tcl_metadata |= FIELD_PREP(HTT_TCL_META_DATA_TYPE, 0) |
++				       FIELD_PREP(HTT_TCL_META_DATA_PEER_ID,
++						  peer->peer_id);
++
++		/* set HTT extension valid bit to 0 by default */
++		arsta->tcl_metadata &= ~HTT_TCL_META_DATA_VALID_HTT;
++	}
++
+ 	ar->num_peers++;
+ 
+ 	spin_unlock_bh(&ar->ab->base_lock);
+-- 
+2.25.1
+
diff --git a/package/kernel/mac80211/patches/ath11k/008-v5.14-ath11k-Avoid-memcpy-over-reading-of-he_cap.patch b/package/kernel/mac80211/patches/ath11k/008-v5.14-ath11k-Avoid-memcpy-over-reading-of-he_cap.patch
new file mode 100644
index 0000000..aad8dc6
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/008-v5.14-ath11k-Avoid-memcpy-over-reading-of-he_cap.patch
@@ -0,0 +1,47 @@
+From c8bcd82a4efd053cdd5ce515a8b0003011a5f756 Mon Sep 17 00:00:00 2001
+From: Kees Cook <keescook@chromium.org>
+Date: Wed, 16 Jun 2021 12:54:10 -0700
+Subject: [PATCH] ath11k: Avoid memcpy() over-reading of he_cap
+
+In preparation for FORTIFY_SOURCE performing compile-time and run-time
+field bounds checking for memcpy(), memmove(), and memset(), avoid
+intentionally writing across neighboring array fields.
+
+Since peer_he_cap_{mac,phy}info and he_cap_elem.{mac,phy}_cap_info are not
+the same sizes, memcpy() was reading beyond field boundaries. Instead,
+correctly cap the copy length and pad out any difference in size
+(peer_he_cap_macinfo is 8 bytes whereas mac_cap_info is 6, and
+peer_he_cap_phyinfo is 12 bytes whereas phy_cap_info is 11).
+
+Signed-off-by: Kees Cook <keescook@chromium.org>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+Link: https://lore.kernel.org/r/20210616195410.1232119-1-keescook@chromium.org
+---
+ drivers/net/wireless/ath/ath11k/mac.c | 14 ++++++++++----
+ 1 file changed, 10 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
+index eb52332dbe3f13..e9b3689331ec2a 100644
+--- a/drivers/net/wireless/ath/ath11k/mac.c
++++ b/drivers/net/wireless/ath/ath11k/mac.c
+@@ -1314,10 +1314,16 @@ static void ath11k_peer_assoc_h_he(struct ath11k *ar,
+ 
+ 	arg->he_flag = true;
+ 
+-	memcpy(&arg->peer_he_cap_macinfo, he_cap->he_cap_elem.mac_cap_info,
+-	       sizeof(arg->peer_he_cap_macinfo));
+-	memcpy(&arg->peer_he_cap_phyinfo, he_cap->he_cap_elem.phy_cap_info,
+-	       sizeof(arg->peer_he_cap_phyinfo));
++	memcpy_and_pad(&arg->peer_he_cap_macinfo,
++		       sizeof(arg->peer_he_cap_macinfo),
++		       he_cap->he_cap_elem.mac_cap_info,
++		       sizeof(he_cap->he_cap_elem.mac_cap_info),
++		       0);
++	memcpy_and_pad(&arg->peer_he_cap_phyinfo,
++		       sizeof(arg->peer_he_cap_phyinfo),
++		       he_cap->he_cap_elem.phy_cap_info,
++		       sizeof(he_cap->he_cap_elem.phy_cap_info),
++		       0);
+ 	arg->peer_he_ops = vif->bss_conf.he_oper.params;
+ 
+ 	/* the top most byte is used to indicate BSS color info */
diff --git a/package/kernel/mac80211/patches/ath11k/009-v5.15-ath11k-set-register-access-length-for-MHI-driver.patch b/package/kernel/mac80211/patches/ath11k/009-v5.15-ath11k-set-register-access-length-for-MHI-driver.patch
new file mode 100644
index 0000000..40942e4
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/009-v5.15-ath11k-set-register-access-length-for-MHI-driver.patch
@@ -0,0 +1,31 @@
+From fb359946c3effad77a3ac8ebc943ea5cac22d335 Mon Sep 17 00:00:00 2001
+From: Bhaumik Bhatt <bbhatt@codeaurora.org>
+Date: Thu, 6 May 2021 12:51:43 -0700
+Subject: [PATCH] ath11k: set register access length for MHI driver
+
+MHI driver requires register space length to add range checks and
+prevent memory region accesses outside of that for MMIO space.
+Set it before registering the MHI controller.
+
+Signed-off-by: Bhaumik Bhatt <bbhatt@codeaurora.org>
+Reviewed-by: Hemant Kumar <hemantk@codeaurora.org>
+Reviewed-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
+Acked-by: Kalle Valo <kvalo@codeaurora.org>
+Link: https://lore.kernel.org/r/1620330705-40192-5-git-send-email-bbhatt@codeaurora.org
+Signed-off-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
+---
+ drivers/net/wireless/ath/ath11k/mhi.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/drivers/net/wireless/ath/ath11k/mhi.c b/drivers/net/wireless/ath/ath11k/mhi.c
+index 27b394d115e26a..e097ae52e25733 100644
+--- a/drivers/net/wireless/ath/ath11k/mhi.c
++++ b/drivers/net/wireless/ath/ath11k/mhi.c
+@@ -330,6 +330,7 @@ int ath11k_mhi_register(struct ath11k_pci *ab_pci)
+ 	mhi_ctrl->cntrl_dev = ab->dev;
+ 	mhi_ctrl->fw_image = ab_pci->amss_path;
+ 	mhi_ctrl->regs = ab->mem;
++	mhi_ctrl->reg_len = ab->mem_len;
+ 
+ 	ret = ath11k_mhi_get_msi(ab_pci);
+ 	if (ret) {
diff --git a/package/kernel/mac80211/patches/ath11k/100-ath11k-load-appropriate-board-data-from-board-id.patch b/package/kernel/mac80211/patches/ath11k/100-ath11k-load-appropriate-board-data-from-board-id.patch
new file mode 100644
index 0000000..2ab24b0
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/100-ath11k-load-appropriate-board-data-from-board-id.patch
@@ -0,0 +1,47 @@
+From 89aec0a67ee30cd11762aede86b3edfdb2433663 Mon Sep 17 00:00:00 2001
+From: Venkateswara Naralasetty <vnaralas@codeaurora.org>
+Date: Thu, 2 Jul 2020 12:04:34 +0530
+Subject: [PATCH] ath11k: load appropriate board data based on board id
+
+This patch adds support to read board id from dts and load
+appropriate board data.
+
+Adding the patch which was removed as a part of commit id -
+Ib950b3271fede9ccf7d53fe9629c38ee729a0ef5
+
+Signed-off-by: Venkateswara Naralasetty <vnaralas@codeaurora.org>
+Signed-off-by: Lavanya Suresh <lavaks@codeaurora.org>
+---
+ drivers/net/wireless/ath/ath11k/qmi.c | 9 +++++++--
+ 1 file changed, 7 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath11k/qmi.c
++++ b/drivers/net/wireless/ath/ath11k/qmi.c
+@@ -1811,9 +1811,11 @@ static int ath11k_qmi_assign_target_mem_
+ 
+ static int ath11k_qmi_request_target_cap(struct ath11k_base *ab)
+ {
++	struct device *dev = ab->dev;
+ 	struct qmi_wlanfw_cap_req_msg_v01 req;
+ 	struct qmi_wlanfw_cap_resp_msg_v01 resp;
+ 	struct qmi_txn txn = {};
++	unsigned int board_id;
+ 	int ret = 0;
+ 	int r;
+ 
+@@ -1853,10 +1855,13 @@ static int ath11k_qmi_request_target_cap
+ 		ab->qmi.target.chip_family = resp.chip_info.chip_family;
+ 	}
+ 
+-	if (resp.board_info_valid)
++	if (!of_property_read_u32(dev->of_node, "qcom,board_id", &board_id) && board_id != 0xFF) {
++		ab->qmi.target.board_id = board_id;
++	} else if (resp.board_info_valid) {
+ 		ab->qmi.target.board_id = resp.board_info.board_id;
+-	else
++	} else {
+ 		ab->qmi.target.board_id = 0xFF;
++	}
+ 
+ 	if (resp.soc_info_valid)
+ 		ab->qmi.target.soc_id = resp.soc_info.soc_id;
diff --git a/package/kernel/mac80211/patches/ath11k/101-ath11k-add-support-for-channel-rx-tx-time-in-survey-dump.patch b/package/kernel/mac80211/patches/ath11k/101-ath11k-add-support-for-channel-rx-tx-time-in-survey-dump.patch
new file mode 100644
index 0000000..dfb00e1
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/101-ath11k-add-support-for-channel-rx-tx-time-in-survey-dump.patch
@@ -0,0 +1,54 @@
+--- a/drivers/net/wireless/ath/ath11k/wmi.c
++++ b/drivers/net/wireless/ath/ath11k/wmi.c
+@@ -1333,6 +1333,7 @@ int ath11k_wmi_pdev_bss_chan_info_reques
+ 				     WMI_TAG_PDEV_BSS_CHAN_INFO_REQUEST) |
+ 			  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);
+ 	cmd->req_type = type;
++	cmd->pdev_id = ar->pdev->pdev_id;
+ 
+ 	ath11k_dbg(ar->ab, ATH11K_DBG_WMI,
+ 		   "WMI bss chan info req type %d\n", type);
+@@ -3122,7 +3123,7 @@ ath11k_wmi_copy_resource_config(struct w
+ 	wmi_cfg->bpf_instruction_size = tg_cfg->bpf_instruction_size;
+ 	wmi_cfg->max_bssid_rx_filters = tg_cfg->max_bssid_rx_filters;
+ 	wmi_cfg->use_pdev_id = tg_cfg->use_pdev_id;
+-	wmi_cfg->flag1 = tg_cfg->atf_config;
++	wmi_cfg->flag1 |= WMI_RSRC_CFG_FLAG1_BSS_CHANNEL_INFO_64;
+ 	wmi_cfg->peer_map_unmap_v2_support = tg_cfg->peer_map_unmap_v2_support;
+ 	wmi_cfg->sched_params = tg_cfg->sched_params;
+ 	wmi_cfg->twt_ap_pdev_count = tg_cfg->twt_ap_pdev_count;
+--- a/drivers/net/wireless/ath/ath11k/wmi.h
++++ b/drivers/net/wireless/ath/ath11k/wmi.h
+@@ -2219,6 +2219,8 @@ struct wmi_init_cmd {
+ 	u32 num_host_mem_chunks;
+ } __packed;
+ 
++#define WMI_RSRC_CFG_FLAG1_BSS_CHANNEL_INFO_64 BIT(5)
++
+ struct wmi_resource_config {
+ 	u32 tlv_header;
+ 	u32 num_vdevs;
+@@ -2935,6 +2937,7 @@ struct wmi_pdev_bss_chan_info_req_cmd {
+ 	u32 tlv_header;
+ 	/* ref wmi_bss_chan_info_req_type */
+ 	u32 req_type;
++	u32 pdev_id;
+ } __packed;
+ 
+ struct wmi_ap_ps_peer_cmd {
+@@ -4028,7 +4031,6 @@ struct wmi_vdev_stopped_event {
+ } __packed;
+ 
+ struct wmi_pdev_bss_chan_info_event {
+-	u32 pdev_id;
+ 	u32 freq;	/* Units in MHz */
+ 	u32 noise_floor;	/* units are dBm */
+ 	/* rx clear - how often the channel was unused */
+@@ -4046,6 +4048,7 @@ struct wmi_pdev_bss_chan_info_event {
+ 	/*rx_cycle cnt for my bss in 64bits format */
+ 	u32 rx_bss_cycle_count_low;
+ 	u32 rx_bss_cycle_count_high;
++	u32 pdev_id;
+ } __packed;
+ 
+ #define WMI_VDEV_INSTALL_KEY_COMPL_STATUS_SUCCESS 0
diff --git a/package/kernel/mac80211/patches/ath11k/207-ath11k-Enable-512MB-profile-in-ath11k.patch b/package/kernel/mac80211/patches/ath11k/207-ath11k-Enable-512MB-profile-in-ath11k.patch
new file mode 100644
index 0000000..8a4c699
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/207-ath11k-Enable-512MB-profile-in-ath11k.patch
@@ -0,0 +1,189 @@
+From 1b402e444ff99efe84d09a084b96c39826783a8e Mon Sep 17 00:00:00 2001
+From: Ramya Gnanasekar <rgnanase@codeaurora.org>
+Date: Thu, 10 Sep 2020 13:33:55 +0530
+Subject: [PATCH] ath11k: Enable 512MB profile in ath11k
+
+Below changes are made to enable 512MB mem mode in ath11k
+        * Makefile changes to implement compilation flag when
+                512MB mem profile is configured.
+        * Enabling 512MB mem profile by default from Makefile
+                for IPQ5018. This can be removed later once
+                512MB profile config is supported.
+        * Update target_mem_mode, number of stations, peer and vap
+                during compile time
+
+Signed-off-by: Ramya Gnanasekar <rgnanase@codeaurora.org>
+---
+ drivers/net/wireless/ath/ath11k/Kconfig |  7 +++++++
+ drivers/net/wireless/ath/ath11k/hw.h    | 14 +++++++++++---
+ drivers/net/wireless/ath/ath11k/qmi.c   |  2 +-
+ drivers/net/wireless/ath/ath11k/qmi.h   |  6 +++++-
+ 4 files changed, 24 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath11k/Kconfig
++++ b/drivers/net/wireless/ath/ath11k/Kconfig
+@@ -60,3 +60,10 @@ config ATH11K_SPECTRAL
+ 	  Enable ath11k spectral scan support
+ 
+ 	  Say Y to enable access to the FFT/spectral data via debugfs.
++
++config ATH11K_MEM_PROFILE_512M
++	bool "ath11k enable 512MB memory profile"
++	depends on ATH11K
++	default n
++	---help---
++	Enables 512MB memory profile for ath11k
+--- a/drivers/net/wireless/ath/ath11k/hw.h
++++ b/drivers/net/wireless/ath/ath11k/hw.h
+@@ -9,11 +9,30 @@
+ #include "wmi.h"
+ 
+ /* Target configuration defines */
++#ifdef CPTCFG_ATH11K_MEM_PROFILE_512M
+ 
++#define TARGET_NUM_VDEVS	8
++#define TARGET_NUM_PEERS_PDEV	(128 + TARGET_NUM_VDEVS)
++/* Max num of stations (per radio) */
++#define TARGET_NUM_STATIONS	128
++#define ATH11K_QMI_TARGET_MEM_MODE	ATH11K_QMI_TARGET_MEM_MODE_512M
++#define ATH11K_DP_TX_COMP_RING_SIZE	8192
++#define ATH11K_DP_RXDMA_MON_STATUS_RING_SIZE	512
++#define ATH11K_DP_RXDMA_MONITOR_BUF_RING_SIZE	128
++#define ATH11K_DP_RXDMA_MONITOR_DST_RING_SIZE	128
++#else
+ /* Num VDEVS per radio */
+ #define TARGET_NUM_VDEVS	(16 + 1)
+ 
+ #define TARGET_NUM_PEERS_PDEV	(512 + TARGET_NUM_VDEVS)
++/* Max num of stations (per radio) */
++#define TARGET_NUM_STATIONS	512
++#define ATH11K_QMI_TARGET_MEM_MODE	ATH11K_QMI_TARGET_MEM_MODE_DEFAULT
++#define ATH11K_DP_TX_COMP_RING_SIZE	32768
++#define ATH11K_DP_RXDMA_MON_STATUS_RING_SIZE	1024
++#define ATH11K_DP_RXDMA_MONITOR_BUF_RING_SIZE	4096
++#define ATH11K_DP_RXDMA_MONITOR_DST_RING_SIZE	2048
++#endif
+ 
+ /* Num of peers for Single Radio mode */
+ #define TARGET_NUM_PEERS_SINGLE		(TARGET_NUM_PEERS_PDEV)
+@@ -24,9 +43,6 @@
+ /* Num of peers for DBS_SBS */
+ #define TARGET_NUM_PEERS_DBS_SBS	(3 * TARGET_NUM_PEERS_PDEV)
+ 
+-/* Max num of stations (per radio) */
+-#define TARGET_NUM_STATIONS	512
+-
+ #define TARGET_NUM_PEERS(x)	TARGET_NUM_PEERS_##x
+ #define TARGET_NUM_PEER_KEYS	2
+ #define TARGET_NUM_TIDS(x)	(2 * TARGET_NUM_PEERS(x) + \
+--- a/drivers/net/wireless/ath/ath11k/qmi.c
++++ b/drivers/net/wireless/ath/ath11k/qmi.c
+@@ -2675,7 +2675,7 @@ int ath11k_qmi_init_service(struct ath11
+ 	memset(&ab->qmi.target_mem, 0, sizeof(struct target_mem_chunk));
+ 	ab->qmi.ab = ab;
+ 
+-	ab->qmi.target_mem_mode = ATH11K_QMI_TARGET_MEM_MODE_DEFAULT;
++	ab->qmi.target_mem_mode = ATH11K_QMI_TARGET_MEM_MODE;
+ 	ret = qmi_handle_init(&ab->qmi.handle, ATH11K_QMI_RESP_LEN_MAX,
+ 			      &ath11k_qmi_ops, ath11k_qmi_msg_handlers);
+ 	if (ret < 0) {
+--- a/drivers/net/wireless/ath/ath11k/qmi.h
++++ b/drivers/net/wireless/ath/ath11k/qmi.h
+@@ -33,10 +33,14 @@
+ 
+ #define QMI_WLANFW_MAX_DATA_SIZE_V01		6144
+ #define ATH11K_FIRMWARE_MODE_OFF		4
+-#define ATH11K_QMI_TARGET_MEM_MODE_DEFAULT	0
+ 
+ struct ath11k_base;
+ 
++enum ath11k_target_mem_mode {
++	ATH11K_QMI_TARGET_MEM_MODE_DEFAULT = 0,
++	ATH11K_QMI_TARGET_MEM_MODE_512M,
++};
++
+ enum ath11k_qmi_file_type {
+ 	ATH11K_QMI_FILE_TYPE_BDF_GOLDEN,
+ 	ATH11K_QMI_FILE_TYPE_CALDATA,
+--- a/local-symbols
++++ b/local-symbols
+@@ -153,6 +153,7 @@ WCN36XX_DEBUGFS=
+ ATH11K=
+ ATH11K_AHB=
+ ATH11K_PCI=
++ATH11K_MEM_PROFILE_512M=
+ ATH11K_DEBUG=
+ ATH11K_DEBUGFS=
+ ATH11K_TRACING=
+--- a/drivers/net/wireless/ath/ath11k/core.h
++++ b/drivers/net/wireless/ath/ath11k/core.h
+@@ -734,6 +734,9 @@ struct ath11k_base {
+ 	u32 num_db_cap;
+ 
+ 	struct timer_list mon_reap_timer;
++
++	atomic_t num_max_allowed;
++
+ 	/* must be last */
+ 	u8 drv_priv[0] __aligned(sizeof(void *));
+ };
+--- a/drivers/net/wireless/ath/ath11k/dp.h
++++ b/drivers/net/wireless/ath/ath11k/dp.h
+@@ -174,8 +174,9 @@ struct ath11k_pdev_dp {
+ 
+ #define DP_WBM_RELEASE_RING_SIZE	64
+ #define DP_TCL_DATA_RING_SIZE		512
+-#define DP_TX_COMP_RING_SIZE		32768
++#define DP_TX_COMP_RING_SIZE		ATH11K_DP_TX_COMP_RING_SIZE
+ #define DP_TX_IDR_SIZE			DP_TX_COMP_RING_SIZE
++#define DP_TX_COMP_MAX_ALLOWED		((DP_TX_COMP_RING_SIZE << 1)/3)
+ #define DP_TCL_CMD_RING_SIZE		32
+ #define DP_TCL_STATUS_RING_SIZE		32
+ #define DP_REO_DST_RING_MAX		4
+@@ -188,9 +189,9 @@ struct ath11k_pdev_dp {
+ #define DP_RXDMA_BUF_RING_SIZE		4096
+ #define DP_RXDMA_REFILL_RING_SIZE	2048
+ #define DP_RXDMA_ERR_DST_RING_SIZE	1024
+-#define DP_RXDMA_MON_STATUS_RING_SIZE	1024
+-#define DP_RXDMA_MONITOR_BUF_RING_SIZE	4096
+-#define DP_RXDMA_MONITOR_DST_RING_SIZE	2048
++#define DP_RXDMA_MON_STATUS_RING_SIZE	ATH11K_DP_RXDMA_MON_STATUS_RING_SIZE
++#define DP_RXDMA_MONITOR_BUF_RING_SIZE	ATH11K_DP_RXDMA_MONITOR_BUF_RING_SIZE
++#define DP_RXDMA_MONITOR_DST_RING_SIZE	ATH11K_DP_RXDMA_MONITOR_BUF_RING_SIZE
+ #define DP_RXDMA_MONITOR_DESC_RING_SIZE	4096
+ 
+ #define DP_RX_BUFFER_SIZE	2048
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
+@@ -262,6 +262,7 @@ tcl_ring_sel:
+ 			skb->data, skb->len);
+ 
+ 	atomic_inc(&ar->dp.num_tx_pending);
++	atomic_inc(&ab->num_max_allowed);
+ 
+ 	return 0;
+ 
+@@ -308,6 +309,7 @@ static void ath11k_dp_tx_free_txbuf(stru
+ 	ar = ab->pdevs[mac_id].ar;
+ 	if (atomic_dec_and_test(&ar->dp.num_tx_pending))
+ 		wake_up(&ar->dp.tx_empty_waitq);
++	atomic_dec(&ab->num_max_allowed);
+ }
+ 
+ static void
+@@ -339,6 +341,7 @@ ath11k_dp_tx_htt_tx_complete_buf(struct
+ 
+ 	if (atomic_dec_and_test(&ar->dp.num_tx_pending))
+ 		wake_up(&ar->dp.tx_empty_waitq);
++	atomic_dec(&ab->num_max_allowed);
+ 
+ 	dma_unmap_single(ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);
+ 
+@@ -600,6 +603,7 @@ void ath11k_dp_tx_completion_handler(str
+ 			wake_up(&ar->dp.tx_empty_waitq);
+ 
+ 		ath11k_dp_tx_complete_msdu(ar, msdu, &ts);
++		atomic_dec(&ab->num_max_allowed);
+ 	}
+ }
+ 
diff --git a/package/kernel/mac80211/patches/ath11k/983-ath11k-Enable-VHT-for-2G.patch b/package/kernel/mac80211/patches/ath11k/983-ath11k-Enable-VHT-for-2G.patch
new file mode 100644
index 0000000..d5fab8b
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/983-ath11k-Enable-VHT-for-2G.patch
@@ -0,0 +1,35 @@
+--- a/drivers/net/wireless/ath/ath11k/mac.c
++++ b/drivers/net/wireless/ath/ath11k/mac.c
+@@ -1593,9 +1593,9 @@ static void ath11k_peer_assoc_h_phymode(
+ 		} else if (sta->vht_cap.vht_supported &&
+ 		    !ath11k_peer_assoc_h_vht_masked(vht_mcs_mask)) {
+ 			if (sta->bandwidth == IEEE80211_STA_RX_BW_40)
+-				phymode = MODE_11AC_VHT40;
++				phymode = MODE_11AC_VHT40_2G;
+ 			else
+-				phymode = MODE_11AC_VHT20;
++				phymode = MODE_11AC_VHT20_2G;
+ 		} else if (sta->ht_cap.ht_supported &&
+ 			   !ath11k_peer_assoc_h_ht_masked(ht_mcs_mask)) {
+ 			if (sta->bandwidth == IEEE80211_STA_RX_BW_40)
+@@ -3552,6 +3552,9 @@ static void ath11k_mac_setup_ht_vht_cap(
+ 			*ht_cap_info = ht_cap;
+ 		band->ht_cap = ath11k_create_ht_cap(ar, ht_cap,
+ 						    rate_cap_rx_chainmask);
++
++		band->vht_cap = ath11k_create_vht_cap(ar, rate_cap_tx_chainmask,
++						      rate_cap_rx_chainmask);
+ 	}
+ 
+ 	if (cap->supported_bands & WMI_HOST_WLAN_5G_CAP && !ar->supports_6ghz) {
+--- a/drivers/net/wireless/ath/ath11k/wmi.c
++++ b/drivers/net/wireless/ath/ath11k/wmi.c
+@@ -346,6 +346,8 @@ ath11k_pull_mac_phy_cap_svc_ready_ext(st
+ 	 * handled.
+ 	 */
+ 	if (mac_phy_caps->supported_bands & WMI_HOST_WLAN_2G_CAP) {
++		pdev_cap->vht_cap = mac_phy_caps->vht_cap_info_2g;
++		pdev_cap->vht_mcs = mac_phy_caps->vht_supp_mcs_2g;
+ 		pdev_cap->tx_chain_mask = mac_phy_caps->tx_chain_mask_2g;
+ 		pdev_cap->rx_chain_mask = mac_phy_caps->rx_chain_mask_2g;
+ 	} else if (mac_phy_caps->supported_bands & WMI_HOST_WLAN_5G_CAP) {
diff --git a/package/kernel/mac80211/patches/subsys/600-mac80211-allow-vht-on-2g.patch b/package/kernel/mac80211/patches/subsys/600-mac80211-allow-vht-on-2g.patch
new file mode 100644
index 0000000..da9fcd2
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/600-mac80211-allow-vht-on-2g.patch
@@ -0,0 +1,36 @@
+--- a/net/mac80211/vht.c
++++ b/net/mac80211/vht.c
+@@ -135,7 +135,8 @@ ieee80211_vht_cap_ie_to_sta_vht_cap(stru
+ 	have_80mhz = false;
+ 	for (i = 0; i < sband->n_channels; i++) {
+ 		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
+-						IEEE80211_CHAN_NO_80MHZ))
++						IEEE80211_CHAN_NO_80MHZ) &&
++						(sband->band != NL80211_BAND_2GHZ))
+ 			continue;
+ 
+ 		have_80mhz = true;
+--- a/net/mac80211/util.c
++++ b/net/mac80211/util.c
+@@ -1769,7 +1769,8 @@ static int ieee80211_build_preq_ies_band
+ 	/* Check if any channel in this sband supports at least 80 MHz */
+ 	for (i = 0; i < sband->n_channels; i++) {
+ 		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
+-						IEEE80211_CHAN_NO_80MHZ))
++						IEEE80211_CHAN_NO_80MHZ) &&
++						(sband->band != NL80211_BAND_2GHZ))
+ 			continue;
+ 
+ 		have_80mhz = true;
+--- a/net/mac80211/mlme.c
++++ b/net/mac80211/mlme.c
+@@ -4824,7 +4824,8 @@ static int ieee80211_prep_channel(struct
+ 	have_80mhz = false;
+ 	for (i = 0; i < sband->n_channels; i++) {
+ 		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
+-						IEEE80211_CHAN_NO_80MHZ))
++						IEEE80211_CHAN_NO_80MHZ) &&
++						(sband->band != NL80211_BAND_2GHZ))
+ 			continue;
+ 
+ 		have_80mhz = true;
diff --git a/package/kernel/mac80211/patches/subsys/999-mac80211-add-option-for-NSS-support.patch b/package/kernel/mac80211/patches/subsys/999-mac80211-add-option-for-NSS-support.patch
new file mode 100644
index 0000000..22b3ae1
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/999-mac80211-add-option-for-NSS-support.patch
@@ -0,0 +1,261 @@
+--- a/net/mac80211/Kconfig	2019-01-03 21:03:17.839001000 +0800
++++ b/net/mac80211/Kconfig	2019-01-03 21:04:43.931001000 +0800
+@@ -16,6 +16,13 @@
+ 
+ if MAC80211 != n
+ 
++config MAC80211_NSS_SUPPORT
++	bool "Enable NSS support for IPQ platform"
++	default n
++	---help---
++	This option enables support for NSS in boards
++	like AP148.
++
+ config MAC80211_HAS_RC
+ 	bool
+ 
+--- a/local-symbols	2019-01-03 21:24:00.087001000 +0800
++++ b/local-symbols	2019-01-03 21:24:56.535001000 +0800
+@@ -47,6 +47,7 @@ LIB80211_CRYPT_CCMP=
+ LIB80211_CRYPT_TKIP=
+ LIB80211_DEBUG=
+ MAC80211=
++MAC80211_NSS_SUPPORT=
+ MAC80211_HAS_RC=
+ MAC80211_RC_MINSTREL=
+ MAC80211_RC_DEFAULT_MINSTREL=
+--- a/net/mac80211/ieee80211_i.h	2019-01-03 21:04:57.527001000 +0800
++++ b/net/mac80211/ieee80211_i.h	2019-01-03 21:05:44.827001000 +0800
+@@ -35,6 +35,10 @@
+ 
+ extern const struct cfg80211_ops mac80211_config_ops;
+ 
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++#include <nss_api_if.h>
++#endif
++
+ struct ieee80211_local;
+ 
+ /* Maximum number of broadcast/multicast frames to buffer when some of the
+@@ -988,6 +992,14 @@ struct ieee80211_sub_if_data {
+ 
+ 	bool hw_80211_encap;
+ 
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++	struct nss_virt_if_handle *nssctx;
++
++	struct tasklet_struct ieee80211_nss_rq_tasklet;
++	struct sk_buff_head rq_for_nss;
++	int nss_rq_tasklet_pending;
++#endif
++
+ 	/* must be last, dynamically sized area in this! */
+ 	struct ieee80211_vif vif;
+ };
+--- a/net/mac80211/iface.c	2019-01-03 21:06:00.007001000 +0800
++++ b/net/mac80211/iface.c	2019-01-03 21:08:49.535001000 +0800
+@@ -15,6 +15,7 @@
+ #include <linux/if_arp.h>
+ #include <linux/netdevice.h>
+ #include <linux/rtnetlink.h>
++#include <linux/module.h>
+ #include <net/mac80211.h>
+ #include <net/ieee80211_radiotap.h>
+ #include "ieee80211_i.h"
+@@ -26,6 +27,12 @@
+ #include "wme.h"
+ #include "rate.h"
+ 
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++bool is_nss_enable = true;
++module_param(is_nss_enable, bool, 0644);
++MODULE_PARM_DESC(is_nss_enable, "NSS enable module param");
++#endif
++
+ /**
+  * DOC: Interface list locking
+  *
+@@ -695,6 +702,96 @@
+ 	ieee80211_teardown_sdata(IEEE80211_DEV_TO_SUB_IF(dev));
+ }
+ 
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++#define case_rtn_string(val) case val: return #val
++
++static const char *nss_tx_status_str(nss_tx_status_t status)
++{
++	switch (status) {
++		case_rtn_string(NSS_TX_SUCCESS);
++		case_rtn_string(NSS_TX_FAILURE);
++		case_rtn_string(NSS_TX_FAILURE_QUEUE);
++		case_rtn_string(NSS_TX_FAILURE_NOT_READY);
++		case_rtn_string(NSS_TX_FAILURE_TOO_LARGE);
++		case_rtn_string(NSS_TX_FAILURE_TOO_SHORT);
++		case_rtn_string(NSS_TX_FAILURE_NOT_SUPPORTED);
++		case_rtn_string(NSS_TX_FAILURE_BAD_PARAM);
++		case_rtn_string(NSS_TX_FAILURE_NOT_ENABLED);
++		case_rtn_string(NSS_TX_FAILURE_SYNC_BAD_PARAM);
++		case_rtn_string(NSS_TX_FAILURE_SYNC_TIMEOUT);
++		case_rtn_string(NSS_TX_FAILURE_SYNC_FW_ERR);
++	default:
++		return "Unknown NSS TX status";
++	}
++}
++
++static void ieee80211_nss_rq_tasklet(unsigned long _txp)
++{
++	struct ieee80211_sub_if_data *sdata = (struct ieee80211_sub_if_data *)_txp;
++	struct sk_buff *skb;
++	int ret;
++
++	while ((skb = __skb_dequeue(&sdata->rq_for_nss)) != NULL) {
++		skb_push(skb, ETH_HLEN);
++
++		ret = nss_virt_if_tx_buf(sdata->nssctx, skb);
++		if (unlikely(ret)) {
++			sdata_err(sdata, "NSS TX failed with error[%d]: %s\n", ret,
++				  nss_tx_status_str(ret));
++
++			skb_pull(skb, ETH_HLEN);
++			netif_receive_skb(skb);
++		}
++	}
++
++	skb = skb_peek(&sdata->rq_for_nss);
++	if (!skb) {
++		sdata->nss_rq_tasklet_pending = 0;
++	}
++	else {
++		sdata->nss_rq_tasklet_pending = 1;
++		tasklet_schedule(&sdata->ieee80211_nss_rq_tasklet);
++	}
++}
++
++static int ieee80211_init_nss(struct net_device *dev)
++{
++	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
++
++	sdata->nssctx = nss_virt_if_create_sync(dev);
++	if (sdata->nssctx) {
++		sdata_info(sdata, "Created a NSS virtual interface.\n");
++
++		__skb_queue_head_init(&sdata->rq_for_nss);
++		tasklet_init(&sdata->ieee80211_nss_rq_tasklet, ieee80211_nss_rq_tasklet,
++			(unsigned long)sdata);
++		sdata_info(sdata, "RX-Q and tasklet initialized.\n");
++	}
++	else {
++		sdata->nssctx = NULL;
++		sdata_err(sdata, "Failed to create a NSS virtual interface\n");
++	}
++
++	return 0;
++}
++
++static void ieee80211_uninit_nss(struct net_device *dev)
++{
++	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
++
++	ieee80211_uninit(dev);
++
++	if (sdata->nssctx) {
++		nss_virt_if_destroy_sync(sdata->nssctx);
++		sdata_info(sdata, "Destroyed NSS virtual interface\n");
++
++		tasklet_kill(&sdata->ieee80211_nss_rq_tasklet);
++		__skb_queue_purge(&sdata->rq_for_nss);
++		sdata_info(sdata, "RX-Q purged.\n");
++	}
++}
++#endif
++
+ #if LINUX_VERSION_IS_GEQ(5,2,0)
+ static u16 ieee80211_netdev_select_queue(struct net_device *dev,
+ 					 struct sk_buff *skb,
+@@ -742,7 +839,12 @@
+ static const struct net_device_ops ieee80211_dataif_ops = {
+ 	.ndo_open		= ieee80211_open,
+ 	.ndo_stop		= ieee80211_stop,
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++	.ndo_init		= ieee80211_init_nss,
++	.ndo_uninit		= ieee80211_uninit_nss,
++#else
+ 	.ndo_uninit		= ieee80211_uninit,
++#endif
+ 	.ndo_start_xmit		= ieee80211_subif_start_xmit,
+ 	.ndo_set_rx_mode	= ieee80211_set_multicast_list,
+ 	.ndo_set_mac_address 	= ieee80211_change_mac,
+--- a/net/mac80211/rx.c	2019-01-03 21:09:29.503001000 +0800
++++ b/net/mac80211/rx.c	2019-01-03 21:17:42.463001000 +0800
+@@ -32,6 +32,10 @@
+ #include "wme.h"
+ #include "rate.h"
+ 
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++extern bool is_nss_enable;
++#endif
++
+ static inline void ieee80211_rx_stats(struct net_device *dev, u32 len)
+ {
+ 	struct pcpu_sw_netstats *tstats = this_cpu_ptr(netdev_tstats(dev));
+@@ -2604,6 +2608,21 @@
+ 			ether_addr_copy(ehdr->h_dest, sdata->vif.addr);
+ 
+ 		/* deliver to local stack */
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++		if (likely(is_nss_enable && sdata->nssctx)) {
++			__skb_queue_tail(&sdata->rq_for_nss, skb);
++			if(!sdata->nss_rq_tasklet_pending) {
++				sdata->nss_rq_tasklet_pending = 1;
++				tasklet_schedule(&sdata->ieee80211_nss_rq_tasklet);
++			}
++		}
++		else {
++			if (rx->list)
++				list_add_tail(&skb->list, rx->list);
++			else
++				netif_receive_skb(skb);
++		}
++#else
+ 		if (rx->list)
+ #if LINUX_VERSION_IS_GEQ(4,19,0)
+ 			list_add_tail(&skb->list, rx->list);
+@@ -2612,6 +2631,7 @@
+ #endif
+ 		else
+ 			netif_receive_skb(skb);
++#endif
+ 	}
+ }
+ 
+@@ -4461,6 +4481,21 @@
+ 	/* deliver to local stack */
+ 	skb->protocol = eth_type_trans(skb, fast_rx->dev);
+ 	memset(skb->cb, 0, sizeof(skb->cb));
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++	if (likely(is_nss_enable && rx->sdata->nssctx)) {
++		__skb_queue_tail(&rx->sdata->rq_for_nss, skb);
++		if(!rx->sdata->nss_rq_tasklet_pending) {
++			rx->sdata->nss_rq_tasklet_pending = 1;
++			tasklet_schedule(&rx->sdata->ieee80211_nss_rq_tasklet);
++		}
++	}
++	else {
++		if (rx->list)
++			list_add_tail(&skb->list, rx->list);
++		else
++			netif_receive_skb(skb);
++	}
++#else
+ 	if (rx->list)
+ #if LINUX_VERSION_IS_GEQ(4,19,0)
+ 		list_add_tail(&skb->list, rx->list);
+@@ -4469,7 +4504,7 @@
+ #endif
+ 	else
+ 		netif_receive_skb(skb);
+-
++#endif
+ }
+ 
+ static bool ieee80211_invoke_fast_rx(struct ieee80211_rx_data *rx,
diff --git a/package/network/utils/ethtool/Makefile b/package/network/utils/ethtool/Makefile
index a82e5c9..024f901 100644
--- a/package/network/utils/ethtool/Makefile
+++ b/package/network/utils/ethtool/Makefile
@@ -39,7 +39,7 @@ define Package/ethtool-full
   VARIANT:=full
   PROVIDES:=ethtool
   CONFLICTS:=ethtool
-  DEPENDS:=+libmnl
+  DEPENDS:=+ETHTOOL_NETLINK:libmnl
 endef
 
 define Package/ethtool/description
diff --git a/target/linux/ipq807x/Makefile b/target/linux/ipq807x/Makefile
index dab05ca..003893b 100644
--- a/target/linux/ipq807x/Makefile
+++ b/target/linux/ipq807x/Makefile
@@ -2,13 +2,19 @@ include $(TOPDIR)/rules.mk
 
 ARCH:=aarch64
 BOARD:=ipq807x
-BOARDNAME:=Qualcomm Atheros IPQ807x
-FEATURES:=squashfs ramdisk source-only
+BOARDNAME:=Qualcomm IPQ807x
+FEATURES:=squashfs ramdisk fpu nand source-only
 KERNELNAME:=Image dtbs
 CPU_TYPE:=cortex-a53
+SUBTARGETS:=generic
 
-KERNEL_PATCHVER:=5.4
+KERNEL_PATCHVER:=5.10
 
 include $(INCLUDE_DIR)/target.mk
+DEFAULT_PACKAGES += \
+	kmod-usb3 kmod-usb-dwc3 kmod-usb-dwc3-qcom \
+	kmod-leds-gpio kmod-gpio-button-hotplug \
+	ath11k-firmware-ipq8074 kmod-ath11k-ahb \
+	wpad-basic-wolfssl kmod-qca-nss-dp
 
 $(eval $(call BuildTarget))
diff --git a/target/linux/ipq807x/base-files/etc/board.d/01_leds b/target/linux/ipq807x/base-files/etc/board.d/01_leds
new file mode 100644
index 0000000..1c195c8
--- /dev/null
+++ b/target/linux/ipq807x/base-files/etc/board.d/01_leds
@@ -0,0 +1,17 @@
+
+. /lib/functions/uci-defaults.sh
+
+board_config_update
+
+board=$(board_name)
+
+case "$board" in
+redmi,ax6|\
+xiaomi,ax3600)
+	ucidef_set_led_netdev "wan" "WAN" "blue:network" "eth0"
+	;;
+esac
+
+board_config_flush
+
+exit 0
diff --git a/target/linux/ipq807x/base-files/etc/board.d/02_network b/target/linux/ipq807x/base-files/etc/board.d/02_network
new file mode 100644
index 0000000..dae3188
--- /dev/null
+++ b/target/linux/ipq807x/base-files/etc/board.d/02_network
@@ -0,0 +1,32 @@
+#
+# Copyright (c) 2015 The Linux Foundation. All rights reserved.
+# Copyright (c) 2011-2015 OpenWrt.org
+#
+
+. /lib/functions/uci-defaults.sh
+. /lib/functions/system.sh
+
+ipq807x_setup_interfaces()
+{
+	local board="$1"
+
+	case "$board" in
+	redmi,ax6|\
+	xiaomi,ax3600)
+		ucidef_set_interfaces_lan_wan "eth1 eth2 eth3" "eth0"
+		;;
+	xiaomi,ax9000)
+		ucidef_set_interfaces_lan_wan "eth0 eth1 eth2 eth3" "eth4"
+		;;
+	*)
+		echo "Unsupported hardware. Network interfaces not initialized"
+		;;
+	esac
+}
+
+board_config_update
+board=$(board_name)
+ipq807x_setup_interfaces $board
+board_config_flush
+
+exit 0
diff --git a/target/linux/ipq807x/base-files/etc/hotplug.d/firmware/11-ath10k-caldata b/target/linux/ipq807x/base-files/etc/hotplug.d/firmware/11-ath10k-caldata
new file mode 100644
index 0000000..22d9e34
--- /dev/null
+++ b/target/linux/ipq807x/base-files/etc/hotplug.d/firmware/11-ath10k-caldata
@@ -0,0 +1,27 @@
+#!/bin/sh
+
+[ -e /lib/firmware/$FIRMWARE ] && exit 0
+
+. /lib/functions/caldata.sh
+
+board=$(board_name)
+
+case "$FIRMWARE" in
+"ath10k/cal-pci-0000:01:00.0.bin")
+	case "$board" in
+	xiaomi,ax3600)
+		caldata_extract "0:art" 0x33000 0x844
+		;;
+	esac
+	;;
+"ath10k/cal-pci-0001:01:00.0.bin")
+	case "$board" in
+	xiaomi,ax9000)
+		caldata_extract "0:art" 0x4d000 0x844
+		;;
+	esac
+	;;
+*)
+	exit 1
+	;;
+esac
diff --git a/target/linux/ipq807x/base-files/etc/hotplug.d/firmware/11-ath11k-caldata b/target/linux/ipq807x/base-files/etc/hotplug.d/firmware/11-ath11k-caldata
new file mode 100644
index 0000000..cc96e9f
--- /dev/null
+++ b/target/linux/ipq807x/base-files/etc/hotplug.d/firmware/11-ath11k-caldata
@@ -0,0 +1,29 @@
+#!/bin/sh
+
+[ -e /lib/firmware/$FIRMWARE ] && exit 0
+
+. /lib/functions/caldata.sh
+
+board=$(board_name)
+
+case "$FIRMWARE" in
+"ath11k/IPQ8074/hw2.0/caldata.bin")
+	case "$board" in
+	redmi,ax6|\
+	xiaomi,ax3600|\
+	xiaomi,ax9000)
+		caldata_extract "0:art" 0x1000 0x20000
+		;;
+	esac
+	;;
+"ath11k/QCN9074/hw1.0/caldata.bin")
+	case "$board" in
+	xiaomi,ax9000)
+		caldata_extract "0:art" 0x26800 0x20000
+		;;
+	esac
+	;;
+*)
+	exit 1
+	;;
+esac
diff --git a/target/linux/ipq807x/base-files/etc/init.d/bootcount b/target/linux/ipq807x/base-files/etc/init.d/bootcount
new file mode 100755
index 0000000..fedf3e2
--- /dev/null
+++ b/target/linux/ipq807x/base-files/etc/init.d/bootcount
@@ -0,0 +1,16 @@
+#!/bin/sh /etc/rc.common
+
+START=99
+
+boot() {
+	case $(board_name) in
+	redmi,ax6|\
+	xiaomi,ax3600|\
+	xiaomi,ax9000)
+		# OTA handling should not be used. Reset it just in case.
+		fw_setenv flag_ota_reboot 0
+		# Not strictly needed but useful to handle partition crash condition
+		fw_setenv flag_boot_success 1
+	;;
+	esac
+}
diff --git a/target/linux/ipq807x/base-files/lib/upgrade/platform.sh b/target/linux/ipq807x/base-files/lib/upgrade/platform.sh
new file mode 100644
index 0000000..087884b
--- /dev/null
+++ b/target/linux/ipq807x/base-files/lib/upgrade/platform.sh
@@ -0,0 +1,45 @@
+PART_NAME=firmware
+REQUIRE_IMAGE_METADATA=1
+
+RAMFS_COPY_BIN='fw_printenv fw_setenv'
+RAMFS_COPY_DATA='/etc/fw_env.config /var/lock/fw_printenv.lock'
+
+platform_check_image() {
+	return 0;
+}
+
+platform_do_upgrade() {
+	case "$(board_name)" in
+	redmi,ax6|\
+	xiaomi,ax3600|\
+	xiaomi,ax9000)
+		part_num="$(fw_printenv -n flag_boot_rootfs)"
+		if [ "$part_num" -eq "1" ]; then
+			CI_UBIPART="rootfs_1"
+			target_num=1
+			# Reset fail flag for the current partition
+			# With both partition set to fail, the partition 2 (bit 1)
+			# is loaded
+			fw_setenv flag_try_sys2_failed 0
+		else
+			CI_UBIPART="rootfs"
+			target_num=0
+			# Reset fail flag for the current partition
+			# or uboot will skip the loading of this partition
+			fw_setenv flag_try_sys1_failed 0
+		fi
+
+		# Tell uboot to switch partition
+		fw_setenv flag_boot_rootfs $target_num
+		fw_setenv flag_last_success $target_num
+
+		# Reset success flag
+		fw_setenv flag_boot_success 0
+
+		nand_do_upgrade "$1"
+		;;
+	*)
+		default_do_upgrade "$1"
+		;;
+	esac
+}
diff --git a/target/linux/ipq807x/config-5.10 b/target/linux/ipq807x/config-5.10
new file mode 100644
index 0000000..67c169f
--- /dev/null
+++ b/target/linux/ipq807x/config-5.10
@@ -0,0 +1,513 @@
+CONFIG_64BIT=y
+# CONFIG_APQ_GCC_8084 is not set
+# CONFIG_APQ_MMCC_8084 is not set
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_KEEP_MEMBLOCK=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_ARCH_MMAP_RND_BITS_MAX=24
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS=11
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ARCH_QCOM=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_STACKWALK=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_USES_HIGH_VMA_FLAGS=y
+CONFIG_ARM64=y
+CONFIG_ARM64_4K_PAGES=y
+CONFIG_ARM64_AMU_EXTN=y
+CONFIG_ARM64_BTI=y
+CONFIG_ARM64_CNP=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_ARM64_E0PD=y
+CONFIG_ARM64_ERRATUM_1165522=y
+CONFIG_ARM64_ERRATUM_1286807=y
+CONFIG_ARM64_ERRATUM_1418040=y
+CONFIG_ARM64_HW_AFDBM=y
+CONFIG_ARM64_MODULE_PLTS=y
+CONFIG_ARM64_MTE=y
+CONFIG_ARM64_PAGE_SHIFT=12
+CONFIG_ARM64_PAN=y
+CONFIG_ARM64_PA_BITS=48
+CONFIG_ARM64_PA_BITS_48=y
+CONFIG_ARM64_PTR_AUTH=y
+CONFIG_ARM64_RAS_EXTN=y
+CONFIG_ARM64_SVE=y
+CONFIG_ARM64_TAGGED_ADDR_ABI=y
+CONFIG_ARM64_TLB_RANGE=y
+CONFIG_ARM64_VA_BITS=39
+CONFIG_ARM64_VA_BITS_39=y
+CONFIG_ARM64_VHE=y
+CONFIG_ARM64_WORKAROUND_REPEAT_TLBI=y
+CONFIG_ARM64_WORKAROUND_SPECULATIVE_AT=y
+# CONFIG_ARMV8_DEPRECATED is not set
+CONFIG_ARM_AMBA=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_V2M=y
+CONFIG_ARM_GIC_V3=y
+CONFIG_ARM_GIC_V3_ITS=y
+CONFIG_ARM_GIC_V3_ITS_PCI=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_ARM_PSCI_FW=y
+# CONFIG_ARM_QCOM_CPUFREQ_HW is not set
+# CONFIG_ARM_QCOM_CPUFREQ_NVMEM is not set
+# CONFIG_ARM_SCMI_PROTOCOL is not set
+CONFIG_ARM_SMCCC_SOC_ID=y
+CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_MQ_PCI=y
+CONFIG_BLK_MQ_VIRTIO=y
+CONFIG_BLK_PM=y
+CONFIG_BLOCK_COMPAT=y
+CONFIG_CAVIUM_TX2_ERRATUM_219=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_COMMON_CLK=y
+CONFIG_COMMON_CLK_QCOM=y
+CONFIG_COMPAT=y
+# CONFIG_COMPAT_32BIT_TIME is not set
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_COMPAT_NETLINK_MESSAGES=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+CONFIG_COREDUMP=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_CPUFREQ_DT_PLATDEV=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+CONFIG_CPU_FREQ_GOV_ATTR_SET=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_STAT is not set
+CONFIG_CPU_FREQ_THERMAL=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+CONFIG_CPU_PM=y
+CONFIG_CPU_RMAP=y
+CONFIG_CPU_THERMAL=y
+CONFIG_CRC16=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_DEV_QCE=y
+CONFIG_CRYPTO_DEV_QCE_ENABLE_ALL=y
+# CONFIG_CRYPTO_DEV_QCE_ENABLE_SHA is not set
+# CONFIG_CRYPTO_DEV_QCE_ENABLE_SKCIPHER is not set
+CONFIG_CRYPTO_DEV_QCE_SHA=y
+CONFIG_CRYPTO_DEV_QCE_SKCIPHER=y
+CONFIG_CRYPTO_DEV_QCE_SW_MAX_LEN=512
+CONFIG_CRYPTO_DEV_QCOM_RNG=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_HASH_INFO=y
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_LIB_DES=y
+CONFIG_CRYPTO_LIB_SHA256=y
+CONFIG_CRYPTO_LZO=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_NULL2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_CRYPTO_ZSTD=y
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_DEV_COREDUMP=y
+CONFIG_DMADEVICES=y
+CONFIG_DMA_DIRECT_REMAP=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+CONFIG_DMA_REMAP=y
+CONFIG_DMA_VIRTUAL_CHANNELS=y
+CONFIG_DTC=y
+CONFIG_DT_IDLE_STATES=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_ETHTOOL_NETLINK=y
+CONFIG_FIXED_PHY=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_FRAME_POINTER=y
+CONFIG_FUJITSU_ERRATUM_010001=y
+CONFIG_FW_LOADER_PAGED_BUF=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_GENERIC_GETTIMEOFDAY=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_PHY=y
+CONFIG_GENERIC_PINCONF=y
+CONFIG_GENERIC_PINCTRL_GROUPS=y
+CONFIG_GENERIC_PINMUX_FUNCTIONS=y
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GLOB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_IRQCHIP=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HOLES_IN_ZONE=y
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_QCOM=y
+CONFIG_HZ=250
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+CONFIG_HZ_PERIODIC=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+# CONFIG_I2C_QCOM_CCI is not set
+CONFIG_I2C_QUP=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_IPQ_APSS_6018 is not set
+CONFIG_IPQ_APSS_8074=y
+# CONFIG_IPQ_APSS_PLL is not set
+# CONFIG_IPQ_GCC_4019 is not set
+# CONFIG_IPQ_GCC_6018 is not set
+# CONFIG_IPQ_GCC_806X is not set
+CONFIG_IPQ_GCC_8074=y
+# CONFIG_IPQ_LCC_806X is not set
+CONFIG_IRQCHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_IRQ_FASTEOI_HIERARCHY_HANDLERS=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_IRQ_WORK=y
+# CONFIG_KPSS_XCC is not set
+CONFIG_LIBFDT=y
+CONFIG_LLD_VERSION=0
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_MAILBOX=y
+# CONFIG_MAILBOX_TEST is not set
+CONFIG_MDIO_BUS=y
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_DEVRES=y
+CONFIG_MDIO_IPQ4019=y
+# CONFIG_MDM_GCC_9615 is not set
+# CONFIG_MDM_LCC_9615 is not set
+CONFIG_MEMFD_CREATE=y
+# CONFIG_MFD_HI6421_SPMI is not set
+# CONFIG_MFD_QCOM_RPM is not set
+CONFIG_MFD_SPMI_PMIC=y
+CONFIG_MFD_SYSCON=y
+CONFIG_MHI_BUS=y
+CONFIG_MHI_BUS_DEBUG=y
+CONFIG_MIGRATION=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_CQHCI=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+CONFIG_MMC_SDHCI_MSM=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MODULES_USE_ELF_RELA=y
+# CONFIG_MSM_GCC_8660 is not set
+# CONFIG_MSM_GCC_8916 is not set
+# CONFIG_MSM_GCC_8939 is not set
+# CONFIG_MSM_GCC_8960 is not set
+# CONFIG_MSM_GCC_8974 is not set
+# CONFIG_MSM_GCC_8994 is not set
+# CONFIG_MSM_GCC_8996 is not set
+# CONFIG_MSM_GCC_8998 is not set
+# CONFIG_MSM_GPUCC_8998 is not set
+# CONFIG_MSM_LCC_8960 is not set
+# CONFIG_MSM_MMCC_8960 is not set
+# CONFIG_MSM_MMCC_8974 is not set
+# CONFIG_MSM_MMCC_8996 is not set
+# CONFIG_MSM_MMCC_8998 is not set
+CONFIG_MTD_NAND_CORE=y
+CONFIG_MTD_NAND_ECC=y
+CONFIG_MTD_NAND_ECC_SW_HAMMING=y
+CONFIG_MTD_NAND_QCOM=y
+CONFIG_MTD_QCOMSMEM_PARTS=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_BEB_LIMIT=20
+CONFIG_MTD_UBI_BLOCK=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_NET_FLOW_LIMIT=y
+CONFIG_NET_SWITCHDEV=y
+CONFIG_NLS=y
+CONFIG_NR_CPUS=256
+CONFIG_NVMEM=y
+# CONFIG_NVMEM_SPMI_SDAM is not set
+CONFIG_NVMEM_SYSFS=y
+CONFIG_OF=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_GPIO=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_NET=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_PADATA=y
+CONFIG_PARTITION_PERCPU=y
+CONFIG_PCI=y
+CONFIG_PCIEASPM=y
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_POWER_SUPERSAVE is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIE_DW=y
+CONFIG_PCIE_DW_HOST=y
+CONFIG_PCIE_PME=y
+CONFIG_PCIE_QCOM=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_DOMAINS_GENERIC=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+CONFIG_PGTABLE_LEVELS=3
+CONFIG_PHYLIB=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+# CONFIG_PHY_QCOM_APQ8064_SATA is not set
+# CONFIG_PHY_QCOM_IPQ4019_USB is not set
+# CONFIG_PHY_QCOM_IPQ806X_SATA is not set
+# CONFIG_PHY_QCOM_IPQ806X_USB is not set
+# CONFIG_PHY_QCOM_PCIE2 is not set
+CONFIG_PHY_QCOM_QMP=y
+CONFIG_PHY_QCOM_QUSB2=y
+# CONFIG_PHY_QCOM_USB_HS_28NM is not set
+# CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2 is not set
+# CONFIG_PHY_QCOM_USB_SS is not set
+CONFIG_PINCTRL=y
+# CONFIG_PINCTRL_APQ8064 is not set
+# CONFIG_PINCTRL_APQ8084 is not set
+# CONFIG_PINCTRL_IPQ4019 is not set
+# CONFIG_PINCTRL_IPQ6018 is not set
+# CONFIG_PINCTRL_IPQ8064 is not set
+CONFIG_PINCTRL_IPQ8074=y
+# CONFIG_PINCTRL_MDM9615 is not set
+CONFIG_PINCTRL_MSM=y
+# CONFIG_PINCTRL_MSM8226 is not set
+# CONFIG_PINCTRL_MSM8660 is not set
+# CONFIG_PINCTRL_MSM8916 is not set
+# CONFIG_PINCTRL_MSM8960 is not set
+# CONFIG_PINCTRL_MSM8976 is not set
+# CONFIG_PINCTRL_MSM8994 is not set
+# CONFIG_PINCTRL_MSM8996 is not set
+# CONFIG_PINCTRL_MSM8998 is not set
+# CONFIG_PINCTRL_QCOM_SPMI_PMIC is not set
+# CONFIG_PINCTRL_QCOM_SSBI_PMIC is not set
+# CONFIG_PINCTRL_QCS404 is not set
+# CONFIG_PINCTRL_SC7180 is not set
+# CONFIG_PINCTRL_SDM660 is not set
+# CONFIG_PINCTRL_SDM845 is not set
+# CONFIG_PINCTRL_SM8150 is not set
+# CONFIG_PINCTRL_SM8250 is not set
+CONFIG_PM=y
+# CONFIG_PM8916_WATCHDOG is not set
+CONFIG_PM_CLK=y
+CONFIG_PM_OPP=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_MSM=y
+# CONFIG_POWER_RESET_QCOM_PON is not set
+CONFIG_POWER_SUPPLY=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_QCOM_A53PLL is not set
+# CONFIG_QCOM_AOSS_QMP is not set
+CONFIG_QCOM_APCS_IPC=y
+# CONFIG_QCOM_APR is not set
+CONFIG_QCOM_BAM_DMA=y
+# CONFIG_QCOM_CLK_APCC_MSM8996 is not set
+# CONFIG_QCOM_CLK_APCS_MSM8916 is not set
+# CONFIG_QCOM_COINCELL is not set
+# CONFIG_QCOM_COMMAND_DB is not set
+# CONFIG_QCOM_CPR is not set
+CONFIG_QCOM_EBI2=y
+# CONFIG_QCOM_FASTRPC is not set
+# CONFIG_QCOM_GENI_SE is not set
+# CONFIG_QCOM_GSBI is not set
+# CONFIG_QCOM_HFPLL is not set
+# CONFIG_QCOM_IPCC is not set
+# CONFIG_QCOM_LLCC is not set
+CONFIG_QCOM_MDT_LOADER=y
+# CONFIG_QCOM_OCMEM is not set
+# CONFIG_QCOM_PDC is not set
+CONFIG_QCOM_PIL_INFO=y
+# CONFIG_QCOM_Q6V5_ADSP is not set
+CONFIG_QCOM_Q6V5_COMMON=y
+# CONFIG_QCOM_Q6V5_MSS is not set
+# CONFIG_QCOM_Q6V5_PAS is not set
+CONFIG_QCOM_Q6V5_WCSS=y
+CONFIG_QCOM_QFPROM=y
+CONFIG_QCOM_QMI_HELPERS=y
+# CONFIG_QCOM_RMTFS_MEM is not set
+# CONFIG_QCOM_RPMH is not set
+CONFIG_QCOM_RPROC_COMMON=y
+CONFIG_QCOM_SCM=y
+# CONFIG_QCOM_SCM_DOWNLOAD_MODE_DEFAULT is not set
+# CONFIG_QCOM_SMD_RPM is not set
+CONFIG_QCOM_SMEM=y
+CONFIG_QCOM_SMEM_STATE=y
+CONFIG_QCOM_SMP2P=y
+# CONFIG_QCOM_SMSM is not set
+CONFIG_QCOM_SOCINFO=y
+# CONFIG_QCOM_SYSMON is not set
+CONFIG_QCOM_TSENS=y
+# CONFIG_QCOM_WCNSS_CTRL is not set
+# CONFIG_QCOM_WCNSS_PIL is not set
+CONFIG_QCOM_WDT=y
+# CONFIG_QCS_GCC_404 is not set
+# CONFIG_QCS_Q6SSTOP_404 is not set
+# CONFIG_QCS_TURING_404 is not set
+CONFIG_QRTR=y
+CONFIG_QRTR_MHI=y
+CONFIG_QRTR_SMD=y
+CONFIG_QRTR_TUN=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_RANDOMIZE_BASE=y
+CONFIG_RANDOMIZE_MODULE_REGION_FULL=y
+CONFIG_RATIONAL=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_REGMAP_SPMI=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_QCOM_LABIBB is not set
+CONFIG_REGULATOR_QCOM_SPMI=y
+# CONFIG_REGULATOR_QCOM_USB_VBUS is not set
+# CONFIG_REGULATOR_VQMMC_IPQ4019 is not set
+CONFIG_RELOCATABLE=y
+CONFIG_REMOTEPROC=y
+CONFIG_REMOTEPROC_CDEV=y
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_QCOM_AOSS is not set
+# CONFIG_RESET_QCOM_PDC is not set
+CONFIG_RFS_ACCEL=y
+CONFIG_RODATA_FULL_DEFAULT_ENABLED=y
+CONFIG_RPMSG=y
+CONFIG_RPMSG_CHAR=y
+CONFIG_RPMSG_QCOM_GLINK=y
+CONFIG_RPMSG_QCOM_GLINK_RPM=y
+CONFIG_RPMSG_QCOM_GLINK_SMEM=y
+CONFIG_RPMSG_QCOM_SMD=y
+CONFIG_RPS=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_THERMAL_PRESSURE=y
+# CONFIG_SC_DISPCC_7180 is not set
+# CONFIG_SC_GCC_7180 is not set
+# CONFIG_SC_GPUCC_7180 is not set
+# CONFIG_SC_LPASS_CORECC_7180 is not set
+# CONFIG_SC_MSS_7180 is not set
+# CONFIG_SC_VIDEOCC_7180 is not set
+# CONFIG_SDM_CAMCC_845 is not set
+# CONFIG_SDM_DISPCC_845 is not set
+# CONFIG_SDM_GCC_660 is not set
+# CONFIG_SDM_GCC_845 is not set
+# CONFIG_SDM_GPUCC_845 is not set
+# CONFIG_SDM_LPASSCC_845 is not set
+# CONFIG_SDM_VIDEOCC_845 is not set
+CONFIG_SERIAL_8250_FSL=y
+CONFIG_SERIAL_MCTRL_GPIO=y
+CONFIG_SERIAL_MSM=y
+CONFIG_SERIAL_MSM_CONSOLE=y
+CONFIG_SGL_ALLOC=y
+CONFIG_SMP=y
+# CONFIG_SM_GCC_8150 is not set
+# CONFIG_SM_GCC_8250 is not set
+# CONFIG_SM_GPUCC_8150 is not set
+# CONFIG_SM_GPUCC_8250 is not set
+# CONFIG_SM_VIDEOCC_8150 is not set
+# CONFIG_SM_VIDEOCC_8250 is not set
+CONFIG_SOC_BUS=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+CONFIG_SPI_QUP=y
+CONFIG_SPMI=y
+# CONFIG_SPMI_HISI3670 is not set
+CONFIG_SPMI_MSM_PMIC_ARB=y
+# CONFIG_SPMI_PMIC_CLKDIV is not set
+CONFIG_SRCU=y
+CONFIG_SWIOTLB=y
+CONFIG_SWPHY=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_NETLINK=y
+CONFIG_THERMAL_OF=y
+CONFIG_THREAD_INFO_IN_TASK=y
+CONFIG_TICK_CPU_ACCOUNTING=y
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_TREE_RCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_UBIFS_FS=y
+CONFIG_UNMAP_KERNEL_AT_EL0=y
+CONFIG_USB=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_SUPPORT=y
+CONFIG_VIRTIO=y
+# CONFIG_VIRTIO_BLK is not set
+# CONFIG_VIRTIO_NET is not set
+CONFIG_VMAP_STACK=y
+CONFIG_WANT_DEV_COREDUMP=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_XPS=y
+CONFIG_XXHASH=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZONE_DMA32=y
+CONFIG_ZSTD_COMPRESS=y
+CONFIG_ZSTD_DECOMPRESS=y
diff --git a/target/linux/ipq807x/config-default b/target/linux/ipq807x/config-default
deleted file mode 100644
index 295a7b4..0000000
--- a/target/linux/ipq807x/config-default
+++ /dev/null
@@ -1,648 +0,0 @@
-CONFIG_64BIT=y
-# CONFIG_ACPI is not set
-# CONFIG_ALLOW_DEV_COREDUMP is not set
-# CONFIG_APQ_GCC_8084 is not set
-# CONFIG_APQ_MMCC_8084 is not set
-CONFIG_AQUANTIA_PHY=y
-CONFIG_ARCH_CLOCKSOURCE_DATA=y
-CONFIG_ARCH_DMA_ADDR_T_64BIT=y
-CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
-CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
-CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
-CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
-CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
-CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
-CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
-CONFIG_ARCH_HAS_KCOV=y
-CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
-CONFIG_ARCH_HAS_PTE_SPECIAL=y
-CONFIG_ARCH_HAS_SET_MEMORY=y
-CONFIG_ARCH_HAS_SG_CHAIN=y
-CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
-CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
-CONFIG_ARCH_HAS_SYSCALL_WRAPPER=y
-CONFIG_ARCH_HAS_TICK_BROADCAST=y
-CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
-CONFIG_ARCH_HIBERNATION_POSSIBLE=y
-CONFIG_ARCH_MMAP_RND_BITS=18
-CONFIG_ARCH_MMAP_RND_BITS_MAX=24
-CONFIG_ARCH_MMAP_RND_BITS_MIN=18
-CONFIG_ARCH_MMAP_RND_COMPAT_BITS=11
-CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
-CONFIG_ARCH_PROC_KCORE_TEXT=y
-CONFIG_ARCH_QCOM=y
-CONFIG_ARCH_SELECT_MEMORY_MODEL=y
-CONFIG_ARCH_SPARSEMEM_DEFAULT=y
-CONFIG_ARCH_SPARSEMEM_ENABLE=y
-CONFIG_ARCH_SUPPORTS_ACPI=y
-CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
-CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
-CONFIG_ARCH_SUPPORTS_INT128=y
-CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
-CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
-CONFIG_ARCH_SUPPORTS_UPROBES=y
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
-CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
-CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
-CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
-CONFIG_ARCH_WANT_FRAME_POINTERS=y
-CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
-CONFIG_ARM64=y
-# CONFIG_ARM64_16K_PAGES is not set
-CONFIG_ARM64_4K_PAGES=y
-# CONFIG_ARM64_64K_PAGES is not set
-CONFIG_ARM64_CONT_SHIFT=4
-# CONFIG_ARM64_CRYPTO is not set
-CONFIG_ARM64_ERRATUM_819472=y
-CONFIG_ARM64_ERRATUM_824069=y
-CONFIG_ARM64_ERRATUM_826319=y
-CONFIG_ARM64_ERRATUM_827319=y
-CONFIG_ARM64_ERRATUM_832075=y
-CONFIG_ARM64_ERRATUM_843419=y
-CONFIG_ARM64_ERRATUM_845719=y
-CONFIG_ARM64_HW_AFDBM=y
-# CONFIG_ARM64_LSE_ATOMICS is not set
-CONFIG_ARM64_MODULE_PLTS=y
-CONFIG_ARM64_PAGE_SHIFT=12
-CONFIG_ARM64_PAN=y
-CONFIG_ARM64_PA_BITS=48
-CONFIG_ARM64_PA_BITS_48=y
-# CONFIG_ARM64_PMEM is not set
-# CONFIG_ARM64_PTDUMP_DEBUGFS is not set
-# CONFIG_ARM64_RANDOMIZE_TEXT_OFFSET is not set
-CONFIG_ARM64_SSBD=y
-CONFIG_ARM64_SVE=y
-CONFIG_ARM64_UAO=y
-CONFIG_ARM64_VA_BITS=39
-CONFIG_ARM64_VA_BITS_39=y
-# CONFIG_ARM64_VA_BITS_48 is not set
-CONFIG_ARM64_VHE=y
-# CONFIG_ARMV8_DEPRECATED is not set
-CONFIG_ARM_AMBA=y
-CONFIG_ARM_ARCH_TIMER=y
-CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
-CONFIG_ARM_CCI=y
-CONFIG_ARM_CCI400_COMMON=y
-CONFIG_ARM_CCI400_PMU=y
-CONFIG_ARM_CCI_PMU=y
-CONFIG_ARM_CPUIDLE=y
-CONFIG_ARM_GIC=y
-CONFIG_ARM_GIC_V2M=y
-CONFIG_ARM_GIC_V3=y
-CONFIG_ARM_GIC_V3_ITS=y
-CONFIG_ARM_GIC_V3_ITS_PCI=y
-CONFIG_ARM_PMU=y
-CONFIG_ARM_PSCI_FW=y
-# CONFIG_ARM_QCOM_CPUFREQ_KRYO is not set
-# CONFIG_ARM_SCMI_PROTOCOL is not set
-# CONFIG_ARM_SP805_WATCHDOG is not set
-CONFIG_ASN1=y
-CONFIG_ASSOCIATIVE_ARRAY=y
-CONFIG_ASYMMETRIC_KEY_TYPE=y
-CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
-CONFIG_AT803X_PHY=y
-CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
-CONFIG_BLK_DEV_NVME=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_BLK_DEV_RAM_SIZE=4096
-CONFIG_BLK_MQ_PCI=y
-CONFIG_BLK_MQ_VIRTIO=y
-CONFIG_BLOCK_COMPAT=y
-CONFIG_BUILD_BIN2C=y
-# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_CLEANCACHE=y
-CONFIG_CLKDEV_LOOKUP=y
-CONFIG_CLONE_BACKWARDS=y
-CONFIG_CLZ_TAB=y
-CONFIG_COMMON_CLK=y
-CONFIG_COMMON_CLK_QCOM=y
-CONFIG_COMMON_CLK_XGENE=y
-CONFIG_COMPAT=y
-CONFIG_COMPAT_32BIT_TIME=y
-CONFIG_COMPAT_BINFMT_ELF=y
-CONFIG_COMPAT_NETLINK_MESSAGES=y
-CONFIG_COMPAT_OLD_SIGACTION=y
-CONFIG_CONFIGFS_FS=y
-CONFIG_COREDUMP=y
-CONFIG_CORESIGHT=y
-# CONFIG_CORESIGHT_CATU is not set
-# CONFIG_CORESIGHT_CPU_DEBUG is not set
-# CONFIG_CORESIGHT_DYNAMIC_REPLICATOR is not set
-CONFIG_CORESIGHT_LINKS_AND_SINKS=y
-CONFIG_CORESIGHT_LINK_AND_SINK_TMC=y
-# CONFIG_CORESIGHT_SINK_ETBV10 is not set
-CONFIG_CORESIGHT_SINK_TPIU=y
-CONFIG_CORESIGHT_SOURCE_ETM4X=y
-CONFIG_CORESIGHT_STM=y
-CONFIG_CPUFREQ_DT=y
-CONFIG_CPUFREQ_DT_PLATDEV=y
-# CONFIG_CPU_BIG_ENDIAN is not set
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
-CONFIG_CPU_FREQ_GOV_ATTR_SET=y
-CONFIG_CPU_FREQ_GOV_COMMON=y
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=y
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_STAT=y
-# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
-CONFIG_CPU_IDLE=y
-CONFIG_CPU_IDLE_GOV_LADDER=y
-CONFIG_CPU_IDLE_GOV_MENU=y
-CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
-CONFIG_CPU_PM=y
-CONFIG_CPU_RMAP=y
-# CONFIG_CPU_THERMAL is not set
-CONFIG_CRC16=y
-# CONFIG_CRC32_SARWATE is not set
-CONFIG_CRC32_SLICEBY8=y
-CONFIG_CROSS_MEMORY_ATTACH=y
-CONFIG_CRYPTO_ACOMP2=y
-CONFIG_CRYPTO_AEAD=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_AKCIPHER=y
-CONFIG_CRYPTO_AKCIPHER2=y
-CONFIG_CRYPTO_ARC4=y
-CONFIG_CRYPTO_CCM=y
-CONFIG_CRYPTO_CMAC=y
-CONFIG_CRYPTO_CRC32C=y
-CONFIG_CRYPTO_CTR=y
-CONFIG_CRYPTO_DEFLATE=y
-# CONFIG_CRYPTO_DEV_QCOM_RNG is not set
-CONFIG_CRYPTO_DRBG=y
-CONFIG_CRYPTO_DRBG_HMAC=y
-CONFIG_CRYPTO_DRBG_MENU=y
-CONFIG_CRYPTO_ECHAINIV=y
-CONFIG_CRYPTO_GCM=y
-CONFIG_CRYPTO_GF128MUL=y
-CONFIG_CRYPTO_GHASH=y
-CONFIG_CRYPTO_HASH=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_HASH_INFO=y
-CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_HW=y
-CONFIG_CRYPTO_JITTERENTROPY=y
-CONFIG_CRYPTO_KPP2=y
-CONFIG_CRYPTO_LZO=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
-CONFIG_CRYPTO_NULL=y
-CONFIG_CRYPTO_NULL2=y
-CONFIG_CRYPTO_RNG=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_RNG_DEFAULT=y
-CONFIG_CRYPTO_SEQIV=y
-CONFIG_CRYPTO_SHA256=y
-CONFIG_CRYPTO_SHA512=y
-CONFIG_CRYPTO_WORKQUEUE=y
-CONFIG_DCACHE_WORD_ACCESS=y
-CONFIG_DEBUG_BUGVERBOSE=y
-CONFIG_DEBUG_GPIO=y
-CONFIG_DECOMPRESS_GZIP=y
-CONFIG_DEVMEM=y
-CONFIG_DMADEVICES=y
-CONFIG_DMA_DIRECT_OPS=y
-CONFIG_DMA_ENGINE=y
-CONFIG_DMA_OF=y
-CONFIG_DMA_VIRTUAL_CHANNELS=y
-CONFIG_DMI=y
-CONFIG_DMIID=y
-# CONFIG_DMI_SYSFS is not set
-CONFIG_DTC=y
-CONFIG_DT_IDLE_STATES=y
-CONFIG_DYNAMIC_DEBUG=y
-CONFIG_EDAC_SUPPORT=y
-CONFIG_EFI=y
-CONFIG_EFIVAR_FS=m
-CONFIG_EFI_ARMSTUB=y
-CONFIG_EFI_ARMSTUB_DTB_LOADER=y
-# CONFIG_EFI_CAPSULE_LOADER is not set
-CONFIG_EFI_ESRT=y
-CONFIG_EFI_PARAMS_FROM_FDT=y
-CONFIG_EFI_RUNTIME_WRAPPERS=y
-CONFIG_EFI_STUB=y
-# CONFIG_EFI_TEST is not set
-# CONFIG_EFI_VARS is not set
-CONFIG_EXT4_FS=y
-# CONFIG_EXT4_USE_FOR_EXT2 is not set
-CONFIG_FB=y
-CONFIG_FB_CMDLINE=y
-# CONFIG_FB_EFI is not set
-CONFIG_FIXED_PHY=y
-CONFIG_FIX_EARLYCON_MEM=y
-# CONFIG_FLATMEM_MANUAL is not set
-CONFIG_FRAME_POINTER=y
-CONFIG_FRAME_WARN=2048
-CONFIG_FREEZER=y
-CONFIG_FS_IOMAP=y
-CONFIG_FS_MBCACHE=y
-CONFIG_GENERIC_ALLOCATOR=y
-CONFIG_GENERIC_ARCH_TOPOLOGY=y
-CONFIG_GENERIC_BUG=y
-CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
-CONFIG_GENERIC_CPU_AUTOPROBE=y
-CONFIG_GENERIC_CPU_VULNERABILITIES=y
-CONFIG_GENERIC_CSUM=y
-CONFIG_GENERIC_EARLY_IOREMAP=y
-CONFIG_GENERIC_IDLE_POLL_SETUP=y
-CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
-CONFIG_GENERIC_IRQ_MIGRATION=y
-CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
-CONFIG_GENERIC_IRQ_SHOW=y
-CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
-CONFIG_GENERIC_MSI_IRQ=y
-CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
-CONFIG_GENERIC_PCI_IOMAP=y
-CONFIG_GENERIC_PHY=y
-CONFIG_GENERIC_PINCONF=y
-CONFIG_GENERIC_PINCTRL_GROUPS=y
-CONFIG_GENERIC_PINMUX_FUNCTIONS=y
-CONFIG_GENERIC_SCHED_CLOCK=y
-CONFIG_GENERIC_SMP_IDLE_THREAD=y
-CONFIG_GENERIC_STRNCPY_FROM_USER=y
-CONFIG_GENERIC_STRNLEN_USER=y
-CONFIG_GENERIC_TIME_VSYSCALL=y
-CONFIG_GPIOLIB=y
-CONFIG_GPIOLIB_IRQCHIP=y
-CONFIG_HANDLE_DOMAIN_IRQ=y
-CONFIG_HARDEN_BRANCH_PREDICTOR=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_HAS_DMA=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT_MAP=y
-CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
-CONFIG_HAVE_ARCH_AUDITSYSCALL=y
-CONFIG_HAVE_ARCH_BITREVERSE=y
-CONFIG_HAVE_ARCH_HUGE_VMAP=y
-CONFIG_HAVE_ARCH_JUMP_LABEL=y
-CONFIG_HAVE_ARCH_KASAN=y
-CONFIG_HAVE_ARCH_KGDB=y
-CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS=y
-CONFIG_HAVE_ARCH_PFN_VALID=y
-CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=y
-CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
-CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
-CONFIG_HAVE_ARCH_TRACEHOOK=y
-CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
-CONFIG_HAVE_ARCH_VMAP_STACK=y
-CONFIG_HAVE_ARM_SMCCC=y
-CONFIG_HAVE_CLK=y
-CONFIG_HAVE_CLK_PREPARE=y
-CONFIG_HAVE_CMPXCHG_DOUBLE=y
-CONFIG_HAVE_CMPXCHG_LOCAL=y
-CONFIG_HAVE_CONTEXT_TRACKING=y
-CONFIG_HAVE_C_RECORDMCOUNT=y
-CONFIG_HAVE_DEBUG_BUGVERBOSE=y
-CONFIG_HAVE_DEBUG_KMEMLEAK=y
-CONFIG_HAVE_DMA_CONTIGUOUS=y
-CONFIG_HAVE_DYNAMIC_FTRACE=y
-CONFIG_HAVE_EBPF_JIT=y
-CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
-CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
-CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
-CONFIG_HAVE_FUNCTION_TRACER=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_HAVE_GENERIC_GUP=y
-CONFIG_HAVE_HW_BREAKPOINT=y
-CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
-CONFIG_HAVE_MEMBLOCK=y
-CONFIG_HAVE_MEMORY_PRESENT=y
-CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
-CONFIG_HAVE_NET_DSA=y
-CONFIG_HAVE_PATA_PLATFORM=y
-CONFIG_HAVE_PERF_EVENTS=y
-CONFIG_HAVE_PERF_REGS=y
-CONFIG_HAVE_PERF_USER_STACK_DUMP=y
-CONFIG_HAVE_RCU_TABLE_FREE=y
-CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
-CONFIG_HAVE_RSEQ=y
-CONFIG_HAVE_SCHED_AVG_IRQ=y
-CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
-CONFIG_HAVE_UID16=y
-CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
-CONFIG_HOLES_IN_ZONE=y
-CONFIG_HOTPLUG_CPU=y
-# CONFIG_HUGETLBFS is not set
-CONFIG_HWSPINLOCK=y
-CONFIG_HWSPINLOCK_QCOM=y
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_COMPAT=y
-CONFIG_I2C_HELPER_AUTO=y
-CONFIG_I2C_QUP=y
-CONFIG_IIO=y
-# CONFIG_IIO_BUFFER is not set
-# CONFIG_IIO_TRIGGER is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_IPQ_GCC_4019 is not set
-# CONFIG_IPQ_GCC_806X is not set
-CONFIG_IPQ_GCC_8074=y
-# CONFIG_IPQ_LCC_806X is not set
-CONFIG_IRQCHIP=y
-CONFIG_IRQ_DOMAIN=y
-CONFIG_IRQ_DOMAIN_HIERARCHY=y
-CONFIG_IRQ_FORCED_THREADING=y
-CONFIG_IRQ_TIME_ACCOUNTING=y
-CONFIG_IRQ_WORK=y
-CONFIG_JBD2=y
-CONFIG_KEYS=y
-CONFIG_KEYS_COMPAT=y
-# CONFIG_KVM is not set
-CONFIG_LEDS_TLC591XX=y
-CONFIG_LIBFDT=y
-CONFIG_LOCK_DEBUGGING_SUPPORT=y
-CONFIG_LOCK_SPIN_ON_OWNER=y
-CONFIG_LZO_COMPRESS=y
-CONFIG_LZO_DECOMPRESS=y
-CONFIG_MAILBOX=y
-# CONFIG_MAILBOX_TEST is not set
-CONFIG_MDIO_BITBANG=y
-CONFIG_MDIO_BUS=y
-CONFIG_MDIO_DEVICE=y
-CONFIG_MDIO_GPIO=y
-# CONFIG_MDM_GCC_9615 is not set
-# CONFIG_MDM_LCC_9615 is not set
-CONFIG_MEMFD_CREATE=y
-CONFIG_MFD_QCOM_RPM=y
-CONFIG_MFD_SPMI_PMIC=y
-CONFIG_MFD_SYSCON=y
-CONFIG_MIGRATION=y
-CONFIG_MMC=y
-CONFIG_MMC_ARMMMCI=y
-CONFIG_MMC_BLOCK=y
-CONFIG_MMC_BLOCK_MINORS=32
-CONFIG_MMC_QCOM_DML=y
-CONFIG_MMC_SDHCI=y
-CONFIG_MMC_SDHCI_IO_ACCESSORS=y
-CONFIG_MMC_SDHCI_MSM=y
-# CONFIG_MMC_SDHCI_PCI is not set
-CONFIG_MMC_SDHCI_PLTFM=y
-CONFIG_MODULES_TREE_LOOKUP=y
-CONFIG_MODULES_USE_ELF_RELA=y
-CONFIG_MPILIB=y
-# CONFIG_MSM_GCC_8660 is not set
-# CONFIG_MSM_GCC_8916 is not set
-# CONFIG_MSM_GCC_8960 is not set
-# CONFIG_MSM_GCC_8974 is not set
-# CONFIG_MSM_GCC_8994 is not set
-# CONFIG_MSM_GCC_8996 is not set
-# CONFIG_MSM_GCC_8998 is not set
-# CONFIG_MSM_LCC_8960 is not set
-# CONFIG_MSM_MMCC_8960 is not set
-# CONFIG_MSM_MMCC_8974 is not set
-# CONFIG_MSM_MMCC_8996 is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_M25P80=y
-CONFIG_MTD_NAND=y
-CONFIG_MTD_NAND_ECC=y
-CONFIG_MTD_NAND_QCOM=y
-CONFIG_MTD_SPI_NOR=y
-CONFIG_MTD_SPLIT_FIRMWARE=y
-CONFIG_MTD_SPLIT_FIT_FW=y
-CONFIG_MTD_UBI=y
-CONFIG_MTD_UBI_BEB_LIMIT=20
-CONFIG_MTD_UBI_BLOCK=y
-CONFIG_MTD_UBI_GLUEBI=y
-CONFIG_MTD_UBI_WL_THRESHOLD=4096
-CONFIG_MUTEX_SPIN_ON_OWNER=y
-CONFIG_NEED_DMA_MAP_STATE=y
-CONFIG_NEED_SG_DMA_LENGTH=y
-CONFIG_NET_FLOW_LIMIT=y
-CONFIG_NET_PTP_CLASSIFY=y
-CONFIG_NET_SWITCHDEV=y
-# CONFIG_NET_VENDOR_CAVIUM is not set
-CONFIG_NLS=y
-CONFIG_NO_BOOTMEM=y
-CONFIG_NO_HZ=y
-CONFIG_NO_HZ_COMMON=y
-CONFIG_NO_HZ_IDLE=y
-CONFIG_NR_CPUS=4
-# CONFIG_NUMA is not set
-CONFIG_NVMEM=y
-CONFIG_NVME_CORE=y
-# CONFIG_NVME_MULTIPATH is not set
-CONFIG_OF=y
-CONFIG_OF_ADDRESS=y
-CONFIG_OF_EARLY_FLATTREE=y
-CONFIG_OF_FLATTREE=y
-CONFIG_OF_GPIO=y
-CONFIG_OF_IRQ=y
-CONFIG_OF_KOBJ=y
-CONFIG_OF_MDIO=y
-CONFIG_OF_NET=y
-CONFIG_OF_RESERVED_MEM=y
-CONFIG_OID_REGISTRY=y
-CONFIG_OLD_SIGSUSPEND3=y
-CONFIG_PADATA=y
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_PARTITION_PERCPU=y
-CONFIG_PCI=y
-CONFIG_PCIE_DW=y
-CONFIG_PCIE_DW_HOST=y
-CONFIG_PCIE_QCOM=y
-CONFIG_PCI_DOMAINS=y
-CONFIG_PCI_DOMAINS_GENERIC=y
-CONFIG_PCI_LABEL=y
-CONFIG_PCI_MSI=y
-CONFIG_PCI_MSI_IRQ_DOMAIN=y
-CONFIG_PGTABLE_LEVELS=3
-CONFIG_PHYLIB=y
-CONFIG_PHYS_ADDR_T_64BIT=y
-# CONFIG_PHY_QCOM_APQ8064_SATA is not set
-# CONFIG_PHY_QCOM_IPQ806X_SATA is not set
-# CONFIG_PHY_QCOM_QMP is not set
-# CONFIG_PHY_QCOM_QUSB2 is not set
-# CONFIG_PHY_QCOM_UFS is not set
-CONFIG_PINCTRL=y
-# CONFIG_PINCTRL_APQ8064 is not set
-# CONFIG_PINCTRL_APQ8084 is not set
-# CONFIG_PINCTRL_IPQ4019 is not set
-# CONFIG_PINCTRL_IPQ8064 is not set
-CONFIG_PINCTRL_IPQ8074=y
-# CONFIG_PINCTRL_MDM9615 is not set
-CONFIG_PINCTRL_MSM=y
-# CONFIG_PINCTRL_MSM8660 is not set
-# CONFIG_PINCTRL_MSM8916 is not set
-# CONFIG_PINCTRL_MSM8960 is not set
-# CONFIG_PINCTRL_MSM8994 is not set
-# CONFIG_PINCTRL_MSM8996 is not set
-# CONFIG_PINCTRL_MSM8998 is not set
-CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
-# CONFIG_PINCTRL_QCOM_SSBI_PMIC is not set
-# CONFIG_PINCTRL_SDM845 is not set
-CONFIG_PM=y
-CONFIG_PM_CLK=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_OPP=y
-CONFIG_PM_SLEEP=y
-CONFIG_PM_SLEEP_SMP=y
-CONFIG_POWER_RESET=y
-CONFIG_POWER_RESET_MSM=y
-# CONFIG_POWER_RESET_QCOM_PON is not set
-CONFIG_POWER_SUPPLY=y
-CONFIG_PPS=y
-CONFIG_PREEMPT=y
-CONFIG_PREEMPT_COUNT=y
-# CONFIG_PREEMPT_NONE is not set
-CONFIG_PREEMPT_RCU=y
-CONFIG_PRINTK_TIME=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_PTP_1588_CLOCK=y
-CONFIG_PWM=y
-CONFIG_PWM_SYSFS=y
-CONFIG_QCOM_A53PLL=y
-# CONFIG_QCOM_APCS_IPC is not set
-CONFIG_QCOM_BAM_DMA=y
-# CONFIG_QCOM_CLK_RPM is not set
-# CONFIG_QCOM_COINCELL is not set
-# CONFIG_QCOM_COMMAND_DB is not set
-CONFIG_QCOM_EBI2=y
-# CONFIG_QCOM_GENI_SE is not set
-CONFIG_QCOM_GSBI=y
-# CONFIG_QCOM_LLCC is not set
-# CONFIG_QCOM_PDC is not set
-CONFIG_QCOM_QFPROM=y
-# CONFIG_QCOM_RMTFS_MEM is not set
-# CONFIG_QCOM_RPMH is not set
-CONFIG_QCOM_SMEM=y
-CONFIG_QCOM_SMEM_STATE=y
-CONFIG_QCOM_SMP2P=y
-# CONFIG_QCOM_SMSM is not set
-CONFIG_QCOM_SPMI_VADC=y
-CONFIG_QCOM_TSENS=y
-CONFIG_QCOM_VADC_COMMON=y
-CONFIG_QCOM_WDT=y
-# CONFIG_QRTR is not set
-CONFIG_QUEUED_RWLOCKS=y
-CONFIG_QUEUED_SPINLOCKS=y
-# CONFIG_RANDOMIZE_BASE is not set
-CONFIG_RATIONAL=y
-CONFIG_RCU_CPU_STALL_TIMEOUT=21
-# CONFIG_RCU_EXPERT is not set
-CONFIG_RCU_NEED_SEGCBLIST=y
-CONFIG_RCU_STALL_COMMON=y
-CONFIG_RD_GZIP=y
-CONFIG_REFCOUNT_FULL=y
-CONFIG_REGMAP=y
-CONFIG_REGMAP_I2C=y
-CONFIG_REGMAP_MMIO=y
-CONFIG_REGMAP_SPI=y
-CONFIG_REGMAP_SPMI=y
-CONFIG_REGULATOR=y
-CONFIG_REGULATOR_FIXED_VOLTAGE=y
-CONFIG_REGULATOR_GPIO=y
-CONFIG_REGULATOR_QCOM_RPM=y
-CONFIG_REGULATOR_QCOM_SPMI=y
-CONFIG_RELAY=y
-CONFIG_REMOTEPROC=y
-# CONFIG_RESET_ATTACK_MITIGATION is not set
-CONFIG_RESET_CONTROLLER=y
-# CONFIG_RESET_QCOM_AOSS is not set
-CONFIG_RFS_ACCEL=y
-# CONFIG_RPMSG_QCOM_GLINK_SMEM is not set
-# CONFIG_RPMSG_QCOM_SMD is not set
-CONFIG_RPS=y
-CONFIG_RTC_CLASS=y
-# CONFIG_RTC_DRV_EFI is not set
-# CONFIG_RTC_DRV_PM8XXX is not set
-CONFIG_RTC_I2C_AND_SPI=y
-CONFIG_RWSEM_SPIN_ON_OWNER=y
-CONFIG_RWSEM_XCHGADD_ALGORITHM=y
-# CONFIG_SDM_DISPCC_845 is not set
-# CONFIG_SDM_GCC_845 is not set
-# CONFIG_SDM_VIDEOCC_845 is not set
-# CONFIG_SERIAL_8250 is not set
-# CONFIG_SERIAL_AMBA_PL011 is not set
-CONFIG_SERIAL_MSM=y
-CONFIG_SERIAL_MSM_CONSOLE=y
-CONFIG_SGL_ALLOC=y
-CONFIG_SMP=y
-CONFIG_SND=y
-# CONFIG_SND_COMPRESS_OFFLOAD is not set
-CONFIG_SND_JACK=y
-CONFIG_SND_PCM=y
-CONFIG_SND_SOC=y
-# CONFIG_SND_SOC_APQ8016_SBC is not set
-CONFIG_SND_SOC_I2C_AND_SPI=y
-CONFIG_SND_SOC_QCOM=y
-# CONFIG_SND_SOC_STORM is not set
-CONFIG_SOUND=y
-CONFIG_SOUND_OSS_CORE=y
-CONFIG_SOUND_OSS_CORE_PRECLAIM=y
-CONFIG_SPARSEMEM=y
-CONFIG_SPARSEMEM_EXTREME=y
-CONFIG_SPARSEMEM_MANUAL=y
-CONFIG_SPARSEMEM_VMEMMAP=y
-CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
-CONFIG_SPARSE_IRQ=y
-CONFIG_SPI=y
-CONFIG_SPI_MASTER=y
-CONFIG_SPI_MEM=y
-CONFIG_SPI_QUP=y
-CONFIG_SPI_SPIDEV=y
-CONFIG_SPMI=y
-CONFIG_SPMI_MSM_PMIC_ARB=y
-# CONFIG_SPMI_PMIC_CLKDIV is not set
-CONFIG_SRCU=y
-# CONFIG_STAGING is not set
-CONFIG_STM=y
-# CONFIG_STM_SOURCE_HEARTBEAT is not set
-# CONFIG_STRIP_ASM_SYMS is not set
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-# CONFIG_SWAP is not set
-CONFIG_SWCONFIG=y
-CONFIG_SWIOTLB=y
-CONFIG_SWPHY=y
-CONFIG_SYSCTL_EXCEPTION_TRACE=y
-CONFIG_SYSVIPC_COMPAT=y
-CONFIG_SYS_SUPPORTS_HUGETLBFS=y
-CONFIG_TASKS_RCU=y
-CONFIG_THERMAL=y
-CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
-CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
-CONFIG_THERMAL_GOV_STEP_WISE=y
-CONFIG_THERMAL_GOV_USER_SPACE=y
-CONFIG_THERMAL_OF=y
-CONFIG_THERMAL_WRITABLE_TRIPS=y
-CONFIG_THREAD_INFO_IN_TASK=y
-CONFIG_TICK_CPU_ACCOUNTING=y
-CONFIG_TIMER_OF=y
-CONFIG_TIMER_PROBE=y
-CONFIG_TREE_SRCU=y
-CONFIG_UBIFS_FS=y
-CONFIG_UCS2_STRING=y
-CONFIG_UEVENT_HELPER_PATH=""
-CONFIG_UNINLINE_SPIN_UNLOCK=y
-CONFIG_UNMAP_KERNEL_AT_EL0=y
-CONFIG_USB_SUPPORT=y
-CONFIG_VIRTIO=y
-# CONFIG_VIRTIO_BLK is not set
-# CONFIG_VIRTIO_CONSOLE is not set
-# CONFIG_VIRTIO_NET is not set
-CONFIG_VIRTUALIZATION=y
-CONFIG_VMAP_STACK=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_WANT_DEV_COREDUMP=y
-CONFIG_WATCHDOG_CORE=y
-# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
-CONFIG_X509_CERTIFICATE_PARSER=y
-CONFIG_XPS=y
-CONFIG_XZ_DEC_ARM=y
-CONFIG_XZ_DEC_BCJ=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZONE_DMA32=y
diff --git a/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8071-ax3600.dts b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8071-ax3600.dts
new file mode 100644
index 0000000..0e5b190
--- /dev/null
+++ b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8071-ax3600.dts
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/* Copyright (c) 2021, Robert Marko <robimarko@gmail.com> */
+
+/dts-v1/;
+
+#include "ipq8071-ax3600.dtsi"
+
+/ {
+	model = "Xiaomi AX3600";
+	compatible = "xiaomi,ax3600", "qcom,ipq8074";
+
+	leds {
+		compatible = "gpio-leds";
+
+		led_system_blue: system-blue {
+			label = "blue:system";
+			gpios = <&tlmm 42 GPIO_ACTIVE_HIGH>;
+		};
+
+		led_system_yellow: system-yellow {
+			label = "yellow:system";
+			gpios = <&tlmm 43 GPIO_ACTIVE_HIGH>;
+		};
+
+		network-yellow {
+			label = "yellow:network";
+			gpios = <&tlmm 22 GPIO_ACTIVE_HIGH>;
+		};
+
+		network-blue {
+			label = "blue:network";
+			gpios = <&tlmm 21 GPIO_ACTIVE_HIGH>;
+		};
+
+		aiot {
+			label = "blue:aiot";
+			gpios = <&tlmm 51 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "phy0tpt";
+		};
+	};
+};
+
+&qmp_pcie_phy0 {
+	status = "okay";
+};
+
+&pcie0 {
+	status = "okay";
+
+	perst-gpio = <&tlmm 52 GPIO_ACTIVE_HIGH>;
+
+	bridge@0,0 {
+		reg = <0x00000000 0 0 0 0>;
+		#address-cells = <3>;
+		#size-cells = <2>;
+		ranges;
+
+		wifi0: wifi@1,0 {
+			status = "okay";
+
+			compatible = "qcom,ath10k";
+			reg = <0x00010000 0 0 0 0>;
+
+			qcom,ath10k-calibration-variant = "Xiaomi-AX3600";
+		};
+	};
+};
+
+&wifi {
+	qcom,ath11k-calibration-variant = "Xiaomi-AX3600";
+};
diff --git a/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8071-ax3600.dtsi b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8071-ax3600.dtsi
new file mode 100644
index 0000000..4d93bda
--- /dev/null
+++ b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8071-ax3600.dtsi
@@ -0,0 +1,498 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/* Copyright (c) 2021, Robert Marko <robimarko@gmail.com> */
+
+#include "ipq8074.dtsi"
+#include "ipq8074-ac-cpu.dtsi"
+#include "ipq8074-ac-nss.dtsi"
+#include "ipq8074-memory-512m.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	interrupt-parent = <&intc>;
+
+	aliases {
+		serial0 = &blsp1_uart5;
+		led-boot = &led_system_yellow;
+		led-failsafe = &led_system_yellow;
+		led-running = &led_system_blue;
+		led-upgrade = &led_system_yellow;
+		/* Aliases as required by u-boot to patch MAC addresses */
+		ethernet1 = &dp2;
+		ethernet2 = &dp3;
+		ethernet3 = &dp4;
+		ethernet4 = &dp5;
+		label-mac-device = &dp2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		bootargs-append = " root=/dev/ubiblock0_1";
+	};
+
+	keys {
+		compatible = "gpio-keys";
+
+		reset {
+			label = "reset";
+			gpios = <&tlmm 34 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_RESTART>;
+		};
+	};
+
+	reserved-memory {
+		/delete-node/ tzapp@4a400000;
+		/delete-node/ q6_etr_dump@50f00000;
+		/delete-node/ m3_dump@51000000;
+	};
+};
+
+&tlmm {
+	mdio_pins: mdio-pins {
+		mdc {
+			pins = "gpio68";
+			function = "mdc";
+			drive-strength = <8>;
+			bias-pull-up;
+		};
+
+		mdio {
+			pins = "gpio69";
+			function = "mdio";
+			drive-strength = <8>;
+			bias-pull-up;
+		};
+	};
+};
+
+&blsp1_uart5 {
+	status = "okay";
+};
+
+&prng {
+	status = "okay";
+};
+
+&cryptobam {
+	status = "okay";
+};
+
+&crypto {
+	status = "okay";
+};
+
+&qpic_bam {
+	status = "okay";
+};
+
+&qpic_nand {
+	status = "okay";
+
+	nand@0 {
+		reg = <0>;
+		nand-ecc-strength = <4>;
+		nand-ecc-step-size = <512>;
+		nand-bus-width = <8>;
+
+		partitions {
+			compatible = "qcom,smem-part";
+		};
+	};
+};
+
+&mdio {
+	status = "okay";
+
+	pinctrl-0 = <&mdio_pins>;
+	pinctrl-names = "default";
+	/*
+	 * Disable the reset GPIO temporarely as it
+	 * resets the 100Mbit LED configuration which
+	 * the bootloader writes.
+	 */
+	//reset-gpios = <&tlmm 37 GPIO_ACTIVE_LOW>;
+
+	ethernet-phy@1 {
+		reg = <1>;
+	};
+
+	ethernet-phy@2 {
+		reg = <2>;
+	};
+
+	ethernet-phy@3 {
+		reg = <3>;
+	};
+
+	ethernet-phy@4 {
+		reg = <4>;
+	};
+};
+
+&ess_switch {
+	switch_cpu_bmp = <0x1>;  /* cpu port bitmap */
+	switch_lan_bmp = <0x1e>; /* lan port bitmap */
+	switch_wan_bmp = <0x20>; /* wan port bitmap */
+	switch_mac_mode = <0x0>; /* mac mode for uniphy instance0*/
+	switch_mac_mode1 = <0xff>; /* mac mode for uniphy instance1*/
+	switch_mac_mode2 = <0xff>; /* mac mode for uniphy instance2*/
+	bm_tick_mode = <0>; /* bm tick mode */
+	tm_tick_mode = <0>; /* tm tick mode */
+	qcom,port_phyinfo {
+		port@0 {
+			port_id = <1>;
+			phy_address = <0>;
+		};
+		port@1 {
+			port_id = <2>;
+			phy_address = <1>;
+		};
+		port@2 {
+			port_id = <3>;
+			phy_address = <2>;
+		};
+		port@3 {
+			port_id = <4>;
+			phy_address = <3>;
+		};
+		port@4 {
+			port_id = <5>;
+			phy_address = <4>;
+		};
+	};
+	port_scheduler_resource {
+		port@0 {
+			port_id = <0>;
+			ucast_queue = <0 143>;
+			mcast_queue = <256 271>;
+			l0sp = <0 35>;
+			l0cdrr = <0 47>;
+			l0edrr = <0 47>;
+			l1cdrr = <0 7>;
+			l1edrr = <0 7>;
+		};
+		port@1 {
+			port_id = <1>;
+			ucast_queue = <144 159>;
+			mcast_queue = <272 275>;
+			l0sp = <36 39>;
+			l0cdrr = <48 63>;
+			l0edrr = <48 63>;
+			l1cdrr = <8 11>;
+			l1edrr = <8 11>;
+		};
+		port@2 {
+			port_id = <2>;
+			ucast_queue = <160 175>;
+			mcast_queue = <276 279>;
+			l0sp = <40 43>;
+			l0cdrr = <64 79>;
+			l0edrr = <64 79>;
+			l1cdrr = <12 15>;
+			l1edrr = <12 15>;
+		};
+		port@3 {
+			port_id = <3>;
+			ucast_queue = <176 191>;
+			mcast_queue = <280 283>;
+			l0sp = <44 47>;
+			l0cdrr = <80 95>;
+			l0edrr = <80 95>;
+			l1cdrr = <16 19>;
+			l1edrr = <16 19>;
+		};
+		port@4 {
+			port_id = <4>;
+			ucast_queue = <192 207>;
+			mcast_queue = <284 287>;
+			l0sp = <48 51>;
+			l0cdrr = <96 111>;
+			l0edrr = <96 111>;
+			l1cdrr = <20 23>;
+			l1edrr = <20 23>;
+		};
+		port@5 {
+			port_id = <5>;
+			ucast_queue = <208 223>;
+			mcast_queue = <288 291>;
+			l0sp = <52 55>;
+			l0cdrr = <112 127>;
+			l0edrr = <112 127>;
+			l1cdrr = <24 27>;
+			l1edrr = <24 27>;
+		};
+		port@6 {
+			port_id = <6>;
+			ucast_queue = <224 239>;
+			mcast_queue = <292 295>;
+			l0sp = <56 59>;
+			l0cdrr = <128 143>;
+			l0edrr = <128 143>;
+			l1cdrr = <28 31>;
+			l1edrr = <28 31>;
+		};
+		port@7 {
+			port_id = <7>;
+			ucast_queue = <240 255>;
+			mcast_queue = <296 299>;
+			l0sp = <60 63>;
+			l0cdrr = <144 159>;
+			l0edrr = <144 159>;
+			l1cdrr = <32 35>;
+			l1edrr = <32 35>;
+		};
+	};
+	port_scheduler_config {
+		port@0 {
+			port_id = <0>;
+			l1scheduler {
+				group@0 {
+					sp = <0 1>; /*L0 SPs*/
+					/*cpri cdrr epri edrr*/
+					cfg = <0 0 0 0>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					/*unicast queues*/
+					ucast_queue = <0 4 8>;
+					/*multicast queues*/
+					mcast_queue = <256 260>;
+					/*sp cpri cdrr epri edrr*/
+					cfg = <0 0 0 0 0>;
+				};
+				group@1 {
+					ucast_queue = <1 5 9>;
+					mcast_queue = <257 261>;
+					cfg = <0 1 1 1 1>;
+				};
+				group@2 {
+					ucast_queue = <2 6 10>;
+					mcast_queue = <258 262>;
+					cfg = <0 2 2 2 2>;
+				};
+				group@3 {
+					ucast_queue = <3 7 11>;
+					mcast_queue = <259 263>;
+					cfg = <0 3 3 3 3>;
+				};
+			};
+		};
+		port@1 {
+			port_id = <1>;
+			l1scheduler {
+				group@0 {
+					sp = <36>;
+					cfg = <0 8 0 8>;
+				};
+				group@1 {
+					sp = <37>;
+					cfg = <1 9 1 9>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <144>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <272>;
+					mcast_loop_pri = <4>;
+					cfg = <36 0 48 0 48>;
+				};
+			};
+		};
+		port@2 {
+			port_id = <2>;
+			l1scheduler {
+				group@0 {
+					sp = <40>;
+					cfg = <0 12 0 12>;
+				};
+				group@1 {
+					sp = <41>;
+					cfg = <1 13 1 13>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <160>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <276>;
+					mcast_loop_pri = <4>;
+					cfg = <40 0 64 0 64>;
+				};
+			};
+		};
+		port@3 {
+			port_id = <3>;
+			l1scheduler {
+				group@0 {
+					sp = <44>;
+					cfg = <0 16 0 16>;
+				};
+				group@1 {
+					sp = <45>;
+					cfg = <1 17 1 17>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <176>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <280>;
+					mcast_loop_pri = <4>;
+					cfg = <44 0 80 0 80>;
+				};
+			};
+		};
+		port@4 {
+			port_id = <4>;
+			l1scheduler {
+				group@0 {
+					sp = <48>;
+					cfg = <0 20 0 20>;
+				};
+				group@1 {
+					sp = <49>;
+					cfg = <1 21 1 21>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <192>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <284>;
+					mcast_loop_pri = <4>;
+					cfg = <48 0 96 0 96>;
+				};
+			};
+		};
+		port@5 {
+			port_id = <5>;
+			l1scheduler {
+				group@0 {
+					sp = <52>;
+					cfg = <0 24 0 24>;
+				};
+				group@1 {
+					sp = <53>;
+					cfg = <1 25 1 25>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <208>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <288>;
+					mcast_loop_pri = <4>;
+					cfg = <52 0 112 0 112>;
+				};
+			};
+		};
+		port@6 {
+			port_id = <6>;
+			l1scheduler {
+				group@0 {
+					sp = <56>;
+					cfg = <0 28 0 28>;
+				};
+				group@1 {
+					sp = <57>;
+					cfg = <1 29 1 29>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <224>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <292>;
+					mcast_loop_pri = <4>;
+					cfg = <56 0 128 0 128>;
+				};
+			};
+		};
+		port@7 {
+			port_id = <7>;
+			l1scheduler {
+				group@0 {
+					sp = <60>;
+					cfg = <0 32 0 32>;
+				};
+				group@1 {
+					sp = <61>;
+					cfg = <1 33 1 33>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <240>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <296>;
+					cfg = <60 0 144 0 144>;
+				};
+			};
+		};
+	};
+};
+
+&soc {
+	dp2: dp2 {
+		device_type = "network";
+		compatible = "qcom,nss-dp";
+		qcom,id = <2>;
+		reg = <0x3a001200 0x200>;
+		qcom,mactype = <0>;
+		local-mac-address = [000000000000];
+		qcom,link-poll = <1>;
+		qcom,phy-mdio-addr = <1>;
+		phy-mode = "sgmii";
+		mdio-bus = <&mdio>;
+	};
+
+	dp3: dp3 {
+		device_type = "network";
+		compatible = "qcom,nss-dp";
+		qcom,id = <3>;
+		reg = <0x3a001400 0x200>;
+		qcom,mactype = <0>;
+		local-mac-address = [000000000000];
+		qcom,link-poll = <1>;
+		qcom,phy-mdio-addr = <2>;
+		phy-mode = "sgmii";
+		mdio-bus = <&mdio>;
+	};
+
+	dp4: dp4 {
+		device_type = "network";
+		compatible = "qcom,nss-dp";
+		qcom,id = <4>;
+		reg = <0x3a001600 0x200>;
+		qcom,mactype = <0>;
+		local-mac-address = [000000000000];
+		qcom,link-poll = <1>;
+		qcom,phy-mdio-addr = <3>;
+		phy-mode = "sgmii";
+		mdio-bus = <&mdio>;
+	};
+
+	dp5: dp5 {
+		device_type = "network";
+		compatible = "qcom,nss-dp";
+		qcom,id = <5>;
+		reg = <0x3a001800 0x200>;
+		qcom,mactype = <0>;
+		local-mac-address = [000000000000];
+		qcom,link-poll = <1>;
+		qcom,phy-mdio-addr = <4>;
+		phy-mode = "sgmii";
+		mdio-bus = <&mdio>;
+	};
+};
+
+&wifi {
+	status = "okay";
+
+	qcom,board_id = <658>;
+};
diff --git a/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8071-ax6.dts b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8071-ax6.dts
new file mode 100644
index 0000000..c66fb95
--- /dev/null
+++ b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8071-ax6.dts
@@ -0,0 +1,39 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/* Copyright (c) 2021, Zhijun You <hujy652@gmail.com> */
+
+/dts-v1/;
+
+#include "ipq8071-ax3600.dtsi"
+
+/ {
+	model = "Redmi AX6";
+	compatible = "redmi,ax6", "qcom,ipq8074";
+
+	leds {
+		compatible = "gpio-leds";
+
+		led_system_blue: system-blue {
+			label = "blue:system";
+			gpios = <&tlmm 21 GPIO_ACTIVE_HIGH>;
+		};
+
+		led_system_yellow: system-yellow {
+			label = "yellow:system";
+			gpios = <&tlmm 22 GPIO_ACTIVE_HIGH>;
+		};
+
+		network-blue {
+			label = "blue:network";
+			gpios = <&tlmm 42 GPIO_ACTIVE_HIGH>;
+		};
+
+		network-yellow {
+			label = "yellow:network";
+			gpios = <&tlmm 43 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&wifi {
+	qcom,ath11k-calibration-variant = "Redmi-AX6";
+};
diff --git a/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8072-ax9000.dts b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8072-ax9000.dts
new file mode 100644
index 0000000..d9a9fdc
--- /dev/null
+++ b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8072-ax9000.dts
@@ -0,0 +1,651 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/* Copyright (c) 2021, Robert Marko <robimarko@gmail.com> */
+
+/dts-v1/;
+
+#include "ipq8074.dtsi"
+#include "ipq8074-hk-cpu.dtsi"
+#include "ipq8074-ac-nss.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	model = "Xiaomi AX9000";
+	compatible = "xiaomi,ax9000", "qcom,ipq8074";
+	interrupt-parent = <&intc>;
+
+	aliases {
+		serial0 = &blsp1_uart5;
+		led-boot = &led_system_yellow;
+		led-failsafe = &led_system_yellow;
+		led-running = &led_system_blue;
+		led-upgrade = &led_system_yellow;
+		/* Aliases as required by u-boot to patch MAC addresses */
+		ethernet0 = &dp1;
+		ethernet1 = &dp2;
+		ethernet2 = &dp3;
+		ethernet3 = &dp4;
+		ethernet4 = &dp5;
+		label-mac-device = &dp5;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		bootargs-append = " root=/dev/ubiblock0_1";
+	};
+
+	keys {
+		compatible = "gpio-keys";
+
+		reset {
+			label = "reset";
+			gpios = <&tlmm 47 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_RESTART>;
+		};
+
+		wps {
+			label = "wps"; /* Labeled Mesh on the device */
+			gpios = <&tlmm 46 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_WPS_BUTTON>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led_system_blue: system-blue {
+			label = "blue:system";
+			gpios = <&tlmm 48 GPIO_ACTIVE_HIGH>;
+			color = <LED_COLOR_ID_BLUE>;
+		};
+
+		led_system_yellow: system-yellow {
+			label = "yellow:system";
+			gpios = <&tlmm 52 GPIO_ACTIVE_HIGH>;
+			color = <LED_COLOR_ID_YELLOW>;
+		};
+
+		network-yellow {
+			label = "yellow:network";
+			gpios = <&tlmm 50 GPIO_ACTIVE_HIGH>;
+			color = <LED_COLOR_ID_YELLOW>;
+		};
+
+		network-blue {
+			label = "blue:network";
+			gpios = <&tlmm 51 GPIO_ACTIVE_HIGH>;
+			color = <LED_COLOR_ID_BLUE>;
+		};
+
+		top-red {
+			label = "red:top";
+			gpios = <&tlmm 63 GPIO_ACTIVE_HIGH>;
+			color = <LED_COLOR_ID_RED>;
+			default-state = "keep";
+		};
+
+		top-green {
+			label = "green:top";
+			gpios = <&tlmm 64 GPIO_ACTIVE_HIGH>;
+			color = <LED_COLOR_ID_GREEN>;
+			default-state = "keep";
+		};
+
+		top-blue {
+			label = "blue:top";
+			gpios = <&tlmm 66 GPIO_ACTIVE_HIGH>;
+			color = <LED_COLOR_ID_BLUE>;
+			default-state = "keep";
+		};
+	};
+};
+
+&tlmm {
+	mdio_pins: mdio-pins {
+		mdc {
+			pins = "gpio68";
+			function = "mdc";
+			drive-strength = <8>;
+			bias-pull-up;
+		};
+
+		mdio {
+			pins = "gpio69";
+			function = "mdio";
+			drive-strength = <8>;
+			bias-pull-up;
+		};
+	};
+
+	i2c_pins: i2c-pins {
+		pins = "gpio0", "gpio2";
+		function = "blsp5_i2c";
+		drive-strength = <8>;
+		bias-disable;
+	};
+};
+
+&blsp1_uart5 {
+	status = "okay";
+};
+
+&blsp1_i2c6 {
+	status = "okay";
+
+	pinctrl-0 = <&i2c_pins>;
+	pinctrl-names = "default";
+
+	emc2301@2f {
+		compatible = "smsc,emc2301";
+		reg = <0x2f>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		fan@0 {
+			reg = <0>;
+			pwm-output-mode = <1>;
+		};
+	};
+};
+
+&prng {
+	status = "okay";
+};
+
+&cryptobam {
+	status = "okay";
+};
+
+&crypto {
+	status = "okay";
+};
+
+&qpic_bam {
+	status = "okay";
+};
+
+&qpic_nand {
+	status = "okay";
+
+	nand@0 {
+		reg = <0>;
+		nand-ecc-strength = <4>;
+		nand-ecc-step-size = <512>;
+		nand-bus-width = <8>;
+
+		partitions {
+			compatible = "qcom,smem-part";
+		};
+	};
+};
+
+&qusb_phy_0 {
+	status = "okay";
+};
+
+&ssphy_0 {
+	status = "okay";
+};
+
+&usb_0 {
+	status = "okay";
+};
+
+&mdio {
+	status = "okay";
+
+	pinctrl-0 = <&mdio_pins>;
+	pinctrl-names = "default";
+	reset-gpios = <&tlmm 37 GPIO_ACTIVE_LOW>;
+
+	ethernet-phy@0 {
+		reg = <0>;
+	};
+
+	ethernet-phy@1 {
+		reg = <1>;
+	};
+
+	ethernet-phy@2 {
+		reg = <2>;
+	};
+
+	ethernet-phy@3 {
+		reg = <3>;
+	};
+
+	ethernet-phy@24 {
+		/*
+		 * It looks like the PHY is too slow for
+		 * auto probing after reset is deasserted
+		 * so set the ID manually.
+		 */
+		compatible = "ethernet-phy-id004d.d101";
+		reg = <24>;
+		reset-gpios = <&tlmm 44 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&qmp_pcie_phy0 {
+	status = "okay";
+};
+
+&pcie0 {
+	status = "okay";
+
+	perst-gpio = <&tlmm 58 GPIO_ACTIVE_LOW>;
+};
+
+&qmp_pcie_phy1 {
+	status = "okay";
+};
+
+&pcie1 {
+	status = "okay";
+
+	perst-gpio = <&tlmm 62 GPIO_ACTIVE_HIGH>;
+
+	bridge@0,0 {
+		reg = <0x00000000 0 0 0 0>;
+		#address-cells = <3>;
+		#size-cells = <2>;
+		ranges;
+
+		wifi@1,0 {
+			status = "okay";
+
+			compatible = "qcom,ath10k";
+			reg = <0x00010000 0 0 0 0>;
+
+			qcom,ath10k-calibration-variant = "Xiaomi-AX9000";
+		};
+	};
+};
+
+&ess_switch {
+	switch_cpu_bmp = <0x1>;  /* cpu port bitmap */
+	switch_lan_bmp = <0x1e>; /* lan port bitmap */
+	switch_wan_bmp = <0x20>; /* wan port bitmap */
+	switch_mac_mode = <0x0>; /* mac mode for uniphy instance0*/
+	switch_mac_mode1 = <0x0f>; /* mac mode for uniphy instance1*/
+	switch_mac_mode2 = <0xff>; /* mac mode for uniphy instance2*/
+	bm_tick_mode = <0>; /* bm tick mode */
+	tm_tick_mode = <0>; /* tm tick mode */
+	qcom,port_phyinfo {
+		port@0 {
+			port_id = <1>;
+			phy_address = <0>;
+		};
+
+		port@1 {
+			port_id = <2>;
+			phy_address = <1>;
+		};
+
+		port@2 {
+			port_id = <3>;
+			phy_address = <2>;
+		};
+
+		port@3 {
+			port_id = <4>;
+			phy_address = <3>;
+		};
+
+		port@4 {
+			port_id = <5>;
+			phy_address = <24>;
+			port_mac_sel = "QGMAC_PORT";
+		};
+	};
+	port_scheduler_resource {
+		port@0 {
+			port_id = <0>;
+			ucast_queue = <0 143>;
+			mcast_queue = <256 271>;
+			l0sp = <0 35>;
+			l0cdrr = <0 47>;
+			l0edrr = <0 47>;
+			l1cdrr = <0 7>;
+			l1edrr = <0 7>;
+		};
+		port@1 {
+			port_id = <1>;
+			ucast_queue = <144 159>;
+			mcast_queue = <272 275>;
+			l0sp = <36 39>;
+			l0cdrr = <48 63>;
+			l0edrr = <48 63>;
+			l1cdrr = <8 11>;
+			l1edrr = <8 11>;
+		};
+		port@2 {
+			port_id = <2>;
+			ucast_queue = <160 175>;
+			mcast_queue = <276 279>;
+			l0sp = <40 43>;
+			l0cdrr = <64 79>;
+			l0edrr = <64 79>;
+			l1cdrr = <12 15>;
+			l1edrr = <12 15>;
+		};
+		port@3 {
+			port_id = <3>;
+			ucast_queue = <176 191>;
+			mcast_queue = <280 283>;
+			l0sp = <44 47>;
+			l0cdrr = <80 95>;
+			l0edrr = <80 95>;
+			l1cdrr = <16 19>;
+			l1edrr = <16 19>;
+		};
+		port@4 {
+			port_id = <4>;
+			ucast_queue = <192 207>;
+			mcast_queue = <284 287>;
+			l0sp = <48 51>;
+			l0cdrr = <96 111>;
+			l0edrr = <96 111>;
+			l1cdrr = <20 23>;
+			l1edrr = <20 23>;
+		};
+		port@5 {
+			port_id = <5>;
+			ucast_queue = <208 223>;
+			mcast_queue = <288 291>;
+			l0sp = <52 55>;
+			l0cdrr = <112 127>;
+			l0edrr = <112 127>;
+			l1cdrr = <24 27>;
+			l1edrr = <24 27>;
+		};
+		port@6 {
+			port_id = <6>;
+			ucast_queue = <224 239>;
+			mcast_queue = <292 295>;
+			l0sp = <56 59>;
+			l0cdrr = <128 143>;
+			l0edrr = <128 143>;
+			l1cdrr = <28 31>;
+			l1edrr = <28 31>;
+		};
+		port@7 {
+			port_id = <7>;
+			ucast_queue = <240 255>;
+			mcast_queue = <296 299>;
+			l0sp = <60 63>;
+			l0cdrr = <144 159>;
+			l0edrr = <144 159>;
+			l1cdrr = <32 35>;
+			l1edrr = <32 35>;
+		};
+	};
+	port_scheduler_config {
+		port@0 {
+			port_id = <0>;
+			l1scheduler {
+				group@0 {
+					sp = <0 1>; /*L0 SPs*/
+					/*cpri cdrr epri edrr*/
+					cfg = <0 0 0 0>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					/*unicast queues*/
+					ucast_queue = <0 4 8>;
+					/*multicast queues*/
+					mcast_queue = <256 260>;
+					/*sp cpri cdrr epri edrr*/
+					cfg = <0 0 0 0 0>;
+				};
+				group@1 {
+					ucast_queue = <1 5 9>;
+					mcast_queue = <257 261>;
+					cfg = <0 1 1 1 1>;
+				};
+				group@2 {
+					ucast_queue = <2 6 10>;
+					mcast_queue = <258 262>;
+					cfg = <0 2 2 2 2>;
+				};
+				group@3 {
+					ucast_queue = <3 7 11>;
+					mcast_queue = <259 263>;
+					cfg = <0 3 3 3 3>;
+				};
+			};
+		};
+		port@1 {
+			port_id = <1>;
+			l1scheduler {
+				group@0 {
+					sp = <36>;
+					cfg = <0 8 0 8>;
+				};
+				group@1 {
+					sp = <37>;
+					cfg = <1 9 1 9>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <144>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <272>;
+					mcast_loop_pri = <4>;
+					cfg = <36 0 48 0 48>;
+				};
+			};
+		};
+		port@2 {
+			port_id = <2>;
+			l1scheduler {
+				group@0 {
+					sp = <40>;
+					cfg = <0 12 0 12>;
+				};
+				group@1 {
+					sp = <41>;
+					cfg = <1 13 1 13>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <160>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <276>;
+					mcast_loop_pri = <4>;
+					cfg = <40 0 64 0 64>;
+				};
+			};
+		};
+		port@3 {
+			port_id = <3>;
+			l1scheduler {
+				group@0 {
+					sp = <44>;
+					cfg = <0 16 0 16>;
+				};
+				group@1 {
+					sp = <45>;
+					cfg = <1 17 1 17>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <176>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <280>;
+					mcast_loop_pri = <4>;
+					cfg = <44 0 80 0 80>;
+				};
+			};
+		};
+		port@4 {
+			port_id = <4>;
+			l1scheduler {
+				group@0 {
+					sp = <48>;
+					cfg = <0 20 0 20>;
+				};
+				group@1 {
+					sp = <49>;
+					cfg = <1 21 1 21>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <192>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <284>;
+					mcast_loop_pri = <4>;
+					cfg = <48 0 96 0 96>;
+				};
+			};
+		};
+		port@5 {
+			port_id = <5>;
+			l1scheduler {
+				group@0 {
+					sp = <52>;
+					cfg = <0 24 0 24>;
+				};
+				group@1 {
+					sp = <53>;
+					cfg = <1 25 1 25>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <208>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <288>;
+					mcast_loop_pri = <4>;
+					cfg = <52 0 112 0 112>;
+				};
+			};
+		};
+		port@6 {
+			port_id = <6>;
+			l1scheduler {
+				group@0 {
+					sp = <56>;
+					cfg = <0 28 0 28>;
+				};
+				group@1 {
+					sp = <57>;
+					cfg = <1 29 1 29>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <224>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <292>;
+					mcast_loop_pri = <4>;
+					cfg = <56 0 128 0 128>;
+				};
+			};
+		};
+		port@7 {
+			port_id = <7>;
+			l1scheduler {
+				group@0 {
+					sp = <60>;
+					cfg = <0 32 0 32>;
+				};
+				group@1 {
+					sp = <61>;
+					cfg = <1 33 1 33>;
+				};
+			};
+			l0scheduler {
+				group@0 {
+					ucast_queue = <240>;
+					ucast_loop_pri = <16>;
+					mcast_queue = <296>;
+					cfg = <60 0 144 0 144>;
+				};
+			};
+		};
+	};
+};
+
+&soc {
+	dp1: dp1 {
+		device_type = "network";
+		compatible = "qcom,nss-dp";
+		qcom,id = <1>;
+		reg = <0x3a001000 0x200>;
+		qcom,mactype = <0>;
+		local-mac-address = [000000000000];
+		qcom,link-poll = <1>;
+		qcom,phy-mdio-addr = <0>;
+		phy-mode = "sgmii";
+		mdio-bus = <&mdio>;
+	};
+
+	dp2: dp2 {
+		device_type = "network";
+		compatible = "qcom,nss-dp";
+		qcom,id = <2>;
+		reg = <0x3a001200 0x200>;
+		qcom,mactype = <0>;
+		local-mac-address = [000000000000];
+		qcom,link-poll = <1>;
+		qcom,phy-mdio-addr = <1>;
+		phy-mode = "sgmii";
+		mdio-bus = <&mdio>;
+	};
+
+	dp3: dp3 {
+		device_type = "network";
+		compatible = "qcom,nss-dp";
+		qcom,id = <3>;
+		reg = <0x3a001400 0x200>;
+		qcom,mactype = <0>;
+		local-mac-address = [000000000000];
+		qcom,link-poll = <1>;
+		qcom,phy-mdio-addr = <2>;
+		phy-mode = "sgmii";
+		mdio-bus = <&mdio>;
+	};
+
+	dp4: dp4 {
+		device_type = "network";
+		compatible = "qcom,nss-dp";
+		qcom,id = <4>;
+		reg = <0x3a001600 0x200>;
+		qcom,mactype = <0>;
+		local-mac-address = [000000000000];
+		qcom,link-poll = <1>;
+		qcom,phy-mdio-addr = <3>;
+		phy-mode = "sgmii";
+		mdio-bus = <&mdio>;
+	};
+
+	dp5: dp5 {
+		device_type = "network";
+		compatible = "qcom,nss-dp";
+		qcom,id = <5>;
+		reg = <0x3a001800 0x200>;
+		qcom,mactype = <0>;
+		local-mac-address = [000000000000];
+		qcom,link-poll = <1>;
+		qcom,phy-mdio-addr = <24>;
+		phy-mode = "sgmii";
+		mdio-bus = <&mdio>;
+	};
+};
+
+&wifi {
+	status = "okay";
+
+	qcom,board_id = <660>;
+	qcom,ath11k-calibration-variant = "Xiaomi-AX9000";
+};
diff --git a/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-ac-cpu.dtsi b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-ac-cpu.dtsi
new file mode 100644
index 0000000..4b2c3c4
--- /dev/null
+++ b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-ac-cpu.dtsi
@@ -0,0 +1,173 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+&CPU0 {
+	operating-points-v2 = <&cpu_opp_table>;
+	voltage-tolerance = <1>;
+	cpu0-supply = <&s3>;
+};
+
+&CPU1 {
+	operating-points-v2 = <&cpu_opp_table>;
+	voltage-tolerance = <1>;
+	cpu-supply = <&s3>;
+};
+
+&CPU2 {
+	operating-points-v2 = <&cpu_opp_table>;
+	voltage-tolerance = <1>;
+	cpu-supply = <&s3>;
+};
+
+&CPU3 {
+	operating-points-v2 = <&cpu_opp_table>;
+	voltage-tolerance = <1>;
+	cpu-supply = <&s3>;
+};
+
+&cpus {
+	cpu_opp_table: cpu_opp_table {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp-1017600000 {
+			opp-hz = /bits/ 64 <1017600000>;
+			opp-microvolt = <704000>;
+			clock-latency-ns = <200000>;
+		};
+		opp-1382400000 {
+			opp-hz = /bits/ 64 <1382400000>;
+			opp-microvolt = <824000>;
+			clock-latency-ns = <200000>;
+		};
+	};
+};
+
+&cpu0_thermal {
+	trips {
+		cpu0_passive: cpu-passive {
+			temperature = <95000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu0_crit: cpu_crit {
+			temperature = <110000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu0_passive>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+	};
+};
+
+&cpu1_thermal {
+	trips {
+		cpu1_passive: cpu-passive {
+			temperature = <95000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu1_crit: cpu_crit {
+			temperature = <110000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu1_passive>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+	};
+};
+
+&cpu2_thermal {
+	trips {
+		cpu2_passive: cpu-passive {
+			temperature = <95000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu2_crit: cpu_crit {
+			temperature = <110000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu2_passive>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+	};
+};
+
+&cpu3_thermal {
+	trips {
+		cpu3_passive: cpu-passive {
+			temperature = <95000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu3_crit: cpu_crit {
+			temperature = <110000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu3_passive>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+	};
+};
+
+&cluster_thermal {
+	trips {
+		cluster_passive: cluster-passive {
+			temperature = <95000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cluster_crit: cluster_crit {
+			temperature = <110000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cluster_passive>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+	};
+};
diff --git a/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-ac-nss.dtsi b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-ac-nss.dtsi
new file mode 100644
index 0000000..608d07f
--- /dev/null
+++ b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-ac-nss.dtsi
@@ -0,0 +1,256 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+&soc {
+	dummy_reg: dummy-regulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "dummy-reg";
+		regulator-min-microvolt = <848000>;
+		regulator-max-microvolt = <848000>;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	nss-common {
+		compatible = "qcom,nss-common";
+		reg = <0x01868010 0x1000>;
+		reg-names = "nss-misc-reset";
+	};
+
+	nss0: nss@40000000 {
+		compatible = "qcom,nss";
+		interrupts = <GIC_SPI 377 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 378 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 379 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 380 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 381 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 382 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 383 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 384 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 385 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 386 IRQ_TYPE_EDGE_RISING>;
+		reg = <0x39000000 0x1000>,
+		      <0x38000000 0x30000>,
+		      <0x0b111000 0x1000>;
+		reg-names = "nphys", "vphys", "qgic-phys";
+		clocks = <&gcc GCC_NSS_NOC_CLK>,
+			 <&gcc GCC_NSS_PTP_REF_CLK>,
+			 <&gcc GCC_NSS_CSR_CLK>, <&gcc GCC_NSS_CFG_CLK>,
+			 <&gcc GCC_NSS_IMEM_CLK>,
+			 <&gcc GCC_NSSNOC_QOSGEN_REF_CLK>,
+			 <&gcc GCC_MEM_NOC_NSS_AXI_CLK>,
+			 <&gcc GCC_NSSNOC_SNOC_CLK>,
+			 <&gcc GCC_NSSNOC_TIMEOUT_REF_CLK>,
+			 <&gcc GCC_NSS_CE_AXI_CLK>,
+			 <&gcc GCC_NSS_CE_APB_CLK>,
+			 <&gcc GCC_NSSNOC_CE_AXI_CLK>,
+			 <&gcc GCC_NSSNOC_CE_APB_CLK>,
+			 <&gcc GCC_NSSNOC_UBI0_AHB_CLK>,
+			 <&gcc GCC_UBI0_CORE_CLK>,
+			 <&gcc GCC_UBI0_AHB_CLK>,
+			 <&gcc GCC_UBI0_AXI_CLK>,
+			 <&gcc GCC_UBI0_MPT_CLK>,
+			 <&gcc GCC_UBI0_NC_AXI_CLK>;
+		clock-names = "nss-noc-clk", "nss-ptp-ref-clk",
+			      "nss-csr-clk", "nss-cfg-clk",
+			      "nss-imem-clk",
+			      "nss-nssnoc-qosgen-ref-clk",
+			      "nss-mem-noc-nss-axi-clk",
+			      "nss-nssnoc-snoc-clk",
+			      "nss-nssnoc-timeout-ref-clk",
+			      "nss-ce-axi-clk", "nss-ce-apb-clk",
+			      "nss-nssnoc-ce-axi-clk",
+			      "nss-nssnoc-ce-apb-clk",
+			      "nss-nssnoc-ahb-clk",
+			      "nss-core-clk", "nss-ahb-clk",
+			      "nss-axi-clk", "nss-mpt-clk",
+			      "nss-nc-axi-clk";
+		qcom,id = <0>;
+		qcom,num-queue = <4>;
+		qcom,num-irq = <10>;
+		qcom,num-pri = <4>;
+		qcom,load-addr = <0x40000000>;
+		qcom,low-frequency = <187200000>;
+		qcom,mid-frequency = <748800000>;
+		qcom,max-frequency = <1497600000>;
+		npu-supply = <&dummy_reg>;
+		mx-supply = <&dummy_reg>;
+		qcom,bridge-enabled;
+		qcom,ipv4-enabled;
+		qcom,ipv4-reasm-enabled;
+		qcom,ipv6-enabled;
+		qcom,ipv6-reasm-enabled;
+		qcom,wlanredirect-enabled;
+		qcom,tun6rd-enabled;
+		qcom,l2tpv2-enabled;
+		qcom,gre-enabled;
+		qcom,gre-redir-enabled;
+		qcom,gre-redir-mark-enabled;
+		qcom,map-t-enabled;
+		qcom,portid-enabled;
+		qcom,ppe-enabled;
+		qcom,pppoe-enabled;
+		qcom,pptp-enabled;
+		qcom,tunipip6-enabled;
+		qcom,shaping-enabled;
+		qcom,wlan-dataplane-offload-enabled;
+		qcom,vlan-enabled;
+		qcom,igs-enabled;
+		qcom,vxlan-enabled;
+		qcom,match-enabled;
+		qcom,mirror-enabled;
+		qcom,udp-st-enabled;
+	};
+
+	nss1: nss@40800000 {
+		compatible = "qcom,nss";
+		interrupts = <GIC_SPI 390 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 391 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 392 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 393 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 394 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 395 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 396 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 397 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 398 IRQ_TYPE_EDGE_RISING>;
+		reg = <0x39400000 0x1000>,
+		      <0x38030000 0x30000>,
+		      <0x0b111000 0x1000>;
+		reg-names = "nphys", "vphys", "qgic-phys";
+		clocks = <&gcc GCC_NSS_NOC_CLK>,
+			 <&gcc GCC_NSS_PTP_REF_CLK>,
+			 <&gcc GCC_NSS_CSR_CLK>, <&gcc GCC_NSS_CFG_CLK>,
+			 <&gcc GCC_NSS_IMEM_CLK>,
+			 <&gcc GCC_NSSNOC_QOSGEN_REF_CLK>,
+			 <&gcc GCC_MEM_NOC_NSS_AXI_CLK>,
+			 <&gcc GCC_NSSNOC_SNOC_CLK>,
+			 <&gcc GCC_NSSNOC_TIMEOUT_REF_CLK>,
+			 <&gcc GCC_NSS_CE_AXI_CLK>,
+			 <&gcc GCC_NSS_CE_APB_CLK>,
+			 <&gcc GCC_NSSNOC_CE_AXI_CLK>,
+			 <&gcc GCC_NSSNOC_CE_APB_CLK>,
+			 <&gcc GCC_NSSNOC_UBI1_AHB_CLK>,
+			 <&gcc GCC_UBI1_CORE_CLK>,
+			 <&gcc GCC_UBI1_AHB_CLK>,
+			 <&gcc GCC_UBI1_AXI_CLK>,
+			 <&gcc GCC_UBI1_MPT_CLK>,
+			 <&gcc GCC_UBI1_NC_AXI_CLK>;
+		clock-names = "nss-noc-clk", "nss-ptp-ref-clk",
+			      "nss-csr-clk", "nss-cfg-clk",
+			      "nss-imem-clk",
+			      "nss-nssnoc-qosgen-ref-clk",
+			      "nss-mem-noc-nss-axi-clk",
+			      "nss-nssnoc-snoc-clk",
+			      "nss-nssnoc-timeout-ref-clk",
+			      "nss-ce-axi-clk", "nss-ce-apb-clk",
+			      "nss-nssnoc-ce-axi-clk",
+			      "nss-nssnoc-ce-apb-clk",
+			      "nss-nssnoc-ahb-clk",
+			      "nss-core-clk", "nss-ahb-clk",
+			      "nss-axi-clk", "nss-mpt-clk",
+			      "nss-nc-axi-clk";
+		qcom,id = <1>;
+		qcom,num-queue = <4>;
+		qcom,num-irq = <9>;
+		qcom,num-pri = <4>;
+		qcom,load-addr = <0x40800000>;
+		qcom,capwap-enabled;
+		qcom,dtls-enabled;
+		qcom,tls-enabled;
+		qcom,crypto-enabled;
+		qcom,ipsec-enabled;
+		qcom,qvpn-enabled;
+		qcom,pvxlan-enabled;
+		qcom,clmap-enabled;
+		qcom,rmnet_rx-enabled;
+	};
+
+	nss_crypto: qcom,nss_crypto {
+		compatible = "qcom,nss-crypto";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		qcom,max-contexts = <64>;
+		qcom,max-context-size = <32>;
+		ranges;
+
+		eip197_node {
+			compatible = "qcom,eip197";
+			reg-names = "crypto_pbase";
+			reg = <0x39800000 0x7ffff>;
+			clocks = <&gcc GCC_NSS_CRYPTO_CLK>,
+				 <&gcc GCC_NSSNOC_CRYPTO_CLK>,
+				 <&gcc GCC_CRYPTO_PPE_CLK>;
+			clock-names = "crypto_clk",
+				      "crypto_nocclk",
+				      "crypto_ppeclk";
+			clock-frequency = /bits/ 64 <600000000 600000000 300000000>;
+			qcom,dma-mask = <0xff>;
+			qcom,transform-enabled;
+			qcom,aes128-cbc;
+			qcom,aes192-cbc;
+			qcom,aes256-cbc;
+			qcom,aes128-ctr;
+			qcom,aes192-ctr;
+			qcom,aes256-ctr;
+			qcom,aes128-ecb;
+			qcom,aes192-ecb;
+			qcom,aes256-ecb;
+			qcom,3des-cbc;
+			qcom,md5-hash;
+			qcom,sha160-hash;
+			qcom,sha224-hash;
+			qcom,sha384-hash;
+			qcom,sha512-hash;
+			qcom,sha256-hash;
+			qcom,md5-hmac;
+			qcom,sha160-hmac;
+			qcom,sha224-hmac;
+			qcom,sha256-hmac;
+			qcom,sha384-hmac;
+			qcom,sha512-hmac;
+			qcom,aes128-gcm-gmac;
+			qcom,aes192-gcm-gmac;
+			qcom,aes256-gcm-gmac;
+			qcom,aes128-cbc-md5-hmac;
+			qcom,aes128-cbc-sha160-hmac;
+			qcom,aes192-cbc-md5-hmac;
+			qcom,aes192-cbc-sha160-hmac;
+			qcom,aes256-cbc-md5-hmac;
+			qcom,aes256-cbc-sha160-hmac;
+			qcom,aes128-ctr-sha160-hmac;
+			qcom,aes192-ctr-sha160-hmac;
+			qcom,aes256-ctr-sha160-hmac;
+			qcom,aes128-ctr-md5-hmac;
+			qcom,aes192-ctr-md5-hmac;
+			qcom,aes256-ctr-md5-hmac;
+			qcom,3des-cbc-md5-hmac;
+			qcom,3des-cbc-sha160-hmac;
+			qcom,aes128-cbc-sha256-hmac;
+			qcom,aes192-cbc-sha256-hmac;
+			qcom,aes256-cbc-sha256-hmac;
+			qcom,aes128-ctr-sha256-hmac;
+			qcom,aes192-ctr-sha256-hmac;
+			qcom,aes256-ctr-sha256-hmac;
+			qcom,3des-cbc-sha256-hmac;
+			qcom,aes128-cbc-sha384-hmac;
+			qcom,aes192-cbc-sha384-hmac;
+			qcom,aes256-cbc-sha384-hmac;
+			qcom,aes128-ctr-sha384-hmac;
+			qcom,aes192-ctr-sha384-hmac;
+			qcom,aes256-ctr-sha384-hmac;
+			qcom,aes128-cbc-sha512-hmac;
+			qcom,aes192-cbc-sha512-hmac;
+			qcom,aes256-cbc-sha512-hmac;
+			qcom,aes128-ctr-sha512-hmac;
+			qcom,aes192-ctr-sha512-hmac;
+			qcom,aes256-ctr-sha512-hmac;
+
+			engine0 {
+				reg_offset = <0x80000>;
+				qcom,ifpp-enabled;
+				qcom,ipue-enabled;
+				qcom,ofpp-enabled;
+				qcom,opue-enabled;
+			};
+		};
+	};
+};
diff --git a/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-hk-cpu.dtsi b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-hk-cpu.dtsi
new file mode 100644
index 0000000..be7b4a9
--- /dev/null
+++ b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-hk-cpu.dtsi
@@ -0,0 +1,258 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+&CPU0 {
+	operating-points-v2 = <&cpu_opp_table>;
+	voltage-tolerance = <1>;
+	cpu0-supply = <&s3>;
+};
+
+&CPU1 {
+	operating-points-v2 = <&cpu_opp_table>;
+	voltage-tolerance = <1>;
+	cpu-supply = <&s3>;
+};
+
+&CPU2 {
+	operating-points-v2 = <&cpu_opp_table>;
+	voltage-tolerance = <1>;
+	cpu-supply = <&s3>;
+};
+
+&CPU3 {
+	operating-points-v2 = <&cpu_opp_table>;
+	voltage-tolerance = <1>;
+	cpu-supply = <&s3>;
+};
+
+&cpus {
+	cpu_opp_table: cpu_opp_table {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp-1017600000 {
+			opp-hz = /bits/ 64 <1017600000>;
+			opp-microvolt = <704000>;
+			clock-latency-ns = <200000>;
+		};
+		opp-1382400000 {
+			opp-hz = /bits/ 64 <1382400000>;
+			opp-microvolt = <784000>;
+			clock-latency-ns = <200000>;
+		};
+		opp-1651200000 {
+			opp-hz = /bits/ 64 <1651200000>;
+			opp-microvolt = <832000>;
+			clock-latency-ns = <200000>;
+		};
+		opp-1843200000 {
+			opp-hz = /bits/ 64 <1843200000>;
+			opp-microvolt = <880000>;
+			clock-latency-ns = <200000>;
+		};
+		opp-1920000000 {
+			opp-hz = /bits/ 64 <1920000000>;
+			opp-microvolt = <904000>;
+			clock-latency-ns = <200000>;
+		};
+		opp-2208000000 {
+			opp-hz = /bits/ 64 <2208000000>;
+			opp-microvolt = <984000>;
+			clock-latency-ns = <200000>;
+		};
+	};
+};
+
+&cpu0_thermal {
+	trips {
+		cpu0_passive_low: cpu-passive-low {
+			temperature = <95000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu0_passive_high: cpu-passive-high {
+			temperature = <100000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu0_crit: cpu_crit {
+			temperature = <110000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu0_passive_low>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+		map1 {
+			trip = <&cpu0_passive_high>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+	};
+};
+
+&cpu1_thermal {
+	trips {
+		cpu1_passive_low: cpu-passive-low {
+			temperature = <95000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu1_passive_high: cpu-passive-high {
+			temperature = <100000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu1_crit: cpu_crit {
+			temperature = <110000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu1_passive_low>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+		map1 {
+			trip = <&cpu1_passive_high>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+	};
+};
+
+&cpu2_thermal {
+	trips {
+		cpu2_passive_low: cpu-passive-low {
+			temperature = <95000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu2_passive_high: cpu-passive-high {
+			temperature = <100000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu2_crit: cpu_crit {
+			temperature = <110000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu2_passive_low>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+		map1 {
+			trip = <&cpu2_passive_high>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+	};
+};
+
+&cpu3_thermal {
+	trips {
+		cpu3_passive_low: cpu-passive-low {
+			temperature = <95000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu3_passive_high: cpu-passive-high {
+			temperature = <100000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cpu3_crit: cpu_crit {
+			temperature = <110000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu3_passive_low>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+		map1 {
+			trip = <&cpu3_passive_high>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+	};
+};
+
+&cluster_thermal {
+	trips {
+		cluster_passive_low: cluster-passive {
+			temperature = <95000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cluster_passive_high: cluster-passive-high {
+			temperature = <100000>;
+			hysteresis = <2000>;
+			type = "passive";
+		};
+
+		cluster_crit: cluster_crit {
+			temperature = <110000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cluster_passive_low>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+		map1 {
+			trip = <&cluster_passive_high>;
+			cooling-device = <&CPU0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&CPU3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+	};
+};
diff --git a/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-memory-512m.dtsi b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-memory-512m.dtsi
new file mode 100644
index 0000000..9dea606
--- /dev/null
+++ b/target/linux/ipq807x/files/arch/arm64/boot/dts/qcom/ipq8074-memory-512m.dtsi
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/* Copyright (C) 2021 AmadeusGhost <amadeus@immortalwrt.org> */
+
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		nss@40000000 {
+			no-map;
+			reg = <0x0 0x40000000 0x0 0x01000000>;
+		};
+
+		uboot@4a600000 {
+			no-map;
+			reg = <0x0 0x4a600000 0x0 0x00400000>;
+		};
+
+		sbl@4aa00000 {
+			no-map;
+			reg = <0x0 0x4aa00000 0x0 0x00100000>;
+		};
+
+		smem_region: smem@4ab00000 {
+			no-map;
+			reg = <0x0 0x4ab00000 0x0 0x00100000>;
+		};
+
+		tz@4ac00000 {
+			no-map;
+			reg = <0x0 0x4ac00000 0x0 0x00400000>;
+		};
+
+		q6_region: wcnss@4b000000 {
+			no-map;
+			reg = <0x0 0x4b000000 0x0 0x03700000>;
+		};
+
+		q6_etr_region: q6_etr_dump@4e700000 {
+			no-map;
+			reg = <0x0 0x4e700000 0x0 0x100000>;
+		};
+
+		wifi_dump@50500000 {
+			no-map;
+			reg = <0x0 0x50500000 0x0 0x200000>;
+		};
+	};
+};
diff --git a/target/linux/ipq807x/files/drivers/hwmon/emc2305.c b/target/linux/ipq807x/files/drivers/hwmon/emc2305.c
new file mode 100644
index 0000000..46aa264
--- /dev/null
+++ b/target/linux/ipq807x/files/drivers/hwmon/emc2305.c
@@ -0,0 +1,523 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2021 Sartura Ltd.
+ *
+ * Driver for the SMSC/Microchip EMC2301/2/3/5 fan controller.
+ *
+ * Author: Robert Marko <robert.marko@sartura.hr>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/delay.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/hwmon.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+
+#define MANUFACTURER_ID_REG	0xfe
+#define SMSC_MANUFACTURER_ID	0x5d
+
+#define PRODUCT_ID_REG		0xfd
+#define EMC2305_PRODUCT_ID	0x34
+#define EMC2303_PRODUCT_ID	0x35
+#define EMC2302_PRODUCT_ID	0x36
+#define EMC2301_PRODUCT_ID	0x37
+
+#define PWM_OUTPUT_CONFIG	0x2b
+
+#define TACH1_HIGH_BYTE		0x3e
+#define TACH1_LOW_BYTE		0x3f
+
+#define FAN1_DRIVE_SETTING	0x30
+#define FAN1_CONFIG		0x32
+#define FAN_CONFIG_ENAG_BIT	BIT(7)
+#define FAN_TACH_RANGE_MASK	GENMASK(6, 5)
+#define FAN_TACH_MULTIPLIER_8	3
+#define FAN_TACH_MULTIPLIER_4	2
+#define FAN_TACH_MULTIPLIER_2	1
+#define FAN_TACH_MULTIPLIER_1	0
+#define FAN_TACH_CONSTANT	3932160
+#define FAN_TACH_READING_MASK	GENMASK(15,3)
+
+#define TACH1_TARGET_LOW_BYTE	0x3c
+#define TACH1_TARGET_HIGH_BYTE	0x3d
+#define TACH_TARGET_HIGH_MASK	GENMASK(12,5)
+#define TACH_TARGET_LOW_MASK	GENMASK(4,0)
+
+#define FANX_OFFSET		0x10
+#define FAN_MAX_NUM		5
+
+struct emc2305_fan_data {
+	u32 pwm_output_type;
+};
+
+struct emc2305_data {
+	struct regmap *regmap;
+	struct i2c_client *client;
+	struct emc2305_fan_data fan_data[FAN_MAX_NUM];
+};
+
+static struct regmap_config emc2305_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0xff,
+};
+
+static int emc2305_read_fan(struct emc2305_data *data, int channel,
+			    long *val)
+{
+	unsigned int regval, high_byte, low_byte;
+	u8 range, multiplier;
+	int ret;
+
+	ret = regmap_read(data->regmap,
+			  FAN1_CONFIG + channel * FANX_OFFSET,
+			  &regval);
+	if (ret < 0)
+		return ret;
+
+	range = FIELD_GET(FAN_TACH_RANGE_MASK, regval);
+
+	switch (range) {
+	case FAN_TACH_MULTIPLIER_8:
+		multiplier = 8;
+		break;
+	case FAN_TACH_MULTIPLIER_4:
+		multiplier = 4;
+		break;
+	case FAN_TACH_MULTIPLIER_2:
+		multiplier = 2;
+		break;
+	case FAN_TACH_MULTIPLIER_1:
+		multiplier = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = regmap_read(data->regmap,
+			  TACH1_HIGH_BYTE + channel * FANX_OFFSET,
+			  &high_byte);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_read(data->regmap,
+			  TACH1_LOW_BYTE + channel * FANX_OFFSET,
+			  &low_byte);
+	if (ret < 0)
+		return ret;
+
+	regval = (u8) high_byte << 8 | (u8) low_byte;
+
+	*val = (FAN_TACH_CONSTANT * multiplier) / FIELD_GET(FAN_TACH_READING_MASK, regval);
+
+	return 0;
+}
+
+static int emc2305_read_fan_target(struct emc2305_data *data, int channel,
+				   long *val)
+{
+	unsigned int regval;
+	int ret;
+
+	ret = regmap_bulk_read(data->regmap,
+			       TACH1_TARGET_LOW_BYTE + channel * FANX_OFFSET,
+			       &regval,
+			       2);
+	if (ret < 0)
+		return ret;
+
+	*val = FIELD_GET(FAN_TACH_READING_MASK, regval);
+
+	return 0;
+}
+
+static int emc2305_set_fan_target(struct emc2305_data *data, int channel,
+				  long val)
+{
+	int ret;
+
+	ret = regmap_write(data->regmap,
+			   TACH1_TARGET_LOW_BYTE + channel * FANX_OFFSET,
+			   val & TACH_TARGET_LOW_MASK);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_write(data->regmap,
+			   TACH1_TARGET_HIGH_BYTE + channel * FANX_OFFSET,
+			   (val & TACH_TARGET_HIGH_MASK) >> 5);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int emc2305_get_pwm_enable(struct emc2305_data *data, int channel,
+				  long *val)
+{
+	unsigned int regval;
+	int ret;
+
+	ret = regmap_read(data->regmap,
+			  FAN1_CONFIG + channel * FANX_OFFSET,
+			  &regval);
+	if (ret < 0)
+		return ret;
+
+	switch (FIELD_GET(FAN_CONFIG_ENAG_BIT, regval)) {
+	case 0:
+		*val = 1;
+		break;
+	case 1:
+		*val = 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int emc2305_set_pwm_enable(struct emc2305_data *data, int channel,
+				  long val)
+{
+	int ret;
+
+	switch (val) {
+	case 1:
+		ret = regmap_update_bits(data->regmap,
+					 FAN1_CONFIG + channel * FANX_OFFSET,
+					 FAN_CONFIG_ENAG_BIT,
+					 0);
+		break;
+	case 2:
+		ret = regmap_update_bits(data->regmap,
+					 FAN1_CONFIG + channel * FANX_OFFSET,
+					 FAN_CONFIG_ENAG_BIT,
+					 FAN_CONFIG_ENAG_BIT);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int emc2305_get_pwm_input(struct emc2305_data *data, int channel,
+				 long *val)
+{
+	unsigned int regval;
+	int ret;
+
+	ret = regmap_read(data->regmap,
+			  FAN1_DRIVE_SETTING + channel * FANX_OFFSET,
+			  &regval);
+	if (ret < 0)
+		return ret;
+
+	*val = regval;
+
+	return 0;
+}
+
+static int emc2305_write(struct device *dev, enum hwmon_sensor_types type,
+			 u32 attr, int channel, long val)
+{
+	struct emc2305_data *data = dev_get_drvdata(dev);
+	int err;
+
+	switch (type) {
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_target:
+			err = emc2305_set_fan_target(data, channel, val);
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_enable:
+			err = emc2305_set_pwm_enable(data, channel, val);
+			break;
+		case hwmon_pwm_input:
+			if (val < 0 || val > 255) {
+				err = -EINVAL;
+				break;
+			}
+			err = regmap_write(data->regmap,
+					   FAN1_DRIVE_SETTING + channel * FANX_OFFSET,
+					   val);
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return err;
+}
+
+static int emc2305_read(struct device *dev, enum hwmon_sensor_types type,
+			u32 attr, int channel, long *val)
+{
+	struct emc2305_data *data = dev_get_drvdata(dev);
+	int err;
+
+	switch (type) {
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			err = emc2305_read_fan(data, channel, val);
+			break;
+		case hwmon_fan_target:
+			err = emc2305_read_fan_target(data, channel, val);
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_enable:
+			err = emc2305_get_pwm_enable(data, channel, val);
+			break;
+		case hwmon_pwm_input:
+			err = emc2305_get_pwm_input(data, channel, val);
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return err;
+}
+
+static umode_t emc2305_is_visible(const void *data, enum hwmon_sensor_types type,
+				  u32 attr, int channel)
+{
+	switch (type) {
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			return 0444;
+		case hwmon_fan_target:
+			return 0644;
+		default:
+			return 0;
+		}
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_enable:
+		case hwmon_pwm_input:
+			return 0644;
+		default:
+			return 0;
+		}
+	default:
+		return 0;
+	}
+}
+
+static const struct hwmon_channel_info *emc2301_info[] = {
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT | HWMON_F_TARGET),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_ENABLE | HWMON_PWM_INPUT),
+
+	NULL
+};
+
+static const struct hwmon_channel_info *emc2302_info[] = {
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT | HWMON_F_TARGET,
+			   HWMON_F_INPUT | HWMON_F_TARGET),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_ENABLE | HWMON_PWM_INPUT,
+			   HWMON_PWM_ENABLE | HWMON_PWM_INPUT),
+	NULL
+};
+
+static const struct hwmon_channel_info *emc2303_info[] = {
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT | HWMON_F_TARGET,
+			   HWMON_F_INPUT | HWMON_F_TARGET,
+			   HWMON_F_INPUT | HWMON_F_TARGET),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_ENABLE | HWMON_PWM_INPUT,
+			   HWMON_PWM_ENABLE | HWMON_PWM_INPUT,
+			   HWMON_PWM_ENABLE | HWMON_PWM_INPUT),
+	NULL
+};
+
+static const struct hwmon_channel_info *emc2305_info[] = {
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT | HWMON_F_TARGET,
+			   HWMON_F_INPUT | HWMON_F_TARGET,
+			   HWMON_F_INPUT | HWMON_F_TARGET,
+			   HWMON_F_INPUT | HWMON_F_TARGET,
+			   HWMON_F_INPUT | HWMON_F_TARGET),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_ENABLE | HWMON_PWM_INPUT,
+			   HWMON_PWM_ENABLE | HWMON_PWM_INPUT,
+			   HWMON_PWM_ENABLE | HWMON_PWM_INPUT,
+			   HWMON_PWM_ENABLE | HWMON_PWM_INPUT,
+			   HWMON_PWM_ENABLE | HWMON_PWM_INPUT),
+	NULL
+};
+
+static const struct hwmon_ops emc2305_hwmon_ops = {
+	.is_visible = emc2305_is_visible,
+	.write = emc2305_write,
+	.read = emc2305_read,
+};
+
+static struct hwmon_chip_info emc2305_chip_info = {
+	.ops = &emc2305_hwmon_ops,
+};
+
+static int emc2305_set_pwm_output_type(struct emc2305_data *data, u32 fan_id)
+{
+	int value, ret;
+
+	if (data->fan_data[fan_id].pwm_output_type)
+		value = BIT(fan_id);
+	else
+		value = 0;
+
+	ret = regmap_update_bits(data->regmap,
+				 PWM_OUTPUT_CONFIG,
+				 BIT(fan_id),
+				 value);
+
+	return ret;
+}
+
+static int emc2305_of_parse(struct device *dev, struct device_node *child,
+			    struct emc2305_data *data)
+{
+	u32 fan_id, pwm_output_type;
+	int ret;
+
+	ret = of_property_read_u32(child, "reg", &fan_id);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32(child, "pwm-output-mode", &pwm_output_type);
+	if (ret)
+		pwm_output_type = 0;
+
+	if (pwm_output_type < 0 || pwm_output_type > 1)
+		return -EINVAL;
+
+	data->fan_data[fan_id].pwm_output_type = pwm_output_type;
+
+	return emc2305_set_pwm_output_type(data, fan_id);
+}
+
+static int emc2305_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct device_node *child;
+	struct emc2305_data *data;
+	struct device *hwmon_dev;
+	const char *model_name;
+	unsigned int regval;
+	int ret;
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->client = client;
+	i2c_set_clientdata(client, data);
+
+	data->regmap = devm_regmap_init_i2c(client, &emc2305_regmap_config);
+	if (IS_ERR(data->regmap)) {
+		dev_err(dev, "failed to allocate register map\n");
+		return PTR_ERR(data->regmap);
+	}
+
+	ret = regmap_read(data->regmap, MANUFACTURER_ID_REG, &regval);
+	if (ret < 0)
+		return ret;
+
+	if (regval != SMSC_MANUFACTURER_ID) {
+		dev_err(dev, "Invalid manufacturer id: 0x%x\n", regval);
+		return -ENODEV;
+	}
+
+	ret = regmap_read(data->regmap, PRODUCT_ID_REG, &regval);
+	if (ret < 0)
+		return ret;
+
+	switch (regval) {
+	case EMC2305_PRODUCT_ID:
+		model_name = "emc2305";
+		emc2305_chip_info.info = emc2305_info;
+		break;
+	case EMC2303_PRODUCT_ID:
+		model_name = "emc2303";
+		emc2305_chip_info.info = emc2303_info;
+		break;
+	case EMC2302_PRODUCT_ID:
+		model_name = "emc2302";
+		emc2305_chip_info.info = emc2302_info;
+		break;
+	case EMC2301_PRODUCT_ID:
+		model_name = "emc2301";
+		emc2305_chip_info.info = emc2301_info;
+		break;
+	default:
+		dev_err(dev, "Unknown ID detected: 0x%x\n", regval);
+		return -ENODEV;
+	}
+
+	dev_info(dev, "%s detected\n", model_name);
+
+	for_each_child_of_node(dev->of_node, child) {
+		ret = emc2305_of_parse(dev, child, data);
+		if (ret) {
+			of_node_put(child);
+			return ret;
+		}
+	}
+
+	hwmon_dev = devm_hwmon_device_register_with_info(dev, model_name,
+							 data, &emc2305_chip_info,
+							 NULL);
+	if (IS_ERR(hwmon_dev))
+		return PTR_ERR(hwmon_dev);
+
+	return 0;
+}
+
+static const struct of_device_id emc2305_of_match[] = {
+	{ .compatible = "smsc,emc2301", },
+	{ .compatible = "smsc,emc2302", },
+	{ .compatible = "smsc,emc2303", },
+	{ .compatible = "smsc,emc2305", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, emc2305_of_match);
+
+static struct i2c_driver emc2305_driver = {
+	.probe_new		= emc2305_probe,
+	.driver = {
+		.name		= "emc2305",
+		.of_match_table	= of_match_ptr(emc2305_of_match),
+	},
+};
+module_i2c_driver(emc2305_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Robert Marko <robert.marko@sartura.hr>");
+MODULE_DESCRIPTION("SMSC EMC2301/2/3/5 fan controller");
diff --git a/target/linux/ipq807x/generic/target.mk b/target/linux/ipq807x/generic/target.mk
new file mode 100644
index 0000000..f5cb1fb
--- /dev/null
+++ b/target/linux/ipq807x/generic/target.mk
@@ -0,0 +1 @@
+BOARDNAME:=Generic
diff --git a/target/linux/ipq807x/image/Makefile b/target/linux/ipq807x/image/Makefile
index 2a0c745..4b0a657 100644
--- a/target/linux/ipq807x/image/Makefile
+++ b/target/linux/ipq807x/image/Makefile
@@ -1,40 +1,18 @@
 include $(TOPDIR)/rules.mk
 include $(INCLUDE_DIR)/image.mk
 
-IPQ807X_KERNEL_LOADADDR = 0x41080000
-DEVICE_DTS_CONFIG = "config@hk01"
-
-define Image/BuildKernel/FIT
-	gzip -9 -c $(KDIR)/Image > $(KDIR)/Image.gz
-	$(call CompressLzma,$(KDIR)/Image,$(KDIR)/Image.gz)
-	$(call Image/BuildKernel/MkFIT,$(1), $(KDIR)/Image.gz, $(DTS_DIR)/qcom/$(1).dtb,gzip,$(2),$(2))
-	$(CP) $(KDIR)/fit-$(1).itb $(BIN_DIR)/$(IMG_PREFIX)-$(1)-fit-uImage.itb
-	mkdir -p $(BIN_DIR)/dtbs/
-	$(CP) $(DTS_DIR)/qcom/ipq*.dtb $(BIN_DIR)/dtbs/
-	$(CP) $(KDIR)/Image $(BIN_DIR)/dtbs/
-endef
-
-define Image/BuildKernel/FITInitramfs
-	$(CP) $(KDIR)/Image-initramfs $(BIN_DIR)/dtbs/
-	$(CP) $(KDIR)/Image-initramfs $(BIN_DIR)/$(IMG_PREFIX)-vmlinux-initramfs.bin
-	$(call Image/BuildKernel/MkFIT,$(1), $(KDIR)/Image-initramfs, $(DTS_DIR)/qcom/$(1).dtb, none,$(2),$(2),-initramfs)
-	$(CP) $(KDIR)/fit-$(1)-initramfs.itb $(BIN_DIR)/$(IMG_PREFIX)-$(1)-fit-uImage-initramfs.itb
-endef
-
-define Image/Build/squashfs
-	$(call prepare_generic_squashfs,$(KDIR)/root.squashfs)
+define Device/Default
+	PROFILES := Default
+	KERNEL_DEPENDS = $$(wildcard $(DTS_DIR)/$$(DEVICE_DTS).dts)
+	KERNEL_LOADADDR := 0x41000000
+	DEVICE_DTS = $$(SOC)-$(lastword $(subst _, ,$(1)))
+	DEVICE_DTS_CONFIG := config@1
+	DEVICE_DTS_DIR := $(DTS_DIR)/qcom
+	IMAGES := sysupgrade.bin
+	IMAGE/sysupgrade.bin = sysupgrade-tar | append-metadata
+	IMAGE/sysupgrade.bin/squashfs :=
 endef
 
-define Image/BuildKernel
-	$(call Image/BuildKernel/FIT,ipq8074-hk01,$(IPQ807X_KERNEL_LOADADDR))
-endef
-
-define Image/BuildKernel/Initramfs
-	$(call Image/BuildKernel/FITInitramfs,ipq8074-hk01,$(IPQ807X_KERNEL_LOADADDR))
-endef
-
-define Image/Build
-	$(call Image/Build/$(1),$(1))
-endef
+include $(SUBTARGET).mk
 
 $(eval $(call BuildImage))
diff --git a/target/linux/ipq807x/image/generic.mk b/target/linux/ipq807x/image/generic.mk
new file mode 100644
index 0000000..ea448cc
--- /dev/null
+++ b/target/linux/ipq807x/image/generic.mk
@@ -0,0 +1,60 @@
+define Device/FitImage
+	KERNEL_SUFFIX := -fit-uImage.itb
+	KERNEL = kernel-bin | gzip | fit gzip $$(DEVICE_DTS_DIR)/$$(DEVICE_DTS).dtb
+	KERNEL_NAME := Image
+endef
+
+define Device/FitImageLzma
+	KERNEL_SUFFIX := -fit-uImage.itb
+	KERNEL = kernel-bin | lzma | fit lzma $$(DEVICE_DTS_DIR)/$$(DEVICE_DTS).dtb
+	KERNEL_NAME := Image
+endef
+
+define Device/FitzImage
+	KERNEL_SUFFIX := -fit-zImage.itb
+	KERNEL = kernel-bin | fit none $$(DEVICE_DTS_DIR)/$$(DEVICE_DTS).dtb
+	KERNEL_NAME := zImage
+endef
+
+define Device/UbiFit
+	KERNEL_IN_UBI := 1
+	IMAGES := nand-factory.ubi nand-sysupgrade.bin
+	IMAGE/nand-factory.ubi := append-ubi
+	IMAGE/nand-sysupgrade.bin := sysupgrade-tar | append-metadata
+endef
+
+define Device/redmi_ax6
+	$(call Device/xiaomi_ax3600)
+	DEVICE_VENDOR := Redmi
+	DEVICE_MODEL := AX6
+	DEVICE_PACKAGES := ipq-wifi-redmi_ax6 uboot-envtools
+endef
+TARGET_DEVICES += redmi_ax6
+
+define Device/xiaomi_ax3600
+	$(call Device/FitImage)
+	$(call Device/UbiFit)
+	DEVICE_VENDOR := Xiaomi
+	DEVICE_MODEL := AX3600
+	BLOCKSIZE := 128k
+	PAGESIZE := 2048
+	DEVICE_DTS_CONFIG := config@ac04
+	SOC := ipq8071
+	DEVICE_PACKAGES := ipq-wifi-xiaomi_ax3600 kmod-ath10k-ct ath10k-firmware-qca9887-ct \
+	uboot-envtools
+endef
+TARGET_DEVICES += xiaomi_ax3600
+
+define Device/xiaomi_ax9000
+	$(call Device/FitImage)
+	$(call Device/UbiFit)
+	DEVICE_VENDOR := Xiaomi
+	DEVICE_MODEL := AX9000
+	BLOCKSIZE := 128k
+	PAGESIZE := 2048
+	DEVICE_DTS_CONFIG := config@hk14
+	SOC := ipq8072
+	DEVICE_PACKAGES := ipq-wifi-xiaomi_ax9000 kmod-ath10k-ct ath10k-firmware-qca9887-ct \
+	uboot-envtools
+endef
+TARGET_DEVICES += xiaomi_ax9000
diff --git a/target/linux/ipq807x/patches-5.10/001-v5.11-remoteproc-sysmon-Expose-the-shutdown-result.patch b/target/linux/ipq807x/patches-5.10/001-v5.11-remoteproc-sysmon-Expose-the-shutdown-result.patch
new file mode 100644
index 0000000..57d2cbf
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/001-v5.11-remoteproc-sysmon-Expose-the-shutdown-result.patch
@@ -0,0 +1,222 @@
+From c47b1e60f043925ecce585f8c5340c049deda25e Mon Sep 17 00:00:00 2001
+From: Bjorn Andersson <bjorn.andersson@linaro.org>
+Date: Sat, 21 Nov 2020 21:41:33 -0800
+Subject: [PATCH] remoteproc: sysmon: Expose the shutdown result
+
+A graceful shutdown of the Qualcomm remote processors where
+traditionally performed by invoking a shared memory state signal and
+waiting for the associated ack.
+
+This was later superseded by the "sysmon" mechanism, where some form of
+shared memory bus is used to send a "graceful shutdown request" message
+and one of more signals comes back to indicate its success.
+
+But when this newer mechanism is in effect the firmware is shut down by
+the time the older mechanism, implemented in the remoteproc drivers,
+attempts to perform a graceful shutdown - and as such it will never
+receive an ack back.
+
+This patch therefor track the success of the latest shutdown attempt in
+sysmon and exposes a new function in the API that the remoteproc driver
+can use to query the success and the necessity of invoking the older
+mechanism.
+
+Tested-by: Steev Klimaszewski <steev@kali.org>
+Reviewed-by: Rishabh Bhatnagar <rishabhb@codeaurora.org>
+Link: https://lore.kernel.org/r/20201122054135.802935-3-bjorn.andersson@linaro.org
+Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
+---
+ drivers/remoteproc/qcom_common.h |  6 +++
+ drivers/remoteproc/qcom_sysmon.c | 82 ++++++++++++++++++++++++--------
+ 2 files changed, 69 insertions(+), 19 deletions(-)
+
+--- a/drivers/remoteproc/qcom_common.h
++++ b/drivers/remoteproc/qcom_common.h
+@@ -51,6 +51,7 @@ struct qcom_sysmon *qcom_add_sysmon_subd
+ 					   const char *name,
+ 					   int ssctl_instance);
+ void qcom_remove_sysmon_subdev(struct qcom_sysmon *sysmon);
++bool qcom_sysmon_shutdown_acked(struct qcom_sysmon *sysmon);
+ #else
+ static inline struct qcom_sysmon *qcom_add_sysmon_subdev(struct rproc *rproc,
+ 							 const char *name,
+@@ -62,6 +63,11 @@ static inline struct qcom_sysmon *qcom_a
+ static inline void qcom_remove_sysmon_subdev(struct qcom_sysmon *sysmon)
+ {
+ }
++
++static inline bool qcom_sysmon_shutdown_acked(struct qcom_sysmon *sysmon)
++{
++	return false;
++}
+ #endif
+ 
+ #endif
+--- a/drivers/remoteproc/qcom_sysmon.c
++++ b/drivers/remoteproc/qcom_sysmon.c
+@@ -44,6 +44,7 @@ struct qcom_sysmon {
+ 	struct mutex lock;
+ 
+ 	bool ssr_ack;
++	bool shutdown_acked;
+ 
+ 	struct qmi_handle qmi;
+ 	struct sockaddr_qrtr ssctl;
+@@ -115,10 +116,13 @@ out_unlock:
+ /**
+  * sysmon_request_shutdown() - request graceful shutdown of remote
+  * @sysmon:	sysmon context
++ *
++ * Return: boolean indicator of the remote processor acking the request
+  */
+-static void sysmon_request_shutdown(struct qcom_sysmon *sysmon)
++static bool sysmon_request_shutdown(struct qcom_sysmon *sysmon)
+ {
+ 	char *req = "ssr:shutdown";
++	bool acked = false;
+ 	int ret;
+ 
+ 	mutex_lock(&sysmon->lock);
+@@ -141,9 +145,13 @@ static void sysmon_request_shutdown(stru
+ 	if (!sysmon->ssr_ack)
+ 		dev_err(sysmon->dev,
+ 			"unexpected response to sysmon shutdown request\n");
++	else
++		acked = true;
+ 
+ out_unlock:
+ 	mutex_unlock(&sysmon->lock);
++
++	return acked;
+ }
+ 
+ static int sysmon_callback(struct rpmsg_device *rpdev, void *data, int count,
+@@ -297,14 +305,33 @@ static struct qmi_msg_handler qmi_indica
+ 	{}
+ };
+ 
++static bool ssctl_request_shutdown_wait(struct qcom_sysmon *sysmon)
++{
++	int ret;
++
++	ret = wait_for_completion_timeout(&sysmon->shutdown_comp, 10 * HZ);
++	if (ret)
++		return true;
++
++	ret = try_wait_for_completion(&sysmon->ind_comp);
++	if (ret)
++		return true;
++
++	dev_err(sysmon->dev, "timeout waiting for shutdown ack\n");
++	return false;
++}
++
+ /**
+  * ssctl_request_shutdown() - request shutdown via SSCTL QMI service
+  * @sysmon:	sysmon context
++ *
++ * Return: boolean indicator of the remote processor acking the request
+  */
+-static void ssctl_request_shutdown(struct qcom_sysmon *sysmon)
++static bool ssctl_request_shutdown(struct qcom_sysmon *sysmon)
+ {
+ 	struct ssctl_shutdown_resp resp;
+ 	struct qmi_txn txn;
++	bool acked = false;
+ 	int ret;
+ 
+ 	reinit_completion(&sysmon->ind_comp);
+@@ -312,7 +339,7 @@ static void ssctl_request_shutdown(struc
+ 	ret = qmi_txn_init(&sysmon->qmi, &txn, ssctl_shutdown_resp_ei, &resp);
+ 	if (ret < 0) {
+ 		dev_err(sysmon->dev, "failed to allocate QMI txn\n");
+-		return;
++		return false;
+ 	}
+ 
+ 	ret = qmi_send_request(&sysmon->qmi, &sysmon->ssctl, &txn,
+@@ -320,27 +347,23 @@ static void ssctl_request_shutdown(struc
+ 	if (ret < 0) {
+ 		dev_err(sysmon->dev, "failed to send shutdown request\n");
+ 		qmi_txn_cancel(&txn);
+-		return;
++		return false;
+ 	}
+ 
+ 	ret = qmi_txn_wait(&txn, 5 * HZ);
+-	if (ret < 0)
++	if (ret < 0) {
+ 		dev_err(sysmon->dev, "failed receiving QMI response\n");
+-	else if (resp.resp.result)
++	} else if (resp.resp.result) {
+ 		dev_err(sysmon->dev, "shutdown request failed\n");
+-	else
++	} else {
+ 		dev_dbg(sysmon->dev, "shutdown request completed\n");
+-
+-	if (sysmon->shutdown_irq > 0) {
+-		ret = wait_for_completion_timeout(&sysmon->shutdown_comp,
+-						  10 * HZ);
+-		if (!ret) {
+-			ret = try_wait_for_completion(&sysmon->ind_comp);
+-			if (!ret)
+-				dev_err(sysmon->dev,
+-					"timeout waiting for shutdown ack\n");
+-		}
++		acked = true;
+ 	}
++
++	if (sysmon->shutdown_irq > 0)
++		return ssctl_request_shutdown_wait(sysmon);
++
++	return acked;
+ }
+ 
+ /**
+@@ -510,6 +533,9 @@ static void sysmon_stop(struct rproc_sub
+ 		.subsys_name = sysmon->name,
+ 		.ssr_event = SSCTL_SSR_EVENT_BEFORE_SHUTDOWN
+ 	};
++	bool acked;
++
++	sysmon->shutdown_acked = false;
+ 
+ 	mutex_lock(&sysmon->state_lock);
+ 	sysmon->state = SSCTL_SSR_EVENT_BEFORE_SHUTDOWN;
+@@ -521,9 +547,11 @@ static void sysmon_stop(struct rproc_sub
+ 		return;
+ 
+ 	if (sysmon->ssctl_version)
+-		ssctl_request_shutdown(sysmon);
++		acked = ssctl_request_shutdown(sysmon);
+ 	else if (sysmon->ept)
+-		sysmon_request_shutdown(sysmon);
++		acked = sysmon_request_shutdown(sysmon);
++
++	sysmon->shutdown_acked = acked;
+ }
+ 
+ static void sysmon_unprepare(struct rproc_subdev *subdev)
+@@ -682,6 +710,22 @@ void qcom_remove_sysmon_subdev(struct qc
+ EXPORT_SYMBOL_GPL(qcom_remove_sysmon_subdev);
+ 
+ /**
++ * qcom_sysmon_shutdown_acked() - query the success of the last shutdown
++ * @sysmon:	sysmon context
++ *
++ * When sysmon is used to request a graceful shutdown of the remote processor
++ * this can be used by the remoteproc driver to query the success, in order to
++ * know if it should fall back to other means of requesting a shutdown.
++ *
++ * Return: boolean indicator of the success of the last shutdown request
++ */
++bool qcom_sysmon_shutdown_acked(struct qcom_sysmon *sysmon)
++{
++	return sysmon && sysmon->shutdown_acked;
++}
++EXPORT_SYMBOL_GPL(qcom_sysmon_shutdown_acked);
++
++/**
+  * sysmon_probe() - probe sys_mon channel
+  * @rpdev:	rpmsg device handle
+  *
diff --git a/target/linux/ipq807x/patches-5.10/002-v5.11-remoteproc-qcom-q6v5-Query-sysmon-before-graceful-sh.patch b/target/linux/ipq807x/patches-5.10/002-v5.11-remoteproc-qcom-q6v5-Query-sysmon-before-graceful-sh.patch
new file mode 100644
index 0000000..aeb0e1b
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/002-v5.11-remoteproc-qcom-q6v5-Query-sysmon-before-graceful-sh.patch
@@ -0,0 +1,120 @@
+From 47c815630294b6d2284fff10377d808f376de2b2 Mon Sep 17 00:00:00 2001
+From: Bjorn Andersson <bjorn.andersson@linaro.org>
+Date: Sat, 21 Nov 2020 21:41:34 -0800
+Subject: [PATCH 01/16] remoteproc: qcom: q6v5: Query sysmon before graceful
+ shutdown
+
+Requesting a graceful shutdown through the shared memory state signals
+will not be acked in the event that sysmon has already successfully shut
+down the remote firmware. So extend the stop request API to optionally
+take the remoteproc's sysmon instance and query if there's already been
+a successful shutdown attempt, before doing the signal dance.
+
+Tested-by: Steev Klimaszewski <steev@kali.org>
+Reviewed-by: Rishabh Bhatnagar <rishabhb@codeaurora.org>
+Link: https://lore.kernel.org/r/20201122054135.802935-4-bjorn.andersson@linaro.org
+Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
+---
+ drivers/remoteproc/qcom_q6v5.c      | 8 +++++++-
+ drivers/remoteproc/qcom_q6v5.h      | 3 ++-
+ drivers/remoteproc/qcom_q6v5_adsp.c | 2 +-
+ drivers/remoteproc/qcom_q6v5_mss.c  | 2 +-
+ drivers/remoteproc/qcom_q6v5_pas.c  | 2 +-
+ drivers/remoteproc/qcom_q6v5_wcss.c | 2 +-
+ 6 files changed, 13 insertions(+), 6 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5.c
++++ b/drivers/remoteproc/qcom_q6v5.c
+@@ -13,6 +13,7 @@
+ #include <linux/soc/qcom/smem.h>
+ #include <linux/soc/qcom/smem_state.h>
+ #include <linux/remoteproc.h>
++#include "qcom_common.h"
+ #include "qcom_q6v5.h"
+ 
+ #define Q6V5_PANIC_DELAY_MS	200
+@@ -146,15 +147,20 @@ static irqreturn_t q6v5_stop_interrupt(i
+ /**
+  * qcom_q6v5_request_stop() - request the remote processor to stop
+  * @q6v5:	reference to qcom_q6v5 context
++ * @sysmon:	reference to the remote's sysmon instance, or NULL
+  *
+  * Return: 0 on success, negative errno on failure
+  */
+-int qcom_q6v5_request_stop(struct qcom_q6v5 *q6v5)
++int qcom_q6v5_request_stop(struct qcom_q6v5 *q6v5, struct qcom_sysmon *sysmon)
+ {
+ 	int ret;
+ 
+ 	q6v5->running = false;
+ 
++	/* Don't perform SMP2P dance if sysmon already shut down the remote */
++	if (qcom_sysmon_shutdown_acked(sysmon))
++		return 0;
++
+ 	qcom_smem_state_update_bits(q6v5->state,
+ 				    BIT(q6v5->stop_bit), BIT(q6v5->stop_bit));
+ 
+--- a/drivers/remoteproc/qcom_q6v5.h
++++ b/drivers/remoteproc/qcom_q6v5.h
+@@ -8,6 +8,7 @@
+ 
+ struct rproc;
+ struct qcom_smem_state;
++struct qcom_sysmon;
+ 
+ struct qcom_q6v5 {
+ 	struct device *dev;
+@@ -40,7 +41,7 @@ int qcom_q6v5_init(struct qcom_q6v5 *q6v
+ 
+ int qcom_q6v5_prepare(struct qcom_q6v5 *q6v5);
+ int qcom_q6v5_unprepare(struct qcom_q6v5 *q6v5);
+-int qcom_q6v5_request_stop(struct qcom_q6v5 *q6v5);
++int qcom_q6v5_request_stop(struct qcom_q6v5 *q6v5, struct qcom_sysmon *sysmon);
+ int qcom_q6v5_wait_for_start(struct qcom_q6v5 *q6v5, int timeout);
+ unsigned long qcom_q6v5_panic(struct qcom_q6v5 *q6v5);
+ 
+--- a/drivers/remoteproc/qcom_q6v5_adsp.c
++++ b/drivers/remoteproc/qcom_q6v5_adsp.c
+@@ -266,7 +266,7 @@ static int adsp_stop(struct rproc *rproc
+ 	int handover;
+ 	int ret;
+ 
+-	ret = qcom_q6v5_request_stop(&adsp->q6v5);
++	ret = qcom_q6v5_request_stop(&adsp->q6v5, adsp->sysmon);
+ 	if (ret == -ETIMEDOUT)
+ 		dev_err(adsp->dev, "timed out on wait\n");
+ 
+--- a/drivers/remoteproc/qcom_q6v5_mss.c
++++ b/drivers/remoteproc/qcom_q6v5_mss.c
+@@ -1376,7 +1376,7 @@ static int q6v5_stop(struct rproc *rproc
+ 	struct q6v5 *qproc = (struct q6v5 *)rproc->priv;
+ 	int ret;
+ 
+-	ret = qcom_q6v5_request_stop(&qproc->q6v5);
++	ret = qcom_q6v5_request_stop(&qproc->q6v5, qproc->sysmon);
+ 	if (ret == -ETIMEDOUT)
+ 		dev_err(qproc->dev, "timed out on wait\n");
+ 
+--- a/drivers/remoteproc/qcom_q6v5_pas.c
++++ b/drivers/remoteproc/qcom_q6v5_pas.c
+@@ -217,7 +217,7 @@ static int adsp_stop(struct rproc *rproc
+ 	int handover;
+ 	int ret;
+ 
+-	ret = qcom_q6v5_request_stop(&adsp->q6v5);
++	ret = qcom_q6v5_request_stop(&adsp->q6v5, adsp->sysmon);
+ 	if (ret == -ETIMEDOUT)
+ 		dev_err(adsp->dev, "timed out on wait\n");
+ 
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -390,7 +390,7 @@ static int q6v5_wcss_stop(struct rproc *
+ 	int ret;
+ 
+ 	/* WCSS powerdown */
+-	ret = qcom_q6v5_request_stop(&wcss->q6v5);
++	ret = qcom_q6v5_request_stop(&wcss->q6v5, NULL);
+ 	if (ret == -ETIMEDOUT) {
+ 		dev_err(wcss->dev, "timed out on wait\n");
+ 		return ret;
diff --git a/target/linux/ipq807x/patches-5.10/003-v5.13-remoteproc-qcom-wcss-populate-hardcoded-param-using-.patch b/target/linux/ipq807x/patches-5.10/003-v5.13-remoteproc-qcom-wcss-populate-hardcoded-param-using-.patch
new file mode 100644
index 0000000..b7f9bd4
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/003-v5.13-remoteproc-qcom-wcss-populate-hardcoded-param-using-.patch
@@ -0,0 +1,104 @@
+From 6a83f257a5a10b24c7311475f19d58399c475476 Mon Sep 17 00:00:00 2001
+From: Govind Singh <govinds@codeaurora.org>
+Date: Fri, 29 Jan 2021 00:18:12 +0530
+Subject: [PATCH 02/16] remoteproc: qcom: wcss: populate hardcoded param using
+ driver data
+
+Q6 based WiFi fw loading is supported across
+different targets, ex: IPQ8074/QCS404. In order to
+support different fw names/pas id etc, populate
+hardcoded param using driver data.
+
+Signed-off-by: Govind Singh <govinds@codeaurora.org>
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Link: https://lore.kernel.org/r/1611859695-11824-2-git-send-email-gokulsri@codeaurora.org
+Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 29 ++++++++++++++++++++++++-----
+ 1 file changed, 24 insertions(+), 5 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -71,6 +71,11 @@
+ #define TCSR_WCSS_CLK_MASK	0x1F
+ #define TCSR_WCSS_CLK_ENABLE	0x14
+ 
++struct wcss_data {
++	const char *firmware_name;
++	unsigned int crash_reason_smem;
++};
++
+ struct q6v5_wcss {
+ 	struct device *dev;
+ 
+@@ -93,6 +98,8 @@ struct q6v5_wcss {
+ 	void *mem_region;
+ 	size_t mem_size;
+ 
++	unsigned int crash_reason_smem;
++
+ 	struct qcom_rproc_glink glink_subdev;
+ 	struct qcom_rproc_ssr ssr_subdev;
+ };
+@@ -438,7 +445,7 @@ static int q6v5_wcss_load(struct rproc *
+ 	return ret;
+ }
+ 
+-static const struct rproc_ops q6v5_wcss_ops = {
++static const struct rproc_ops q6v5_wcss_ipq8074_ops = {
+ 	.start = q6v5_wcss_start,
+ 	.stop = q6v5_wcss_stop,
+ 	.da_to_va = q6v5_wcss_da_to_va,
+@@ -538,12 +545,17 @@ static int q6v5_alloc_memory_region(stru
+ 
+ static int q6v5_wcss_probe(struct platform_device *pdev)
+ {
++	const struct wcss_data *desc;
+ 	struct q6v5_wcss *wcss;
+ 	struct rproc *rproc;
+ 	int ret;
+ 
+-	rproc = rproc_alloc(&pdev->dev, pdev->name, &q6v5_wcss_ops,
+-			    "IPQ8074/q6_fw.mdt", sizeof(*wcss));
++	desc = device_get_match_data(&pdev->dev);
++	if (!desc)
++		return -EINVAL;
++
++	rproc = rproc_alloc(&pdev->dev, pdev->name, &q6v5_wcss_ipq8074_ops,
++			    desc->firmware_name, sizeof(*wcss));
+ 	if (!rproc) {
+ 		dev_err(&pdev->dev, "failed to allocate rproc\n");
+ 		return -ENOMEM;
+@@ -551,6 +563,7 @@ static int q6v5_wcss_probe(struct platfo
+ 
+ 	wcss = rproc->priv;
+ 	wcss->dev = &pdev->dev;
++	wcss->crash_reason_smem = desc->crash_reason_smem;
+ 
+ 	ret = q6v5_wcss_init_mmio(wcss, pdev);
+ 	if (ret)
+@@ -564,7 +577,8 @@ static int q6v5_wcss_probe(struct platfo
+ 	if (ret)
+ 		goto free_rproc;
+ 
+-	ret = qcom_q6v5_init(&wcss->q6v5, pdev, rproc, WCSS_CRASH_REASON, NULL);
++	ret = qcom_q6v5_init(&wcss->q6v5, pdev, rproc, desc->crash_reason_smem,
++			     NULL);
+ 	if (ret)
+ 		goto free_rproc;
+ 
+@@ -595,8 +609,13 @@ static int q6v5_wcss_remove(struct platf
+ 	return 0;
+ }
+ 
++static const struct wcss_data wcss_ipq8074_res_init = {
++	.firmware_name = "IPQ8074/q6_fw.mdt",
++	.crash_reason_smem = WCSS_CRASH_REASON,
++};
++
+ static const struct of_device_id q6v5_wcss_of_match[] = {
+-	{ .compatible = "qcom,ipq8074-wcss-pil" },
++	{ .compatible = "qcom,ipq8074-wcss-pil", .data = &wcss_ipq8074_res_init },
+ 	{ },
+ };
+ MODULE_DEVICE_TABLE(of, q6v5_wcss_of_match);
diff --git a/target/linux/ipq807x/patches-5.10/004-v5.13-remoteproc-qcom-wcss-Add-non-pas-wcss-Q6-support-for.patch b/target/linux/ipq807x/patches-5.10/004-v5.13-remoteproc-qcom-wcss-Add-non-pas-wcss-Q6-support-for.patch
new file mode 100644
index 0000000..00b9cec
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/004-v5.13-remoteproc-qcom-wcss-Add-non-pas-wcss-Q6-support-for.patch
@@ -0,0 +1,764 @@
+From 155940892f022482c7e7a33c917fd766519d031b Mon Sep 17 00:00:00 2001
+From: Govind Singh <govinds@codeaurora.org>
+Date: Fri, 29 Jan 2021 00:18:14 +0530
+Subject: [PATCH 03/16] remoteproc: qcom: wcss: Add non pas wcss Q6 support for
+ QCS404
+
+Add non PAS WCSS remoteproc driver support for QCS404 SOC.
+Add WCSS q6 bootup and shutdown sequence handled from
+Application Processor SubSystem(APSS).
+
+Signed-off-by: Govind Singh <govinds@codeaurora.org>
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Link: https://lore.kernel.org/r/1611859695-11824-4-git-send-email-gokulsri@codeaurora.org
+Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 566 ++++++++++++++++++++++++++--
+ 1 file changed, 528 insertions(+), 38 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -4,13 +4,18 @@
+  * Copyright (C) 2014 Sony Mobile Communications AB
+  * Copyright (c) 2012-2018, The Linux Foundation. All rights reserved.
+  */
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/io.h>
+ #include <linux/iopoll.h>
+ #include <linux/kernel.h>
+ #include <linux/mfd/syscon.h>
+ #include <linux/module.h>
++#include <linux/of_address.h>
+ #include <linux/of_reserved_mem.h>
+ #include <linux/platform_device.h>
+ #include <linux/regmap.h>
++#include <linux/regulator/consumer.h>
+ #include <linux/reset.h>
+ #include <linux/soc/qcom/mdt_loader.h>
+ #include "qcom_common.h"
+@@ -24,6 +29,9 @@
+ #define Q6SS_GFMUX_CTL_REG		0x020
+ #define Q6SS_PWR_CTL_REG		0x030
+ #define Q6SS_MEM_PWR_CTL		0x0B0
++#define Q6SS_STRAP_ACC			0x110
++#define Q6SS_CGC_OVERRIDE		0x034
++#define Q6SS_BCR_REG			0x6000
+ 
+ /* AXI Halt Register Offsets */
+ #define AXI_HALTREQ_REG			0x0
+@@ -37,14 +45,19 @@
+ #define Q6SS_CORE_ARES			BIT(1)
+ #define Q6SS_BUS_ARES_ENABLE		BIT(2)
+ 
++/* Q6SS_BRC_RESET */
++#define Q6SS_BRC_BLK_ARES		BIT(0)
++
+ /* Q6SS_GFMUX_CTL */
+ #define Q6SS_CLK_ENABLE			BIT(1)
++#define Q6SS_SWITCH_CLK_SRC		BIT(8)
+ 
+ /* Q6SS_PWR_CTL */
+ #define Q6SS_L2DATA_STBY_N		BIT(18)
+ #define Q6SS_SLP_RET_N			BIT(19)
+ #define Q6SS_CLAMP_IO			BIT(20)
+ #define QDSS_BHS_ON			BIT(21)
++#define QDSS_Q6_MEMORIES		GENMASK(15, 0)
+ 
+ /* Q6SS parameters */
+ #define Q6SS_LDO_BYP		BIT(25)
+@@ -53,6 +66,7 @@
+ #define Q6SS_CLAMP_QMC_MEM		BIT(22)
+ #define HALT_CHECK_MAX_LOOPS		200
+ #define Q6SS_XO_CBCR		GENMASK(5, 3)
++#define Q6SS_SLEEP_CBCR		GENMASK(5, 2)
+ 
+ /* Q6SS config/status registers */
+ #define TCSR_GLOBAL_CFG0	0x0
+@@ -71,9 +85,23 @@
+ #define TCSR_WCSS_CLK_MASK	0x1F
+ #define TCSR_WCSS_CLK_ENABLE	0x14
+ 
++#define MAX_HALT_REG		3
++enum {
++	WCSS_IPQ8074,
++	WCSS_QCS404,
++};
++
+ struct wcss_data {
+ 	const char *firmware_name;
+ 	unsigned int crash_reason_smem;
++	u32 version;
++	bool aon_reset_required;
++	bool wcss_q6_reset_required;
++	const char *ssr_name;
++	const char *sysmon_name;
++	int ssctl_id;
++	const struct rproc_ops *ops;
++	bool requires_force_stop;
+ };
+ 
+ struct q6v5_wcss {
+@@ -87,9 +115,26 @@ struct q6v5_wcss {
+ 	u32 halt_wcss;
+ 	u32 halt_nc;
+ 
++	struct clk *xo;
++	struct clk *ahbfabric_cbcr_clk;
++	struct clk *gcc_abhs_cbcr;
++	struct clk *gcc_axim_cbcr;
++	struct clk *lcc_csr_cbcr;
++	struct clk *ahbs_cbcr;
++	struct clk *tcm_slave_cbcr;
++	struct clk *qdsp6ss_abhm_cbcr;
++	struct clk *qdsp6ss_sleep_cbcr;
++	struct clk *qdsp6ss_axim_cbcr;
++	struct clk *qdsp6ss_xo_cbcr;
++	struct clk *qdsp6ss_core_gfmux;
++	struct clk *lcc_bcr_sleep;
++	struct regulator *cx_supply;
++	struct qcom_sysmon *sysmon;
++
+ 	struct reset_control *wcss_aon_reset;
+ 	struct reset_control *wcss_reset;
+ 	struct reset_control *wcss_q6_reset;
++	struct reset_control *wcss_q6_bcr_reset;
+ 
+ 	struct qcom_q6v5 q6v5;
+ 
+@@ -99,6 +144,8 @@ struct q6v5_wcss {
+ 	size_t mem_size;
+ 
+ 	unsigned int crash_reason_smem;
++	u32 version;
++	bool requires_force_stop;
+ 
+ 	struct qcom_rproc_glink glink_subdev;
+ 	struct qcom_rproc_ssr ssr_subdev;
+@@ -244,6 +291,207 @@ wcss_reset:
+ 	return ret;
+ }
+ 
++static int q6v5_wcss_qcs404_power_on(struct q6v5_wcss *wcss)
++{
++	unsigned long val;
++	int ret, idx;
++
++	/* Toggle the restart */
++	reset_control_assert(wcss->wcss_reset);
++	usleep_range(200, 300);
++	reset_control_deassert(wcss->wcss_reset);
++	usleep_range(200, 300);
++
++	/* Enable GCC_WDSP_Q6SS_AHBS_CBCR clock */
++	ret = clk_prepare_enable(wcss->gcc_abhs_cbcr);
++	if (ret)
++		return ret;
++
++	/* Remove reset to the WCNSS QDSP6SS */
++	reset_control_deassert(wcss->wcss_q6_bcr_reset);
++
++	/* Enable Q6SSTOP_AHBFABRIC_CBCR clock */
++	ret = clk_prepare_enable(wcss->ahbfabric_cbcr_clk);
++	if (ret)
++		goto disable_gcc_abhs_cbcr_clk;
++
++	/* Enable the LCCCSR CBC clock, Q6SSTOP_Q6SSTOP_LCC_CSR_CBCR clock */
++	ret = clk_prepare_enable(wcss->lcc_csr_cbcr);
++	if (ret)
++		goto disable_ahbfabric_cbcr_clk;
++
++	/* Enable the Q6AHBS CBC, Q6SSTOP_Q6SS_AHBS_CBCR clock */
++	ret = clk_prepare_enable(wcss->ahbs_cbcr);
++	if (ret)
++		goto disable_csr_cbcr_clk;
++
++	/* Enable the TCM slave CBC, Q6SSTOP_Q6SS_TCM_SLAVE_CBCR clock */
++	ret = clk_prepare_enable(wcss->tcm_slave_cbcr);
++	if (ret)
++		goto disable_ahbs_cbcr_clk;
++
++	/* Enable the Q6SS AHB master CBC, Q6SSTOP_Q6SS_AHBM_CBCR clock */
++	ret = clk_prepare_enable(wcss->qdsp6ss_abhm_cbcr);
++	if (ret)
++		goto disable_tcm_slave_cbcr_clk;
++
++	/* Enable the Q6SS AXI master CBC, Q6SSTOP_Q6SS_AXIM_CBCR clock */
++	ret = clk_prepare_enable(wcss->qdsp6ss_axim_cbcr);
++	if (ret)
++		goto disable_abhm_cbcr_clk;
++
++	/* Enable the Q6SS XO CBC */
++	val = readl(wcss->reg_base + Q6SS_XO_CBCR);
++	val |= BIT(0);
++	writel(val, wcss->reg_base + Q6SS_XO_CBCR);
++	/* Read CLKOFF bit to go low indicating CLK is enabled */
++	ret = readl_poll_timeout(wcss->reg_base + Q6SS_XO_CBCR,
++				 val, !(val & BIT(31)), 1,
++				 HALT_CHECK_MAX_LOOPS);
++	if (ret) {
++		dev_err(wcss->dev,
++			"xo cbcr enabling timed out (rc:%d)\n", ret);
++		return ret;
++	}
++
++	writel(0, wcss->reg_base + Q6SS_CGC_OVERRIDE);
++
++	/* Enable QDSP6 sleep clock clock */
++	val = readl(wcss->reg_base + Q6SS_SLEEP_CBCR);
++	val |= BIT(0);
++	writel(val, wcss->reg_base + Q6SS_SLEEP_CBCR);
++
++	/* Enable the Enable the Q6 AXI clock, GCC_WDSP_Q6SS_AXIM_CBCR*/
++	ret = clk_prepare_enable(wcss->gcc_axim_cbcr);
++	if (ret)
++		goto disable_sleep_cbcr_clk;
++
++	/* Assert resets, stop core */
++	val = readl(wcss->reg_base + Q6SS_RESET_REG);
++	val |= Q6SS_CORE_ARES | Q6SS_BUS_ARES_ENABLE | Q6SS_STOP_CORE;
++	writel(val, wcss->reg_base + Q6SS_RESET_REG);
++
++	/* Program the QDSP6SS PWR_CTL register */
++	writel(0x01700000, wcss->reg_base + Q6SS_PWR_CTL_REG);
++
++	writel(0x03700000, wcss->reg_base + Q6SS_PWR_CTL_REG);
++
++	writel(0x03300000, wcss->reg_base + Q6SS_PWR_CTL_REG);
++
++	writel(0x033C0000, wcss->reg_base + Q6SS_PWR_CTL_REG);
++
++	/*
++	 * Enable memories by turning on the QDSP6 memory foot/head switch, one
++	 * bank at a time to avoid in-rush current
++	 */
++	for (idx = 28; idx >= 0; idx--) {
++		writel((readl(wcss->reg_base + Q6SS_MEM_PWR_CTL) |
++			(1 << idx)), wcss->reg_base + Q6SS_MEM_PWR_CTL);
++	}
++
++	writel(0x031C0000, wcss->reg_base + Q6SS_PWR_CTL_REG);
++	writel(0x030C0000, wcss->reg_base + Q6SS_PWR_CTL_REG);
++
++	val = readl(wcss->reg_base + Q6SS_RESET_REG);
++	val &= ~Q6SS_CORE_ARES;
++	writel(val, wcss->reg_base + Q6SS_RESET_REG);
++
++	/* Enable the Q6 core clock at the GFM, Q6SSTOP_QDSP6SS_GFMUX_CTL */
++	val = readl(wcss->reg_base + Q6SS_GFMUX_CTL_REG);
++	val |= Q6SS_CLK_ENABLE | Q6SS_SWITCH_CLK_SRC;
++	writel(val, wcss->reg_base + Q6SS_GFMUX_CTL_REG);
++
++	/* Enable sleep clock branch needed for BCR circuit */
++	ret = clk_prepare_enable(wcss->lcc_bcr_sleep);
++	if (ret)
++		goto disable_core_gfmux_clk;
++
++	return 0;
++
++disable_core_gfmux_clk:
++	val = readl(wcss->reg_base + Q6SS_GFMUX_CTL_REG);
++	val &= ~(Q6SS_CLK_ENABLE | Q6SS_SWITCH_CLK_SRC);
++	writel(val, wcss->reg_base + Q6SS_GFMUX_CTL_REG);
++	clk_disable_unprepare(wcss->gcc_axim_cbcr);
++disable_sleep_cbcr_clk:
++	val = readl(wcss->reg_base + Q6SS_SLEEP_CBCR);
++	val &= ~Q6SS_CLK_ENABLE;
++	writel(val, wcss->reg_base + Q6SS_SLEEP_CBCR);
++	val = readl(wcss->reg_base + Q6SS_XO_CBCR);
++	val &= ~Q6SS_CLK_ENABLE;
++	writel(val, wcss->reg_base + Q6SS_XO_CBCR);
++	clk_disable_unprepare(wcss->qdsp6ss_axim_cbcr);
++disable_abhm_cbcr_clk:
++	clk_disable_unprepare(wcss->qdsp6ss_abhm_cbcr);
++disable_tcm_slave_cbcr_clk:
++	clk_disable_unprepare(wcss->tcm_slave_cbcr);
++disable_ahbs_cbcr_clk:
++	clk_disable_unprepare(wcss->ahbs_cbcr);
++disable_csr_cbcr_clk:
++	clk_disable_unprepare(wcss->lcc_csr_cbcr);
++disable_ahbfabric_cbcr_clk:
++	clk_disable_unprepare(wcss->ahbfabric_cbcr_clk);
++disable_gcc_abhs_cbcr_clk:
++	clk_disable_unprepare(wcss->gcc_abhs_cbcr);
++
++	return ret;
++}
++
++static inline int q6v5_wcss_qcs404_reset(struct q6v5_wcss *wcss)
++{
++	unsigned long val;
++
++	writel(0x80800000, wcss->reg_base + Q6SS_STRAP_ACC);
++
++	/* Start core execution */
++	val = readl(wcss->reg_base + Q6SS_RESET_REG);
++	val &= ~Q6SS_STOP_CORE;
++	writel(val, wcss->reg_base + Q6SS_RESET_REG);
++
++	return 0;
++}
++
++static int q6v5_qcs404_wcss_start(struct rproc *rproc)
++{
++	struct q6v5_wcss *wcss = rproc->priv;
++	int ret;
++
++	ret = clk_prepare_enable(wcss->xo);
++	if (ret)
++		return ret;
++
++	ret = regulator_enable(wcss->cx_supply);
++	if (ret)
++		goto disable_xo_clk;
++
++	qcom_q6v5_prepare(&wcss->q6v5);
++
++	ret = q6v5_wcss_qcs404_power_on(wcss);
++	if (ret) {
++		dev_err(wcss->dev, "wcss clk_enable failed\n");
++		goto disable_cx_supply;
++	}
++
++	writel(rproc->bootaddr >> 4, wcss->reg_base + Q6SS_RST_EVB);
++
++	q6v5_wcss_qcs404_reset(wcss);
++
++	ret = qcom_q6v5_wait_for_start(&wcss->q6v5, 5 * HZ);
++	if (ret == -ETIMEDOUT) {
++		dev_err(wcss->dev, "start timed out\n");
++		goto disable_cx_supply;
++	}
++
++	return 0;
++
++disable_cx_supply:
++	regulator_disable(wcss->cx_supply);
++disable_xo_clk:
++	clk_disable_unprepare(wcss->xo);
++
++	return ret;
++}
++
+ static void q6v5_wcss_halt_axi_port(struct q6v5_wcss *wcss,
+ 				    struct regmap *halt_map,
+ 				    u32 offset)
+@@ -278,6 +526,70 @@ static void q6v5_wcss_halt_axi_port(stru
+ 	regmap_write(halt_map, offset + AXI_HALTREQ_REG, 0);
+ }
+ 
++static int q6v5_qcs404_wcss_shutdown(struct q6v5_wcss *wcss)
++{
++	unsigned long val;
++	int ret;
++
++	q6v5_wcss_halt_axi_port(wcss, wcss->halt_map, wcss->halt_wcss);
++
++	/* assert clamps to avoid MX current inrush */
++	val = readl(wcss->reg_base + Q6SS_PWR_CTL_REG);
++	val |= (Q6SS_CLAMP_IO | Q6SS_CLAMP_WL | Q6SS_CLAMP_QMC_MEM);
++	writel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);
++
++	/* Disable memories by turning off memory foot/headswitch */
++	writel((readl(wcss->reg_base + Q6SS_MEM_PWR_CTL) &
++		~QDSS_Q6_MEMORIES),
++		wcss->reg_base + Q6SS_MEM_PWR_CTL);
++
++	/* Clear the BHS_ON bit */
++	val = readl(wcss->reg_base + Q6SS_PWR_CTL_REG);
++	val &= ~Q6SS_BHS_ON;
++	writel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);
++
++	clk_disable_unprepare(wcss->ahbfabric_cbcr_clk);
++	clk_disable_unprepare(wcss->lcc_csr_cbcr);
++	clk_disable_unprepare(wcss->tcm_slave_cbcr);
++	clk_disable_unprepare(wcss->qdsp6ss_abhm_cbcr);
++	clk_disable_unprepare(wcss->qdsp6ss_axim_cbcr);
++
++	val = readl(wcss->reg_base + Q6SS_SLEEP_CBCR);
++	val &= ~BIT(0);
++	writel(val, wcss->reg_base + Q6SS_SLEEP_CBCR);
++
++	val = readl(wcss->reg_base + Q6SS_XO_CBCR);
++	val &= ~BIT(0);
++	writel(val, wcss->reg_base + Q6SS_XO_CBCR);
++
++	clk_disable_unprepare(wcss->ahbs_cbcr);
++	clk_disable_unprepare(wcss->lcc_bcr_sleep);
++
++	val = readl(wcss->reg_base + Q6SS_GFMUX_CTL_REG);
++	val &= ~(Q6SS_CLK_ENABLE | Q6SS_SWITCH_CLK_SRC);
++	writel(val, wcss->reg_base + Q6SS_GFMUX_CTL_REG);
++
++	clk_disable_unprepare(wcss->gcc_abhs_cbcr);
++
++	ret = reset_control_assert(wcss->wcss_reset);
++	if (ret) {
++		dev_err(wcss->dev, "wcss_reset failed\n");
++		return ret;
++	}
++	usleep_range(200, 300);
++
++	ret = reset_control_deassert(wcss->wcss_reset);
++	if (ret) {
++		dev_err(wcss->dev, "wcss_reset failed\n");
++		return ret;
++	}
++	usleep_range(200, 300);
++
++	clk_disable_unprepare(wcss->gcc_axim_cbcr);
++
++	return 0;
++}
++
+ static int q6v5_wcss_powerdown(struct q6v5_wcss *wcss)
+ {
+ 	int ret;
+@@ -397,20 +709,28 @@ static int q6v5_wcss_stop(struct rproc *
+ 	int ret;
+ 
+ 	/* WCSS powerdown */
+-	ret = qcom_q6v5_request_stop(&wcss->q6v5, NULL);
+-	if (ret == -ETIMEDOUT) {
+-		dev_err(wcss->dev, "timed out on wait\n");
+-		return ret;
++	if (wcss->requires_force_stop) {
++		ret = qcom_q6v5_request_stop(&wcss->q6v5, NULL);
++		if (ret == -ETIMEDOUT) {
++			dev_err(wcss->dev, "timed out on wait\n");
++			return ret;
++		}
+ 	}
+ 
+-	ret = q6v5_wcss_powerdown(wcss);
+-	if (ret)
+-		return ret;
+-
+-	/* Q6 Power down */
+-	ret = q6v5_q6_powerdown(wcss);
+-	if (ret)
+-		return ret;
++	if (wcss->version == WCSS_QCS404) {
++		ret = q6v5_qcs404_wcss_shutdown(wcss);
++		if (ret)
++			return ret;
++	} else {
++		ret = q6v5_wcss_powerdown(wcss);
++		if (ret)
++			return ret;
++
++		/* Q6 Power down */
++		ret = q6v5_q6_powerdown(wcss);
++		if (ret)
++			return ret;
++	}
+ 
+ 	qcom_q6v5_unprepare(&wcss->q6v5);
+ 
+@@ -453,14 +773,26 @@ static const struct rproc_ops q6v5_wcss_
+ 	.get_boot_addr = rproc_elf_get_boot_addr,
+ };
+ 
+-static int q6v5_wcss_init_reset(struct q6v5_wcss *wcss)
++static const struct rproc_ops q6v5_wcss_qcs404_ops = {
++	.start = q6v5_qcs404_wcss_start,
++	.stop = q6v5_wcss_stop,
++	.da_to_va = q6v5_wcss_da_to_va,
++	.load = q6v5_wcss_load,
++	.get_boot_addr = rproc_elf_get_boot_addr,
++	.parse_fw = qcom_register_dump_segments,
++};
++
++static int q6v5_wcss_init_reset(struct q6v5_wcss *wcss,
++				const struct wcss_data *desc)
+ {
+ 	struct device *dev = wcss->dev;
+ 
+-	wcss->wcss_aon_reset = devm_reset_control_get(dev, "wcss_aon_reset");
+-	if (IS_ERR(wcss->wcss_aon_reset)) {
+-		dev_err(wcss->dev, "unable to acquire wcss_aon_reset\n");
+-		return PTR_ERR(wcss->wcss_aon_reset);
++	if (desc->aon_reset_required) {
++		wcss->wcss_aon_reset = devm_reset_control_get(dev, "wcss_aon_reset");
++		if (IS_ERR(wcss->wcss_aon_reset)) {
++			dev_err(wcss->dev, "fail to acquire wcss_aon_reset\n");
++			return PTR_ERR(wcss->wcss_aon_reset);
++		}
+ 	}
+ 
+ 	wcss->wcss_reset = devm_reset_control_get(dev, "wcss_reset");
+@@ -469,10 +801,18 @@ static int q6v5_wcss_init_reset(struct q
+ 		return PTR_ERR(wcss->wcss_reset);
+ 	}
+ 
+-	wcss->wcss_q6_reset = devm_reset_control_get(dev, "wcss_q6_reset");
+-	if (IS_ERR(wcss->wcss_q6_reset)) {
+-		dev_err(wcss->dev, "unable to acquire wcss_q6_reset\n");
+-		return PTR_ERR(wcss->wcss_q6_reset);
++	if (desc->wcss_q6_reset_required) {
++		wcss->wcss_q6_reset = devm_reset_control_get(dev, "wcss_q6_reset");
++		if (IS_ERR(wcss->wcss_q6_reset)) {
++			dev_err(wcss->dev, "unable to acquire wcss_q6_reset\n");
++			return PTR_ERR(wcss->wcss_q6_reset);
++		}
++	}
++
++	wcss->wcss_q6_bcr_reset = devm_reset_control_get_exclusive(dev, "wcss_q6_bcr_reset");
++	if (IS_ERR(wcss->wcss_q6_bcr_reset)) {
++		dev_err(wcss->dev, "unable to acquire wcss_q6_bcr_reset\n");
++		return PTR_ERR(wcss->wcss_q6_bcr_reset);
+ 	}
+ 
+ 	return 0;
+@@ -481,35 +821,48 @@ static int q6v5_wcss_init_reset(struct q
+ static int q6v5_wcss_init_mmio(struct q6v5_wcss *wcss,
+ 			       struct platform_device *pdev)
+ {
+-	struct of_phandle_args args;
++	unsigned int halt_reg[MAX_HALT_REG] = {0};
++	struct device_node *syscon;
+ 	struct resource *res;
+ 	int ret;
+ 
+ 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qdsp6");
+-	wcss->reg_base = devm_ioremap_resource(&pdev->dev, res);
++	wcss->reg_base = devm_ioremap(&pdev->dev, res->start,
++				      resource_size(res));
+ 	if (IS_ERR(wcss->reg_base))
+ 		return PTR_ERR(wcss->reg_base);
+ 
+-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "rmb");
+-	wcss->rmb_base = devm_ioremap_resource(&pdev->dev, res);
+-	if (IS_ERR(wcss->rmb_base))
+-		return PTR_ERR(wcss->rmb_base);
++	if (wcss->version == WCSS_IPQ8074) {
++		res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "rmb");
++		wcss->rmb_base = devm_ioremap_resource(&pdev->dev, res);
++		if (IS_ERR(wcss->rmb_base))
++			return PTR_ERR(wcss->rmb_base);
++	}
+ 
+-	ret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,
+-					       "qcom,halt-regs", 3, 0, &args);
+-	if (ret < 0) {
++	syscon = of_parse_phandle(pdev->dev.of_node,
++				  "qcom,halt-regs", 0);
++	if (!syscon) {
+ 		dev_err(&pdev->dev, "failed to parse qcom,halt-regs\n");
+ 		return -EINVAL;
+ 	}
+ 
+-	wcss->halt_map = syscon_node_to_regmap(args.np);
+-	of_node_put(args.np);
++	wcss->halt_map = syscon_node_to_regmap(syscon);
++	of_node_put(syscon);
+ 	if (IS_ERR(wcss->halt_map))
+ 		return PTR_ERR(wcss->halt_map);
+ 
+-	wcss->halt_q6 = args.args[0];
+-	wcss->halt_wcss = args.args[1];
+-	wcss->halt_nc = args.args[2];
++	ret = of_property_read_variable_u32_array(pdev->dev.of_node,
++						  "qcom,halt-regs",
++						  halt_reg, 0,
++						  MAX_HALT_REG);
++	if (ret < 0) {
++		dev_err(&pdev->dev, "failed to parse qcom,halt-regs\n");
++		return -EINVAL;
++	}
++
++	wcss->halt_q6 = halt_reg[0];
++	wcss->halt_wcss = halt_reg[1];
++	wcss->halt_nc = halt_reg[2];
+ 
+ 	return 0;
+ }
+@@ -543,6 +896,107 @@ static int q6v5_alloc_memory_region(stru
+ 	return 0;
+ }
+ 
++static int q6v5_wcss_init_clock(struct q6v5_wcss *wcss)
++{
++	int ret;
++
++	wcss->xo = devm_clk_get(wcss->dev, "xo");
++	if (IS_ERR(wcss->xo)) {
++		ret = PTR_ERR(wcss->xo);
++		if (ret != -EPROBE_DEFER)
++			dev_err(wcss->dev, "failed to get xo clock");
++		return ret;
++	}
++
++	wcss->gcc_abhs_cbcr = devm_clk_get(wcss->dev, "gcc_abhs_cbcr");
++	if (IS_ERR(wcss->gcc_abhs_cbcr)) {
++		ret = PTR_ERR(wcss->gcc_abhs_cbcr);
++		if (ret != -EPROBE_DEFER)
++			dev_err(wcss->dev, "failed to get gcc abhs clock");
++		return PTR_ERR(wcss->gcc_abhs_cbcr);
++	}
++
++	wcss->gcc_axim_cbcr = devm_clk_get(wcss->dev, "gcc_axim_cbcr");
++	if (IS_ERR(wcss->gcc_axim_cbcr)) {
++		ret = PTR_ERR(wcss->gcc_axim_cbcr);
++		if (ret != -EPROBE_DEFER)
++			dev_err(wcss->dev, "failed to get gcc axim clock\n");
++		return PTR_ERR(wcss->gcc_axim_cbcr);
++	}
++
++	wcss->ahbfabric_cbcr_clk = devm_clk_get(wcss->dev,
++						"lcc_ahbfabric_cbc");
++	if (IS_ERR(wcss->ahbfabric_cbcr_clk)) {
++		ret = PTR_ERR(wcss->ahbfabric_cbcr_clk);
++		if (ret != -EPROBE_DEFER)
++			dev_err(wcss->dev, "failed to get ahbfabric clock\n");
++		return PTR_ERR(wcss->ahbfabric_cbcr_clk);
++	}
++
++	wcss->lcc_csr_cbcr = devm_clk_get(wcss->dev, "tcsr_lcc_cbc");
++	if (IS_ERR(wcss->lcc_csr_cbcr)) {
++		ret = PTR_ERR(wcss->lcc_csr_cbcr);
++		if (ret != -EPROBE_DEFER)
++			dev_err(wcss->dev, "failed to get csr cbcr clk\n");
++		return PTR_ERR(wcss->lcc_csr_cbcr);
++	}
++
++	wcss->ahbs_cbcr = devm_clk_get(wcss->dev,
++				       "lcc_abhs_cbc");
++	if (IS_ERR(wcss->ahbs_cbcr)) {
++		ret = PTR_ERR(wcss->ahbs_cbcr);
++		if (ret != -EPROBE_DEFER)
++			dev_err(wcss->dev, "failed to get ahbs_cbcr clk\n");
++		return PTR_ERR(wcss->ahbs_cbcr);
++	}
++
++	wcss->tcm_slave_cbcr = devm_clk_get(wcss->dev,
++					    "lcc_tcm_slave_cbc");
++	if (IS_ERR(wcss->tcm_slave_cbcr)) {
++		ret = PTR_ERR(wcss->tcm_slave_cbcr);
++		if (ret != -EPROBE_DEFER)
++			dev_err(wcss->dev, "failed to get tcm cbcr clk\n");
++		return PTR_ERR(wcss->tcm_slave_cbcr);
++	}
++
++	wcss->qdsp6ss_abhm_cbcr = devm_clk_get(wcss->dev, "lcc_abhm_cbc");
++	if (IS_ERR(wcss->qdsp6ss_abhm_cbcr)) {
++		ret = PTR_ERR(wcss->qdsp6ss_abhm_cbcr);
++		if (ret != -EPROBE_DEFER)
++			dev_err(wcss->dev, "failed to get abhm cbcr clk\n");
++		return PTR_ERR(wcss->qdsp6ss_abhm_cbcr);
++	}
++
++	wcss->qdsp6ss_axim_cbcr = devm_clk_get(wcss->dev, "lcc_axim_cbc");
++	if (IS_ERR(wcss->qdsp6ss_axim_cbcr)) {
++		ret = PTR_ERR(wcss->qdsp6ss_axim_cbcr);
++		if (ret != -EPROBE_DEFER)
++			dev_err(wcss->dev, "failed to get axim cbcr clk\n");
++		return PTR_ERR(wcss->qdsp6ss_abhm_cbcr);
++	}
++
++	wcss->lcc_bcr_sleep = devm_clk_get(wcss->dev, "lcc_bcr_sleep");
++	if (IS_ERR(wcss->lcc_bcr_sleep)) {
++		ret = PTR_ERR(wcss->lcc_bcr_sleep);
++		if (ret != -EPROBE_DEFER)
++			dev_err(wcss->dev, "failed to get bcr cbcr clk\n");
++		return PTR_ERR(wcss->lcc_bcr_sleep);
++	}
++
++	return 0;
++}
++
++static int q6v5_wcss_init_regulator(struct q6v5_wcss *wcss)
++{
++	wcss->cx_supply = devm_regulator_get(wcss->dev, "cx");
++	if (IS_ERR(wcss->cx_supply))
++		return PTR_ERR(wcss->cx_supply);
++
++	regulator_set_load(wcss->cx_supply, 100000);
++
++	return 0;
++}
++
+ static int q6v5_wcss_probe(struct platform_device *pdev)
+ {
+ 	const struct wcss_data *desc;
+@@ -554,7 +1008,7 @@ static int q6v5_wcss_probe(struct platfo
+ 	if (!desc)
+ 		return -EINVAL;
+ 
+-	rproc = rproc_alloc(&pdev->dev, pdev->name, &q6v5_wcss_ipq8074_ops,
++	rproc = rproc_alloc(&pdev->dev, pdev->name, desc->ops,
+ 			    desc->firmware_name, sizeof(*wcss));
+ 	if (!rproc) {
+ 		dev_err(&pdev->dev, "failed to allocate rproc\n");
+@@ -563,7 +1017,10 @@ static int q6v5_wcss_probe(struct platfo
+ 
+ 	wcss = rproc->priv;
+ 	wcss->dev = &pdev->dev;
+-	wcss->crash_reason_smem = desc->crash_reason_smem;
++	wcss->version = desc->version;
++
++	wcss->version = desc->version;
++	wcss->requires_force_stop = desc->requires_force_stop;
+ 
+ 	ret = q6v5_wcss_init_mmio(wcss, pdev);
+ 	if (ret)
+@@ -573,7 +1030,17 @@ static int q6v5_wcss_probe(struct platfo
+ 	if (ret)
+ 		goto free_rproc;
+ 
+-	ret = q6v5_wcss_init_reset(wcss);
++	if (wcss->version == WCSS_QCS404) {
++		ret = q6v5_wcss_init_clock(wcss);
++		if (ret)
++			goto free_rproc;
++
++		ret = q6v5_wcss_init_regulator(wcss);
++		if (ret)
++			goto free_rproc;
++	}
++
++	ret = q6v5_wcss_init_reset(wcss, desc);
+ 	if (ret)
+ 		goto free_rproc;
+ 
+@@ -585,6 +1052,11 @@ static int q6v5_wcss_probe(struct platfo
+ 	qcom_add_glink_subdev(rproc, &wcss->glink_subdev, "q6wcss");
+ 	qcom_add_ssr_subdev(rproc, &wcss->ssr_subdev, "q6wcss");
+ 
++	if (desc->ssctl_id)
++		wcss->sysmon = qcom_add_sysmon_subdev(rproc,
++						      desc->sysmon_name,
++						      desc->ssctl_id);
++
+ 	ret = rproc_add(rproc);
+ 	if (ret)
+ 		goto free_rproc;
+@@ -612,10 +1084,28 @@ static int q6v5_wcss_remove(struct platf
+ static const struct wcss_data wcss_ipq8074_res_init = {
+ 	.firmware_name = "IPQ8074/q6_fw.mdt",
+ 	.crash_reason_smem = WCSS_CRASH_REASON,
++	.aon_reset_required = true,
++	.wcss_q6_reset_required = true,
++	.ops = &q6v5_wcss_ipq8074_ops,
++	.requires_force_stop = true,
++};
++
++static const struct wcss_data wcss_qcs404_res_init = {
++	.crash_reason_smem = WCSS_CRASH_REASON,
++	.firmware_name = "wcnss.mdt",
++	.version = WCSS_QCS404,
++	.aon_reset_required = false,
++	.wcss_q6_reset_required = false,
++	.ssr_name = "mpss",
++	.sysmon_name = "wcnss",
++	.ssctl_id = 0x12,
++	.ops = &q6v5_wcss_qcs404_ops,
++	.requires_force_stop = false,
+ };
+ 
+ static const struct of_device_id q6v5_wcss_of_match[] = {
+ 	{ .compatible = "qcom,ipq8074-wcss-pil", .data = &wcss_ipq8074_res_init },
++	{ .compatible = "qcom,qcs404-wcss-pil", .data = &wcss_qcs404_res_init },
+ 	{ },
+ };
+ MODULE_DEVICE_TABLE(of, q6v5_wcss_of_match);
diff --git a/target/linux/ipq807x/patches-5.10/005-v5.13-remoteproc-qcom-wcss-explicitly-request-exclusive-re.patch b/target/linux/ipq807x/patches-5.10/005-v5.13-remoteproc-qcom-wcss-explicitly-request-exclusive-re.patch
new file mode 100644
index 0000000..3b09a6d
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/005-v5.13-remoteproc-qcom-wcss-explicitly-request-exclusive-re.patch
@@ -0,0 +1,43 @@
+From 7b230496f6b45e840bc7b13e7df2a8676bab9230 Mon Sep 17 00:00:00 2001
+From: Govind Singh <govinds@codeaurora.org>
+Date: Fri, 29 Jan 2021 00:18:15 +0530
+Subject: [PATCH 04/16] remoteproc: qcom: wcss: explicitly request exclusive
+ reset control
+
+Use request exclusive reset control for wcss reset controls.
+
+Signed-off-by: Govind Singh <govinds@codeaurora.org>
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Link: https://lore.kernel.org/r/1611859695-11824-5-git-send-email-gokulsri@codeaurora.org
+Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -788,21 +788,21 @@ static int q6v5_wcss_init_reset(struct q
+ 	struct device *dev = wcss->dev;
+ 
+ 	if (desc->aon_reset_required) {
+-		wcss->wcss_aon_reset = devm_reset_control_get(dev, "wcss_aon_reset");
++		wcss->wcss_aon_reset = devm_reset_control_get_exclusive(dev, "wcss_aon_reset");
+ 		if (IS_ERR(wcss->wcss_aon_reset)) {
+ 			dev_err(wcss->dev, "fail to acquire wcss_aon_reset\n");
+ 			return PTR_ERR(wcss->wcss_aon_reset);
+ 		}
+ 	}
+ 
+-	wcss->wcss_reset = devm_reset_control_get(dev, "wcss_reset");
++	wcss->wcss_reset = devm_reset_control_get_exclusive(dev, "wcss_reset");
+ 	if (IS_ERR(wcss->wcss_reset)) {
+ 		dev_err(wcss->dev, "unable to acquire wcss_reset\n");
+ 		return PTR_ERR(wcss->wcss_reset);
+ 	}
+ 
+ 	if (desc->wcss_q6_reset_required) {
+-		wcss->wcss_q6_reset = devm_reset_control_get(dev, "wcss_q6_reset");
++		wcss->wcss_q6_reset = devm_reset_control_get_exclusive(dev, "wcss_q6_reset");
+ 		if (IS_ERR(wcss->wcss_q6_reset)) {
+ 			dev_err(wcss->dev, "unable to acquire wcss_q6_reset\n");
+ 			return PTR_ERR(wcss->wcss_q6_reset);
diff --git a/target/linux/ipq807x/patches-5.10/006-v5.13-remoteproc-qcom-wcss-Fix-return-value-check-in-q6v5_.patch b/target/linux/ipq807x/patches-5.10/006-v5.13-remoteproc-qcom-wcss-Fix-return-value-check-in-q6v5_.patch
new file mode 100644
index 0000000..fe5e33c
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/006-v5.13-remoteproc-qcom-wcss-Fix-return-value-check-in-q6v5_.patch
@@ -0,0 +1,32 @@
+From 5b8b0967576f04d2ee3ea36310c078a3d50e7339 Mon Sep 17 00:00:00 2001
+From: Wei Yongjun <weiyongjun1@huawei.com>
+Date: Fri, 19 Mar 2021 09:41:00 +0000
+Subject: [PATCH 05/16] remoteproc: qcom: wcss: Fix return value check in
+ q6v5_wcss_init_mmio()
+
+In case of error, the function devm_ioremap() returns NULL pointer
+not ERR_PTR(). The IS_ERR() test in the return value check should
+be replaced with NULL test.
+
+Fixes: 0af65b9b915e ("remoteproc: qcom: wcss: Add non pas wcss Q6 support for QCS404")
+Reported-by: Hulk Robot <hulkci@huawei.com>
+Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
+Link: https://lore.kernel.org/r/20210319094100.4185044-1-weiyongjun1@huawei.com
+Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -829,8 +829,8 @@ static int q6v5_wcss_init_mmio(struct q6
+ 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qdsp6");
+ 	wcss->reg_base = devm_ioremap(&pdev->dev, res->start,
+ 				      resource_size(res));
+-	if (IS_ERR(wcss->reg_base))
+-		return PTR_ERR(wcss->reg_base);
++	if (!wcss->reg_base)
++		return -ENOMEM;
+ 
+ 	if (wcss->version == WCSS_IPQ8074) {
+ 		res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "rmb");
diff --git a/target/linux/ipq807x/patches-5.10/007-v5.13-remoteproc-qcom-wcss-Fix-wrong-pointer-passed-to-PTR.patch b/target/linux/ipq807x/patches-5.10/007-v5.13-remoteproc-qcom-wcss-Fix-wrong-pointer-passed-to-PTR.patch
new file mode 100644
index 0000000..65676cf
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/007-v5.13-remoteproc-qcom-wcss-Fix-wrong-pointer-passed-to-PTR.patch
@@ -0,0 +1,32 @@
+From 6a52dbbde0e741e84f217cf762233589cc3efd13 Mon Sep 17 00:00:00 2001
+From: Wei Yongjun <weiyongjun1@huawei.com>
+Date: Fri, 26 Mar 2021 02:47:41 +0000
+Subject: [PATCH 06/16] remoteproc: qcom: wcss: Fix wrong pointer passed to
+ PTR_ERR()
+
+PTR_ERR should access the value just tested by IS_ERR, otherwise
+the wrong error code will be returned.
+
+This commit fix it by return 'ret' directly.
+
+Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
+Fixes: 0af65b9b915e ("remoteproc: qcom: wcss: Add non pas wcss Q6 support for QCS404")
+Reported-by: Hulk Robot <hulkci@huawei.com>
+Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
+Link: https://lore.kernel.org/r/20210326024741.841267-1-weiyongjun1@huawei.com
+Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -972,7 +972,7 @@ static int q6v5_wcss_init_clock(struct q
+ 		ret = PTR_ERR(wcss->qdsp6ss_axim_cbcr);
+ 		if (ret != -EPROBE_DEFER)
+ 			dev_err(wcss->dev, "failed to get axim cbcr clk\n");
+-		return PTR_ERR(wcss->qdsp6ss_abhm_cbcr);
++		return ret;
+ 	}
+ 
+ 	wcss->lcc_bcr_sleep = devm_clk_get(wcss->dev, "lcc_bcr_sleep");
diff --git a/target/linux/ipq807x/patches-5.10/008-v5.13-remoteproc-qcom-wcss-Remove-unnecessary-PTR_ERR.patch b/target/linux/ipq807x/patches-5.10/008-v5.13-remoteproc-qcom-wcss-Remove-unnecessary-PTR_ERR.patch
new file mode 100644
index 0000000..dff8bda
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/008-v5.13-remoteproc-qcom-wcss-Remove-unnecessary-PTR_ERR.patch
@@ -0,0 +1,89 @@
+From 00f24490f498db0ea67715a4dfe6c4a6ca11c6a0 Mon Sep 17 00:00:00 2001
+From: Junlin Yang <yangjunlin@yulong.com>
+Date: Thu, 8 Apr 2021 22:33:22 +0800
+Subject: [PATCH 07/16] remoteproc: qcom: wcss: Remove unnecessary PTR_ERR()
+
+Remove unnecessary PTR_ERR(), it has been assigned to ret before,
+so return ret directly.
+
+Signed-off-by: Junlin Yang <yangjunlin@yulong.com>
+Link: https://lore.kernel.org/r/20210408143322.1647-1-angkery@163.com
+Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 16 ++++++++--------
+ 1 file changed, 8 insertions(+), 8 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -913,7 +913,7 @@ static int q6v5_wcss_init_clock(struct q
+ 		ret = PTR_ERR(wcss->gcc_abhs_cbcr);
+ 		if (ret != -EPROBE_DEFER)
+ 			dev_err(wcss->dev, "failed to get gcc abhs clock");
+-		return PTR_ERR(wcss->gcc_abhs_cbcr);
++		return ret;
+ 	}
+ 
+ 	wcss->gcc_axim_cbcr = devm_clk_get(wcss->dev, "gcc_axim_cbcr");
+@@ -921,7 +921,7 @@ static int q6v5_wcss_init_clock(struct q
+ 		ret = PTR_ERR(wcss->gcc_axim_cbcr);
+ 		if (ret != -EPROBE_DEFER)
+ 			dev_err(wcss->dev, "failed to get gcc axim clock\n");
+-		return PTR_ERR(wcss->gcc_axim_cbcr);
++		return ret;
+ 	}
+ 
+ 	wcss->ahbfabric_cbcr_clk = devm_clk_get(wcss->dev,
+@@ -930,7 +930,7 @@ static int q6v5_wcss_init_clock(struct q
+ 		ret = PTR_ERR(wcss->ahbfabric_cbcr_clk);
+ 		if (ret != -EPROBE_DEFER)
+ 			dev_err(wcss->dev, "failed to get ahbfabric clock\n");
+-		return PTR_ERR(wcss->ahbfabric_cbcr_clk);
++		return ret;
+ 	}
+ 
+ 	wcss->lcc_csr_cbcr = devm_clk_get(wcss->dev, "tcsr_lcc_cbc");
+@@ -938,7 +938,7 @@ static int q6v5_wcss_init_clock(struct q
+ 		ret = PTR_ERR(wcss->lcc_csr_cbcr);
+ 		if (ret != -EPROBE_DEFER)
+ 			dev_err(wcss->dev, "failed to get csr cbcr clk\n");
+-		return PTR_ERR(wcss->lcc_csr_cbcr);
++		return ret;
+ 	}
+ 
+ 	wcss->ahbs_cbcr = devm_clk_get(wcss->dev,
+@@ -947,7 +947,7 @@ static int q6v5_wcss_init_clock(struct q
+ 		ret = PTR_ERR(wcss->ahbs_cbcr);
+ 		if (ret != -EPROBE_DEFER)
+ 			dev_err(wcss->dev, "failed to get ahbs_cbcr clk\n");
+-		return PTR_ERR(wcss->ahbs_cbcr);
++		return ret;
+ 	}
+ 
+ 	wcss->tcm_slave_cbcr = devm_clk_get(wcss->dev,
+@@ -956,7 +956,7 @@ static int q6v5_wcss_init_clock(struct q
+ 		ret = PTR_ERR(wcss->tcm_slave_cbcr);
+ 		if (ret != -EPROBE_DEFER)
+ 			dev_err(wcss->dev, "failed to get tcm cbcr clk\n");
+-		return PTR_ERR(wcss->tcm_slave_cbcr);
++		return ret;
+ 	}
+ 
+ 	wcss->qdsp6ss_abhm_cbcr = devm_clk_get(wcss->dev, "lcc_abhm_cbc");
+@@ -964,7 +964,7 @@ static int q6v5_wcss_init_clock(struct q
+ 		ret = PTR_ERR(wcss->qdsp6ss_abhm_cbcr);
+ 		if (ret != -EPROBE_DEFER)
+ 			dev_err(wcss->dev, "failed to get abhm cbcr clk\n");
+-		return PTR_ERR(wcss->qdsp6ss_abhm_cbcr);
++		return ret;
+ 	}
+ 
+ 	wcss->qdsp6ss_axim_cbcr = devm_clk_get(wcss->dev, "lcc_axim_cbc");
+@@ -980,7 +980,7 @@ static int q6v5_wcss_init_clock(struct q
+ 		ret = PTR_ERR(wcss->lcc_bcr_sleep);
+ 		if (ret != -EPROBE_DEFER)
+ 			dev_err(wcss->dev, "failed to get bcr cbcr clk\n");
+-		return PTR_ERR(wcss->lcc_bcr_sleep);
++		return ret;
+ 	}
+ 
+ 	return 0;
diff --git a/target/linux/ipq807x/patches-5.10/009-5.12-mtd-parsers-Add-Qcom-SMEM-parser.patch b/target/linux/ipq807x/patches-5.10/009-5.12-mtd-parsers-Add-Qcom-SMEM-parser.patch
new file mode 100644
index 0000000..a78dc82
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/009-5.12-mtd-parsers-Add-Qcom-SMEM-parser.patch
@@ -0,0 +1,217 @@
+From 803eb124e1a64e42888542c3444bfe6dac412c7f Mon Sep 17 00:00:00 2001
+From: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
+Date: Mon, 4 Jan 2021 09:41:35 +0530
+Subject: mtd: parsers: Add Qcom SMEM parser
+
+NAND based Qualcomm platforms have the partition table populated in the
+Shared Memory (SMEM). Hence, add a parser for parsing the partitions
+from it.
+
+Signed-off-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
+Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
+Link: https://lore.kernel.org/linux-mtd/20210104041137.113075-3-manivannan.sadhasivam@linaro.org
+---
+ drivers/mtd/parsers/Kconfig        |   8 ++
+ drivers/mtd/parsers/Makefile       |   1 +
+ drivers/mtd/parsers/qcomsmempart.c | 170 +++++++++++++++++++++++++++++++++++++
+ 3 files changed, 179 insertions(+)
+ create mode 100644 drivers/mtd/parsers/qcomsmempart.c
+
+--- a/drivers/mtd/parsers/Kconfig
++++ b/drivers/mtd/parsers/Kconfig
+@@ -196,6 +196,14 @@ config MTD_REDBOOT_PARTS_READONLY
+ 
+ endif # MTD_REDBOOT_PARTS
+ 
++config MTD_QCOMSMEM_PARTS
++	tristate "Qualcomm SMEM NAND flash partition parser"
++	depends on MTD_NAND_QCOM || COMPILE_TEST
++	depends on QCOM_SMEM
++	help
++	  This provides support for parsing partitions from Shared Memory (SMEM)
++	  for NAND flash on Qualcomm platforms.
++
+ config MTD_ROUTERBOOT_PARTS
+ 	tristate "RouterBoot flash partition parser"
+ 	depends on MTD && OF
+--- a/drivers/mtd/parsers/Makefile
++++ b/drivers/mtd/parsers/Makefile
+@@ -13,4 +13,5 @@ obj-$(CONFIG_MTD_AFS_PARTS)		+= afs.o
+ obj-$(CONFIG_MTD_PARSER_TRX)		+= parser_trx.o
+ obj-$(CONFIG_MTD_SHARPSL_PARTS)		+= sharpslpart.o
+ obj-$(CONFIG_MTD_REDBOOT_PARTS)		+= redboot.o
++obj-$(CONFIG_MTD_QCOMSMEM_PARTS)	+= qcomsmempart.o
+ obj-$(CONFIG_MTD_ROUTERBOOT_PARTS)		+= routerbootpart.o
+--- /dev/null
++++ b/drivers/mtd/parsers/qcomsmempart.c
+@@ -0,0 +1,170 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Qualcomm SMEM NAND flash partition parser
++ *
++ * Copyright (C) 2020, Linaro Ltd.
++ */
++
++#include <linux/ctype.h>
++#include <linux/module.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/partitions.h>
++#include <linux/slab.h>
++#include <linux/soc/qcom/smem.h>
++
++#define SMEM_AARM_PARTITION_TABLE	9
++#define SMEM_APPS			0
++
++#define SMEM_FLASH_PART_MAGIC1		0x55ee73aa
++#define SMEM_FLASH_PART_MAGIC2		0xe35ebddb
++#define SMEM_FLASH_PTABLE_V3		3
++#define SMEM_FLASH_PTABLE_V4		4
++#define SMEM_FLASH_PTABLE_MAX_PARTS_V3	16
++#define SMEM_FLASH_PTABLE_MAX_PARTS_V4	48
++#define SMEM_FLASH_PTABLE_HDR_LEN	(4 * sizeof(u32))
++#define SMEM_FLASH_PTABLE_NAME_SIZE	16
++
++/**
++ * struct smem_flash_pentry - SMEM Flash partition entry
++ * @name: Name of the partition
++ * @offset: Offset in blocks
++ * @length: Length of the partition in blocks
++ * @attr: Flags for this partition
++ */
++struct smem_flash_pentry {
++	char name[SMEM_FLASH_PTABLE_NAME_SIZE];
++	__le32 offset;
++	__le32 length;
++	u8 attr;
++} __packed __aligned(4);
++
++/**
++ * struct smem_flash_ptable - SMEM Flash partition table
++ * @magic1: Partition table Magic 1
++ * @magic2: Partition table Magic 2
++ * @version: Partition table version
++ * @numparts: Number of partitions in this ptable
++ * @pentry: Flash partition entries belonging to this ptable
++ */
++struct smem_flash_ptable {
++	__le32 magic1;
++	__le32 magic2;
++	__le32 version;
++	__le32 numparts;
++	struct smem_flash_pentry pentry[SMEM_FLASH_PTABLE_MAX_PARTS_V4];
++} __packed __aligned(4);
++
++static int parse_qcomsmem_part(struct mtd_info *mtd,
++			       const struct mtd_partition **pparts,
++			       struct mtd_part_parser_data *data)
++{
++	struct smem_flash_pentry *pentry;
++	struct smem_flash_ptable *ptable;
++	size_t len = SMEM_FLASH_PTABLE_HDR_LEN;
++	struct mtd_partition *parts;
++	int ret, i, numparts;
++	char *name, *c;
++
++	pr_debug("Parsing partition table info from SMEM\n");
++	ptable = qcom_smem_get(SMEM_APPS, SMEM_AARM_PARTITION_TABLE, &len);
++	if (IS_ERR(ptable)) {
++		pr_err("Error reading partition table header\n");
++		return PTR_ERR(ptable);
++	}
++
++	/* Verify ptable magic */
++	if (le32_to_cpu(ptable->magic1) != SMEM_FLASH_PART_MAGIC1 ||
++	    le32_to_cpu(ptable->magic2) != SMEM_FLASH_PART_MAGIC2) {
++		pr_err("Partition table magic verification failed\n");
++		return -EINVAL;
++	}
++
++	/* Ensure that # of partitions is less than the max we have allocated */
++	numparts = le32_to_cpu(ptable->numparts);
++	if (numparts > SMEM_FLASH_PTABLE_MAX_PARTS_V4) {
++		pr_err("Partition numbers exceed the max limit\n");
++		return -EINVAL;
++	}
++
++	/* Find out length of partition data based on table version */
++	if (le32_to_cpu(ptable->version) <= SMEM_FLASH_PTABLE_V3) {
++		len = SMEM_FLASH_PTABLE_HDR_LEN + SMEM_FLASH_PTABLE_MAX_PARTS_V3 *
++			sizeof(struct smem_flash_pentry);
++	} else if (le32_to_cpu(ptable->version) == SMEM_FLASH_PTABLE_V4) {
++		len = SMEM_FLASH_PTABLE_HDR_LEN + SMEM_FLASH_PTABLE_MAX_PARTS_V4 *
++			sizeof(struct smem_flash_pentry);
++	} else {
++		pr_err("Unknown ptable version (%d)", le32_to_cpu(ptable->version));
++		return -EINVAL;
++	}
++
++	/*
++	 * Now that the partition table header has been parsed, verified
++	 * and the length of the partition table calculated, read the
++	 * complete partition table
++	 */
++	ptable = qcom_smem_get(SMEM_APPS, SMEM_AARM_PARTITION_TABLE, &len);
++	if (IS_ERR_OR_NULL(ptable)) {
++		pr_err("Error reading partition table\n");
++		return PTR_ERR(ptable);
++	}
++
++	parts = kcalloc(numparts, sizeof(*parts), GFP_KERNEL);
++	if (!parts)
++		return -ENOMEM;
++
++	for (i = 0; i < numparts; i++) {
++		pentry = &ptable->pentry[i];
++		if (pentry->name[0] == '\0')
++			continue;
++
++		name = kstrdup(pentry->name, GFP_KERNEL);
++		if (!name) {
++			ret = -ENOMEM;
++			goto out_free_parts;
++		}
++
++		/* Convert name to lower case */
++		for (c = name; *c != '\0'; c++)
++			*c = tolower(*c);
++
++		parts[i].name = name;
++		parts[i].offset = le32_to_cpu(pentry->offset) * mtd->erasesize;
++		parts[i].mask_flags = pentry->attr;
++		parts[i].size = le32_to_cpu(pentry->length) * mtd->erasesize;
++		pr_debug("%d: %s offs=0x%08x size=0x%08x attr:0x%08x\n",
++			 i, pentry->name, le32_to_cpu(pentry->offset),
++			 le32_to_cpu(pentry->length), pentry->attr);
++	}
++
++	pr_debug("SMEM partition table found: ver: %d len: %d\n",
++		 le32_to_cpu(ptable->version), numparts);
++	*pparts = parts;
++
++	return numparts;
++
++out_free_parts:
++	while (--i >= 0)
++		kfree(parts[i].name);
++	kfree(parts);
++	*pparts = NULL;
++
++	return ret;
++}
++
++static const struct of_device_id qcomsmem_of_match_table[] = {
++	{ .compatible = "qcom,smem-part" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, qcomsmem_of_match_table);
++
++static struct mtd_part_parser mtd_parser_qcomsmem = {
++	.parse_fn = parse_qcomsmem_part,
++	.name = "qcomsmem",
++	.of_match_table = qcomsmem_of_match_table,
++};
++module_mtd_part_parser(mtd_parser_qcomsmem);
++
++MODULE_LICENSE("GPL v2");
++MODULE_AUTHOR("Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>");
++MODULE_DESCRIPTION("Qualcomm SMEM NAND flash partition parser");
diff --git a/target/linux/ipq807x/patches-5.10/010-v5.11-PCI-dwc-Drop-the-.set_num_vectors-host-op.patch b/target/linux/ipq807x/patches-5.10/010-v5.11-PCI-dwc-Drop-the-.set_num_vectors-host-op.patch
new file mode 100644
index 0000000..c8bdec8
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/010-v5.11-PCI-dwc-Drop-the-.set_num_vectors-host-op.patch
@@ -0,0 +1,120 @@
+From 80b960829a85e555b96bfd4e31f31b3db3e8f5da Mon Sep 17 00:00:00 2001
+From: Rob Herring <robh@kernel.org>
+Date: Thu, 5 Nov 2020 15:11:50 -0600
+Subject: [PATCH 1/5] PCI: dwc: Drop the .set_num_vectors() host op
+
+There's no reason for the .set_num_vectors() host op. Drivers needing a
+non-default value can just initialize pcie_port.num_vectors directly.
+
+Link: https://lore.kernel.org/r/20201105211159.1814485-8-robh@kernel.org
+Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
+Signed-off-by: Rob Herring <robh@kernel.org>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Acked-by: Jingoo Han <jingoohan1@gmail.com>
+Cc: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
+Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Cc: Bjorn Helgaas <bhelgaas@google.com>
+Cc: Thierry Reding <thierry.reding@gmail.com>
+Cc: Jonathan Hunter <jonathanh@nvidia.com>
+Cc: linux-tegra@vger.kernel.org
+---
+ .../pci/controller/dwc/pcie-designware-host.c | 19 ++++---------------
+ .../pci/controller/dwc/pcie-designware-plat.c |  7 +------
+ drivers/pci/controller/dwc/pcie-designware.h  |  1 -
+ drivers/pci/controller/dwc/pcie-tegra194.c    |  7 +------
+ 4 files changed, 6 insertions(+), 28 deletions(-)
+
+--- a/drivers/pci/controller/dwc/pcie-designware-host.c
++++ b/drivers/pci/controller/dwc/pcie-designware-host.c
+@@ -358,22 +358,11 @@ int dw_pcie_host_init(struct pcie_port *
+ 		pci->link_gen = of_pci_get_max_link_speed(np);
+ 
+ 	if (pci_msi_enabled()) {
+-		/*
+-		 * If a specific SoC driver needs to change the
+-		 * default number of vectors, it needs to implement
+-		 * the set_num_vectors callback.
+-		 */
+-		if (!pp->ops->set_num_vectors) {
++		if (!pp->num_vectors) {
+ 			pp->num_vectors = MSI_DEF_NUM_VECTORS;
+-		} else {
+-			pp->ops->set_num_vectors(pp);
+-
+-			if (pp->num_vectors > MAX_MSI_IRQS ||
+-			    pp->num_vectors == 0) {
+-				dev_err(dev,
+-					"Invalid number of vectors\n");
+-				return -EINVAL;
+-			}
++		} else if (pp->num_vectors > MAX_MSI_IRQS) {
++			dev_err(dev, "Invalid number of vectors\n");
++			return -EINVAL;
+ 		}
+ 
+ 		if (!pp->ops->msi_host_init) {
+--- a/drivers/pci/controller/dwc/pcie-designware-plat.c
++++ b/drivers/pci/controller/dwc/pcie-designware-plat.c
+@@ -44,14 +44,8 @@ static int dw_plat_pcie_host_init(struct
+ 	return 0;
+ }
+ 
+-static void dw_plat_set_num_vectors(struct pcie_port *pp)
+-{
+-	pp->num_vectors = MAX_MSI_IRQS;
+-}
+-
+ static const struct dw_pcie_host_ops dw_plat_pcie_host_ops = {
+ 	.host_init = dw_plat_pcie_host_init,
+-	.set_num_vectors = dw_plat_set_num_vectors,
+ };
+ 
+ static int dw_plat_pcie_establish_link(struct dw_pcie *pci)
+@@ -128,6 +122,7 @@ static int dw_plat_add_pcie_port(struct
+ 			return pp->msi_irq;
+ 	}
+ 
++	pp->num_vectors = MAX_MSI_IRQS;
+ 	pp->ops = &dw_plat_pcie_host_ops;
+ 
+ 	ret = dw_pcie_host_init(pp);
+--- a/drivers/pci/controller/dwc/pcie-designware.h
++++ b/drivers/pci/controller/dwc/pcie-designware.h
+@@ -174,7 +174,6 @@ enum dw_pcie_device_mode {
+ 
+ struct dw_pcie_host_ops {
+ 	int (*host_init)(struct pcie_port *pp);
+-	void (*set_num_vectors)(struct pcie_port *pp);
+ 	int (*msi_host_init)(struct pcie_port *pp);
+ };
+ 
+--- a/drivers/pci/controller/dwc/pcie-tegra194.c
++++ b/drivers/pci/controller/dwc/pcie-tegra194.c
+@@ -990,11 +990,6 @@ static int tegra_pcie_dw_link_up(struct
+ 	return !!(val & PCI_EXP_LNKSTA_DLLLA);
+ }
+ 
+-static void tegra_pcie_set_msi_vec_num(struct pcie_port *pp)
+-{
+-	pp->num_vectors = MAX_MSI_IRQS;
+-}
+-
+ static int tegra_pcie_dw_start_link(struct dw_pcie *pci)
+ {
+ 	struct tegra_pcie_dw *pcie = to_tegra_pcie(pci);
+@@ -1019,7 +1014,6 @@ static const struct dw_pcie_ops tegra_dw
+ 
+ static struct dw_pcie_host_ops tegra_pcie_dw_host_ops = {
+ 	.host_init = tegra_pcie_dw_host_init,
+-	.set_num_vectors = tegra_pcie_set_msi_vec_num,
+ };
+ 
+ static void tegra_pcie_disable_phy(struct tegra_pcie_dw *pcie)
+@@ -2003,6 +1997,7 @@ static int tegra_pcie_dw_probe(struct pl
+ 	pci->n_fts[1] = FTS_VAL;
+ 
+ 	pp = &pci->pp;
++	pp->num_vectors = MAX_MSI_IRQS;
+ 	pcie->dev = &pdev->dev;
+ 	pcie->mode = (enum dw_pcie_device_mode)data->mode;
+ 
diff --git a/target/linux/ipq807x/patches-5.10/011-v5.11-PCI-dwc-Move-MSI-interrupt-setup-into-DWC-common-cod.patch b/target/linux/ipq807x/patches-5.10/011-v5.11-PCI-dwc-Move-MSI-interrupt-setup-into-DWC-common-cod.patch
new file mode 100644
index 0000000..634e0b4
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/011-v5.11-PCI-dwc-Move-MSI-interrupt-setup-into-DWC-common-cod.patch
@@ -0,0 +1,288 @@
+From 264b6fd7baa53bfaef2a6d41067b9568dff7163a Mon Sep 17 00:00:00 2001
+From: Rob Herring <robh@kernel.org>
+Date: Thu, 5 Nov 2020 15:11:51 -0600
+Subject: [PATCH 2/5] PCI: dwc: Move MSI interrupt setup into DWC common code
+
+Platforms using the built-in DWC MSI controller all have a dedicated
+interrupt with "msi" name or at index 0, so let's move setting up the
+interrupt to the common DWC code.
+
+spear13xx and dra7xx are the 2 oddballs with muxed interrupts, so
+we need to prevent configuring the MSI interrupt by setting msi_irq
+to negative.
+
+Link: https://lore.kernel.org/r/20201105211159.1814485-9-robh@kernel.org
+Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
+Signed-off-by: Rob Herring <robh@kernel.org>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Acked-by: Jingoo Han <jingoohan1@gmail.com>
+Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Cc: Bjorn Helgaas <bhelgaas@google.com>
+Cc: Kukjin Kim <kgene@kernel.org>
+Cc: Krzysztof Kozlowski <krzk@kernel.org>
+Cc: Richard Zhu <hongxing.zhu@nxp.com>
+Cc: Lucas Stach <l.stach@pengutronix.de>
+Cc: Shawn Guo <shawnguo@kernel.org>
+Cc: Sascha Hauer <s.hauer@pengutronix.de>
+Cc: Pengutronix Kernel Team <kernel@pengutronix.de>
+Cc: Fabio Estevam <festevam@gmail.com>
+Cc: NXP Linux Team <linux-imx@nxp.com>
+Cc: Yue Wang <yue.wang@Amlogic.com>
+Cc: Kevin Hilman <khilman@baylibre.com>
+Cc: Neil Armstrong <narmstrong@baylibre.com>
+Cc: Jerome Brunet <jbrunet@baylibre.com>
+Cc: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+Cc: Jesper Nilsson <jesper.nilsson@axis.com>
+Cc: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
+Cc: Xiaowei Song <songxiaowei@hisilicon.com>
+Cc: Binghui Wang <wangbinghui@hisilicon.com>
+Cc: Stanimir Varbanov <svarbanov@mm-sol.com>
+Cc: Andy Gross <agross@kernel.org>
+Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
+Cc: Pratyush Anand <pratyush.anand@gmail.com>
+Cc: Thierry Reding <thierry.reding@gmail.com>
+Cc: Jonathan Hunter <jonathanh@nvidia.com>
+Cc: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
+Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
+Cc: linux-samsung-soc@vger.kernel.org
+Cc: linux-amlogic@lists.infradead.org
+Cc: linux-arm-kernel@axis.com
+Cc: linux-arm-msm@vger.kernel.org
+Cc: linux-tegra@vger.kernel.org
+---
+ drivers/pci/controller/dwc/pci-dra7xx.c       |  3 +++
+ drivers/pci/controller/dwc/pci-exynos.c       |  6 -----
+ drivers/pci/controller/dwc/pci-imx6.c         |  6 -----
+ drivers/pci/controller/dwc/pci-meson.c        |  6 -----
+ drivers/pci/controller/dwc/pcie-artpec6.c     |  6 -----
+ .../pci/controller/dwc/pcie-designware-host.c | 11 +++++++++-
+ .../pci/controller/dwc/pcie-designware-plat.c |  6 -----
+ drivers/pci/controller/dwc/pcie-histb.c       |  6 -----
+ drivers/pci/controller/dwc/pcie-kirin.c       | 22 -------------------
+ drivers/pci/controller/dwc/pcie-qcom.c        |  8 -------
+ drivers/pci/controller/dwc/pcie-spear13xx.c   |  1 +
+ drivers/pci/controller/dwc/pcie-tegra194.c    |  8 -------
+ drivers/pci/controller/dwc/pcie-uniphier.c    |  6 -----
+ 13 files changed, 14 insertions(+), 81 deletions(-)
+
+--- a/drivers/pci/controller/dwc/pci-dra7xx.c
++++ b/drivers/pci/controller/dwc/pci-dra7xx.c
+@@ -622,6 +622,9 @@ static int __init dra7xx_add_pcie_port(s
+ 	if (pp->irq < 0)
+ 		return pp->irq;
+ 
++	/* MSI IRQ is muxed */
++	pp->msi_irq = -ENODEV;
++
+ 	ret = dra7xx_pcie_init_irq_domain(pp);
+ 	if (ret < 0)
+ 		return ret;
+--- a/drivers/pci/controller/dwc/pci-exynos.c
++++ b/drivers/pci/controller/dwc/pci-exynos.c
+@@ -415,12 +415,6 @@ static int __init exynos_add_pcie_port(s
+ 		return ret;
+ 	}
+ 
+-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+-		pp->msi_irq = platform_get_irq(pdev, 0);
+-		if (pp->msi_irq < 0)
+-			return pp->msi_irq;
+-	}
+-
+ 	pp->ops = &exynos_pcie_host_ops;
+ 
+ 	ret = dw_pcie_host_init(pp);
+--- a/drivers/pci/controller/dwc/pci-imx6.c
++++ b/drivers/pci/controller/dwc/pci-imx6.c
+@@ -853,12 +853,6 @@ static int imx6_add_pcie_port(struct imx
+ 	struct device *dev = &pdev->dev;
+ 	int ret;
+ 
+-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+-		pp->msi_irq = platform_get_irq_byname(pdev, "msi");
+-		if (pp->msi_irq < 0)
+-			return pp->msi_irq;
+-	}
+-
+ 	pp->ops = &imx6_pcie_host_ops;
+ 
+ 	ret = dw_pcie_host_init(pp);
+--- a/drivers/pci/controller/dwc/pci-meson.c
++++ b/drivers/pci/controller/dwc/pci-meson.c
+@@ -405,12 +405,6 @@ static int meson_add_pcie_port(struct me
+ 	struct device *dev = &pdev->dev;
+ 	int ret;
+ 
+-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+-		pp->msi_irq = platform_get_irq(pdev, 0);
+-		if (pp->msi_irq < 0)
+-			return pp->msi_irq;
+-	}
+-
+ 	pp->ops = &meson_pcie_host_ops;
+ 
+ 	ret = dw_pcie_host_init(pp);
+--- a/drivers/pci/controller/dwc/pcie-artpec6.c
++++ b/drivers/pci/controller/dwc/pcie-artpec6.c
+@@ -348,12 +348,6 @@ static int artpec6_add_pcie_port(struct
+ 	struct device *dev = pci->dev;
+ 	int ret;
+ 
+-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+-		pp->msi_irq = platform_get_irq_byname(pdev, "msi");
+-		if (pp->msi_irq < 0)
+-			return pp->msi_irq;
+-	}
+-
+ 	pp->ops = &artpec6_pcie_host_ops;
+ 
+ 	ret = dw_pcie_host_init(pp);
+--- a/drivers/pci/controller/dwc/pcie-designware-host.c
++++ b/drivers/pci/controller/dwc/pcie-designware-host.c
+@@ -366,13 +366,22 @@ int dw_pcie_host_init(struct pcie_port *
+ 		}
+ 
+ 		if (!pp->ops->msi_host_init) {
++			if (!pp->msi_irq) {
++				pp->msi_irq = platform_get_irq_byname_optional(pdev, "msi");
++				if (pp->msi_irq < 0) {
++					pp->msi_irq = platform_get_irq(pdev, 0);
++					if (pp->msi_irq < 0)
++						return pp->msi_irq;
++				}
++			}
++
+ 			pp->msi_irq_chip = &dw_pci_msi_bottom_irq_chip;
+ 
+ 			ret = dw_pcie_allocate_domains(pp);
+ 			if (ret)
+ 				return ret;
+ 
+-			if (pp->msi_irq)
++			if (pp->msi_irq > 0)
+ 				irq_set_chained_handler_and_data(pp->msi_irq,
+ 							    dw_chained_msi_isr,
+ 							    pp);
+--- a/drivers/pci/controller/dwc/pcie-designware-plat.c
++++ b/drivers/pci/controller/dwc/pcie-designware-plat.c
+@@ -116,12 +116,6 @@ static int dw_plat_add_pcie_port(struct
+ 	if (pp->irq < 0)
+ 		return pp->irq;
+ 
+-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+-		pp->msi_irq = platform_get_irq(pdev, 0);
+-		if (pp->msi_irq < 0)
+-			return pp->msi_irq;
+-	}
+-
+ 	pp->num_vectors = MAX_MSI_IRQS;
+ 	pp->ops = &dw_plat_pcie_host_ops;
+ 
+--- a/drivers/pci/controller/dwc/pcie-histb.c
++++ b/drivers/pci/controller/dwc/pcie-histb.c
+@@ -400,12 +400,6 @@ static int histb_pcie_probe(struct platf
+ 		return PTR_ERR(hipcie->bus_reset);
+ 	}
+ 
+-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+-		pp->msi_irq = platform_get_irq_byname(pdev, "msi");
+-		if (pp->msi_irq < 0)
+-			return pp->msi_irq;
+-	}
+-
+ 	hipcie->phy = devm_phy_get(dev, "phy");
+ 	if (IS_ERR(hipcie->phy)) {
+ 		dev_info(dev, "no pcie-phy found\n");
+--- a/drivers/pci/controller/dwc/pcie-kirin.c
++++ b/drivers/pci/controller/dwc/pcie-kirin.c
+@@ -444,31 +444,9 @@ static const struct dw_pcie_host_ops kir
+ 	.host_init = kirin_pcie_host_init,
+ };
+ 
+-static int kirin_pcie_add_msi(struct dw_pcie *pci,
+-				struct platform_device *pdev)
+-{
+-	int irq;
+-
+-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+-		irq = platform_get_irq(pdev, 0);
+-		if (irq < 0)
+-			return irq;
+-
+-		pci->pp.msi_irq = irq;
+-	}
+-
+-	return 0;
+-}
+-
+ static int kirin_add_pcie_port(struct dw_pcie *pci,
+ 			       struct platform_device *pdev)
+ {
+-	int ret;
+-
+-	ret = kirin_pcie_add_msi(pci, pdev);
+-	if (ret)
+-		return ret;
+-
+ 	pci->pp.ops = &kirin_pcie_host_ops;
+ 
+ 	return dw_pcie_host_init(&pci->pp);
+--- a/drivers/pci/controller/dwc/pcie-qcom.c
++++ b/drivers/pci/controller/dwc/pcie-qcom.c
+@@ -1434,14 +1434,6 @@ static int qcom_pcie_probe(struct platfo
+ 
+ 	pp->ops = &qcom_pcie_dw_ops;
+ 
+-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+-		pp->msi_irq = platform_get_irq_byname(pdev, "msi");
+-		if (pp->msi_irq < 0) {
+-			ret = pp->msi_irq;
+-			goto err_pm_runtime_put;
+-		}
+-	}
+-
+ 	ret = phy_init(pcie->phy);
+ 	if (ret) {
+ 		pm_runtime_disable(&pdev->dev);
+--- a/drivers/pci/controller/dwc/pcie-spear13xx.c
++++ b/drivers/pci/controller/dwc/pcie-spear13xx.c
+@@ -183,6 +183,7 @@ static int spear13xx_add_pcie_port(struc
+ 	}
+ 
+ 	pp->ops = &spear13xx_pcie_host_ops;
++	pp->msi_irq = -ENODEV;
+ 
+ 	ret = dw_pcie_host_init(pp);
+ 	if (ret) {
+--- a/drivers/pci/controller/dwc/pcie-tegra194.c
++++ b/drivers/pci/controller/dwc/pcie-tegra194.c
+@@ -1554,14 +1554,6 @@ static int tegra_pcie_config_rp(struct t
+ 	char *name;
+ 	int ret;
+ 
+-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+-		pp->msi_irq = of_irq_get_byname(dev->of_node, "msi");
+-		if (!pp->msi_irq) {
+-			dev_err(dev, "Failed to get MSI interrupt\n");
+-			return -ENODEV;
+-		}
+-	}
+-
+ 	pm_runtime_enable(dev);
+ 
+ 	ret = pm_runtime_get_sync(dev);
+--- a/drivers/pci/controller/dwc/pcie-uniphier.c
++++ b/drivers/pci/controller/dwc/pcie-uniphier.c
+@@ -341,12 +341,6 @@ static int uniphier_add_pcie_port(struct
+ 
+ 	pp->ops = &uniphier_pcie_host_ops;
+ 
+-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+-		pp->msi_irq = platform_get_irq_byname(pdev, "msi");
+-		if (pp->msi_irq < 0)
+-			return pp->msi_irq;
+-	}
+-
+ 	ret = dw_pcie_host_init(pp);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to initialize host (%d)\n", ret);
diff --git a/target/linux/ipq807x/patches-5.10/012-v5.11-PCI-dwc-Rework-MSI-initialization.patch b/target/linux/ipq807x/patches-5.10/012-v5.11-PCI-dwc-Rework-MSI-initialization.patch
new file mode 100644
index 0000000..eac6c12
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/012-v5.11-PCI-dwc-Rework-MSI-initialization.patch
@@ -0,0 +1,199 @@
+From ed016f820e3f1b980dfe0ef6137069e008f99109 Mon Sep 17 00:00:00 2001
+From: Rob Herring <robh@kernel.org>
+Date: Thu, 5 Nov 2020 15:11:52 -0600
+Subject: [PATCH 3/5] PCI: dwc: Rework MSI initialization
+
+There are 3 possible MSI implementations for the DWC host. The first is
+using the built-in DWC MSI controller. The 2nd is a custom MSI
+controller as part of the PCI host (keystone only). The 3rd is an
+external MSI controller (typically GICv3 ITS). Currently, the last 2
+are distinguished with a .msi_host_init() hook with the 3rd option using
+an empty function. However we can detect the 3rd case with the presence
+of 'msi-parent' or 'msi-map' properties, so let's do that instead and
+remove the empty functions.
+
+Link: https://lore.kernel.org/r/20201105211159.1814485-10-robh@kernel.org
+Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
+Signed-off-by: Rob Herring <robh@kernel.org>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Acked-by: Jingoo Han <jingoohan1@gmail.com>
+Cc: Murali Karicheri <m-karicheri2@ti.com>
+Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Cc: Bjorn Helgaas <bhelgaas@google.com>
+Cc: Minghuan Lian <minghuan.Lian@nxp.com>
+Cc: Mingkai Hu <mingkai.hu@nxp.com>
+Cc: Roy Zang <roy.zang@nxp.com>
+Cc: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
+Cc: linuxppc-dev@lists.ozlabs.org
+---
+ drivers/pci/controller/dwc/pci-keystone.c     |  9 -------
+ drivers/pci/controller/dwc/pci-layerscape.c   | 25 -------------------
+ .../pci/controller/dwc/pcie-designware-host.c | 20 +++++++++------
+ drivers/pci/controller/dwc/pcie-designware.h  |  1 +
+ drivers/pci/controller/dwc/pcie-intel-gw.c    |  9 -------
+ 5 files changed, 13 insertions(+), 51 deletions(-)
+
+--- a/drivers/pci/controller/dwc/pci-keystone.c
++++ b/drivers/pci/controller/dwc/pci-keystone.c
+@@ -272,14 +272,6 @@ static void ks_pcie_handle_legacy_irq(st
+ 	ks_pcie_app_writel(ks_pcie, IRQ_EOI, offset);
+ }
+ 
+-/*
+- * Dummy function so that DW core doesn't configure MSI
+- */
+-static int ks_pcie_am654_msi_host_init(struct pcie_port *pp)
+-{
+-	return 0;
+-}
+-
+ static void ks_pcie_enable_error_irq(struct keystone_pcie *ks_pcie)
+ {
+ 	ks_pcie_app_writel(ks_pcie, ERR_IRQ_ENABLE_SET, ERR_IRQ_ALL);
+@@ -855,7 +847,6 @@ static const struct dw_pcie_host_ops ks_
+ 
+ static const struct dw_pcie_host_ops ks_pcie_am654_host_ops = {
+ 	.host_init = ks_pcie_host_init,
+-	.msi_host_init = ks_pcie_am654_msi_host_init,
+ };
+ 
+ static irqreturn_t ks_pcie_err_irq_handler(int irq, void *priv)
+--- a/drivers/pci/controller/dwc/pci-layerscape.c
++++ b/drivers/pci/controller/dwc/pci-layerscape.c
+@@ -182,37 +182,12 @@ static int ls1021_pcie_host_init(struct
+ 	return ls_pcie_host_init(pp);
+ }
+ 
+-static int ls_pcie_msi_host_init(struct pcie_port *pp)
+-{
+-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+-	struct device *dev = pci->dev;
+-	struct device_node *np = dev->of_node;
+-	struct device_node *msi_node;
+-
+-	/*
+-	 * The MSI domain is set by the generic of_msi_configure().  This
+-	 * .msi_host_init() function keeps us from doing the default MSI
+-	 * domain setup in dw_pcie_host_init() and also enforces the
+-	 * requirement that "msi-parent" exists.
+-	 */
+-	msi_node = of_parse_phandle(np, "msi-parent", 0);
+-	if (!msi_node) {
+-		dev_err(dev, "failed to find msi-parent\n");
+-		return -EINVAL;
+-	}
+-
+-	of_node_put(msi_node);
+-	return 0;
+-}
+-
+ static const struct dw_pcie_host_ops ls1021_pcie_host_ops = {
+ 	.host_init = ls1021_pcie_host_init,
+-	.msi_host_init = ls_pcie_msi_host_init,
+ };
+ 
+ static const struct dw_pcie_host_ops ls_pcie_host_ops = {
+ 	.host_init = ls_pcie_host_init,
+-	.msi_host_init = ls_pcie_msi_host_init,
+ };
+ 
+ static const struct dw_pcie_ops dw_ls1021_pcie_ops = {
+--- a/drivers/pci/controller/dwc/pcie-designware-host.c
++++ b/drivers/pci/controller/dwc/pcie-designware-host.c
+@@ -358,6 +358,10 @@ int dw_pcie_host_init(struct pcie_port *
+ 		pci->link_gen = of_pci_get_max_link_speed(np);
+ 
+ 	if (pci_msi_enabled()) {
++		pp->has_msi_ctrl = !(pp->ops->msi_host_init ||
++				     of_property_read_bool(np, "msi-parent") ||
++				     of_property_read_bool(np, "msi-map"));
++
+ 		if (!pp->num_vectors) {
+ 			pp->num_vectors = MSI_DEF_NUM_VECTORS;
+ 		} else if (pp->num_vectors > MAX_MSI_IRQS) {
+@@ -365,7 +369,11 @@ int dw_pcie_host_init(struct pcie_port *
+ 			return -EINVAL;
+ 		}
+ 
+-		if (!pp->ops->msi_host_init) {
++		if (pp->ops->msi_host_init) {
++			ret = pp->ops->msi_host_init(pp);
++			if (ret < 0)
++				return ret;
++		} else if (pp->has_msi_ctrl) {
+ 			if (!pp->msi_irq) {
+ 				pp->msi_irq = platform_get_irq_byname_optional(pdev, "msi");
+ 				if (pp->msi_irq < 0) {
+@@ -395,10 +403,6 @@ int dw_pcie_host_init(struct pcie_port *
+ 				pp->msi_data = 0;
+ 				goto err_free_msi;
+ 			}
+-		} else {
+-			ret = pp->ops->msi_host_init(pp);
+-			if (ret < 0)
+-				return ret;
+ 		}
+ 	}
+ 
+@@ -419,7 +423,7 @@ int dw_pcie_host_init(struct pcie_port *
+ 		return 0;
+ 
+ err_free_msi:
+-	if (pci_msi_enabled() && !pp->ops->msi_host_init)
++	if (pp->has_msi_ctrl)
+ 		dw_pcie_free_msi(pp);
+ 	return ret;
+ }
+@@ -429,7 +433,7 @@ void dw_pcie_host_deinit(struct pcie_por
+ {
+ 	pci_stop_root_bus(pp->bridge->bus);
+ 	pci_remove_root_bus(pp->bridge->bus);
+-	if (pci_msi_enabled() && !pp->ops->msi_host_init)
++	if (pp->has_msi_ctrl)
+ 		dw_pcie_free_msi(pp);
+ }
+ EXPORT_SYMBOL_GPL(dw_pcie_host_deinit);
+@@ -540,7 +544,7 @@ void dw_pcie_setup_rc(struct pcie_port *
+ 
+ 	dw_pcie_setup(pci);
+ 
+-	if (pci_msi_enabled() && !pp->ops->msi_host_init) {
++	if (pp->has_msi_ctrl) {
+ 		num_ctrls = pp->num_vectors / MAX_MSI_IRQS_PER_CTRL;
+ 
+ 		/* Initialize IRQ Status array */
+--- a/drivers/pci/controller/dwc/pcie-designware.h
++++ b/drivers/pci/controller/dwc/pcie-designware.h
+@@ -178,6 +178,7 @@ struct dw_pcie_host_ops {
+ };
+ 
+ struct pcie_port {
++	bool			has_msi_ctrl:1;
+ 	u64			cfg0_base;
+ 	void __iomem		*va_cfg0_base;
+ 	u32			cfg0_size;
+--- a/drivers/pci/controller/dwc/pcie-intel-gw.c
++++ b/drivers/pci/controller/dwc/pcie-intel-gw.c
+@@ -403,14 +403,6 @@ static int intel_pcie_rc_init(struct pci
+ 	return intel_pcie_host_setup(lpp);
+ }
+ 
+-/*
+- * Dummy function so that DW core doesn't configure MSI
+- */
+-static int intel_pcie_msi_init(struct pcie_port *pp)
+-{
+-	return 0;
+-}
+-
+ static u64 intel_pcie_cpu_addr(struct dw_pcie *pcie, u64 cpu_addr)
+ {
+ 	return cpu_addr + BUS_IATU_OFFSET;
+@@ -422,7 +414,6 @@ static const struct dw_pcie_ops intel_pc
+ 
+ static const struct dw_pcie_host_ops intel_pcie_dw_ops = {
+ 	.host_init =		intel_pcie_rc_init,
+-	.msi_host_init =	intel_pcie_msi_init,
+ };
+ 
+ static const struct intel_pcie_soc pcie_data = {
diff --git a/target/linux/ipq807x/patches-5.10/013-v5.11-PCI-dwc-Move-link-handling-into-common-code.patch b/target/linux/ipq807x/patches-5.10/013-v5.11-PCI-dwc-Move-link-handling-into-common-code.patch
new file mode 100644
index 0000000..b12da22
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/013-v5.11-PCI-dwc-Move-link-handling-into-common-code.patch
@@ -0,0 +1,603 @@
+From 533bee2aeda70c212a3fb5547d5beb6406e3ccf7 Mon Sep 17 00:00:00 2001
+From: Rob Herring <robh@kernel.org>
+Date: Thu, 5 Nov 2020 15:11:53 -0600
+Subject: [PATCH 4/5] PCI: dwc: Move link handling into common code
+
+All the DWC drivers do link setup and checks at roughly the same time.
+Let's use the existing .start_link() hook (currently only used in EP
+mode) and move the link handling to the core code.
+
+The behavior for a link down was inconsistent as some drivers would fail
+probe in that case while others succeed. Let's standardize this to
+succeed as there are usecases where devices (and the link) appear later
+even without hotplug. For example, a reconfigured FPGA device.
+
+Link: https://lore.kernel.org/r/20201105211159.1814485-11-robh@kernel.org
+Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
+Signed-off-by: Rob Herring <robh@kernel.org>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Acked-by: Jingoo Han <jingoohan1@gmail.com>
+Cc: Kishon Vijay Abraham I <kishon@ti.com>
+Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Cc: Bjorn Helgaas <bhelgaas@google.com>
+Cc: Kukjin Kim <kgene@kernel.org>
+Cc: Krzysztof Kozlowski <krzk@kernel.org>
+Cc: Richard Zhu <hongxing.zhu@nxp.com>
+Cc: Lucas Stach <l.stach@pengutronix.de>
+Cc: Shawn Guo <shawnguo@kernel.org>
+Cc: Sascha Hauer <s.hauer@pengutronix.de>
+Cc: Pengutronix Kernel Team <kernel@pengutronix.de>
+Cc: Fabio Estevam <festevam@gmail.com>
+Cc: NXP Linux Team <linux-imx@nxp.com>
+Cc: Murali Karicheri <m-karicheri2@ti.com>
+Cc: Yue Wang <yue.wang@Amlogic.com>
+Cc: Kevin Hilman <khilman@baylibre.com>
+Cc: Neil Armstrong <narmstrong@baylibre.com>
+Cc: Jerome Brunet <jbrunet@baylibre.com>
+Cc: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+Cc: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+Cc: Jesper Nilsson <jesper.nilsson@axis.com>
+Cc: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
+Cc: Xiaowei Song <songxiaowei@hisilicon.com>
+Cc: Binghui Wang <wangbinghui@hisilicon.com>
+Cc: Andy Gross <agross@kernel.org>
+Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
+Cc: Stanimir Varbanov <svarbanov@mm-sol.com>
+Cc: Pratyush Anand <pratyush.anand@gmail.com>
+Cc: Thierry Reding <thierry.reding@gmail.com>
+Cc: Jonathan Hunter <jonathanh@nvidia.com>
+Cc: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
+Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
+Cc: linux-omap@vger.kernel.org
+Cc: linux-samsung-soc@vger.kernel.org
+Cc: linux-amlogic@lists.infradead.org
+Cc: linux-arm-kernel@axis.com
+Cc: linux-arm-msm@vger.kernel.org
+Cc: linux-tegra@vger.kernel.org
+---
+ drivers/pci/controller/dwc/pci-dra7xx.c       |  2 -
+ drivers/pci/controller/dwc/pci-exynos.c       | 41 +++++++----------
+ drivers/pci/controller/dwc/pci-imx6.c         |  9 ++--
+ drivers/pci/controller/dwc/pci-keystone.c     |  9 ----
+ drivers/pci/controller/dwc/pci-meson.c        | 24 ++++------
+ drivers/pci/controller/dwc/pcie-armada8k.c    | 39 +++++++---------
+ drivers/pci/controller/dwc/pcie-artpec6.c     |  2 -
+ .../pci/controller/dwc/pcie-designware-host.c |  9 ++++
+ .../pci/controller/dwc/pcie-designware-plat.c |  3 --
+ drivers/pci/controller/dwc/pcie-histb.c       | 34 +++++++-------
+ drivers/pci/controller/dwc/pcie-kirin.c       | 23 ++--------
+ drivers/pci/controller/dwc/pcie-qcom.c        | 19 ++------
+ drivers/pci/controller/dwc/pcie-spear13xx.c   | 46 ++++++++-----------
+ drivers/pci/controller/dwc/pcie-tegra194.c    |  1 -
+ drivers/pci/controller/dwc/pcie-uniphier.c    | 13 ++----
+ 15 files changed, 103 insertions(+), 171 deletions(-)
+
+--- a/drivers/pci/controller/dwc/pci-dra7xx.c
++++ b/drivers/pci/controller/dwc/pci-dra7xx.c
+@@ -183,8 +183,6 @@ static int dra7xx_pcie_host_init(struct
+ 
+ 	dw_pcie_setup_rc(pp);
+ 
+-	dra7xx_pcie_establish_link(pci);
+-	dw_pcie_wait_for_link(pci);
+ 	dw_pcie_msi_init(pp);
+ 	dra7xx_pcie_enable_interrupts(dra7xx);
+ 
+--- a/drivers/pci/controller/dwc/pci-exynos.c
++++ b/drivers/pci/controller/dwc/pci-exynos.c
+@@ -229,30 +229,9 @@ static void exynos_pcie_assert_reset(str
+ 				GPIOF_OUT_INIT_HIGH, "RESET");
+ }
+ 
+-static int exynos_pcie_establish_link(struct exynos_pcie *ep)
++static int exynos_pcie_start_link(struct dw_pcie *pci)
+ {
+-	struct dw_pcie *pci = ep->pci;
+-	struct pcie_port *pp = &pci->pp;
+-	struct device *dev = pci->dev;
+-
+-	if (dw_pcie_link_up(pci)) {
+-		dev_err(dev, "Link already up\n");
+-		return 0;
+-	}
+-
+-	exynos_pcie_assert_core_reset(ep);
+-
+-	phy_reset(ep->phy);
+-
+-	exynos_pcie_writel(ep->mem_res->elbi_base, 1,
+-			PCIE_PWR_RESET);
+-
+-	phy_power_on(ep->phy);
+-	phy_init(ep->phy);
+-
+-	exynos_pcie_deassert_core_reset(ep);
+-	dw_pcie_setup_rc(pp);
+-	exynos_pcie_assert_reset(ep);
++	struct exynos_pcie *ep = to_exynos_pcie(pci);
+ 
+ 	/* assert LTSSM enable */
+ 	exynos_pcie_writel(ep->mem_res->elbi_base, PCIE_ELBI_LTSSM_ENABLE,
+@@ -386,7 +365,20 @@ static int exynos_pcie_host_init(struct
+ 
+ 	pp->bridge->ops = &exynos_pci_ops;
+ 
+-	exynos_pcie_establish_link(ep);
++	exynos_pcie_assert_core_reset(ep);
++
++	phy_reset(ep->phy);
++
++	exynos_pcie_writel(ep->mem_res->elbi_base, 1,
++			PCIE_PWR_RESET);
++
++	phy_power_on(ep->phy);
++	phy_init(ep->phy);
++
++	exynos_pcie_deassert_core_reset(ep);
++	dw_pcie_setup_rc(pp);
++	exynos_pcie_assert_reset(ep);
++
+ 	exynos_pcie_enable_interrupts(ep);
+ 
+ 	return 0;
+@@ -430,6 +422,7 @@ static const struct dw_pcie_ops dw_pcie_
+ 	.read_dbi = exynos_pcie_read_dbi,
+ 	.write_dbi = exynos_pcie_write_dbi,
+ 	.link_up = exynos_pcie_link_up,
++	.start_link = exynos_pcie_start_link,
+ };
+ 
+ static int __init exynos_pcie_probe(struct platform_device *pdev)
+--- a/drivers/pci/controller/dwc/pci-imx6.c
++++ b/drivers/pci/controller/dwc/pci-imx6.c
+@@ -745,9 +745,9 @@ static void imx6_pcie_ltssm_enable(struc
+ 	}
+ }
+ 
+-static int imx6_pcie_establish_link(struct imx6_pcie *imx6_pcie)
++static int imx6_pcie_start_link(struct dw_pcie *pci)
+ {
+-	struct dw_pcie *pci = imx6_pcie->pci;
++	struct imx6_pcie *imx6_pcie = to_imx6_pcie(pci);
+ 	struct device *dev = pci->dev;
+ 	u8 offset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);
+ 	u32 tmp;
+@@ -835,7 +835,6 @@ static int imx6_pcie_host_init(struct pc
+ 	imx6_pcie_deassert_core_reset(imx6_pcie);
+ 	imx6_setup_phy_mpll(imx6_pcie);
+ 	dw_pcie_setup_rc(pp);
+-	imx6_pcie_establish_link(imx6_pcie);
+ 	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+@@ -865,7 +864,7 @@ static int imx6_add_pcie_port(struct imx
+ }
+ 
+ static const struct dw_pcie_ops dw_pcie_ops = {
+-	/* No special ops needed, but pcie-designware still expects this struct */
++	.start_link = imx6_pcie_start_link,
+ };
+ 
+ #ifdef CONFIG_PM_SLEEP
+@@ -974,7 +973,7 @@ static int imx6_pcie_resume_noirq(struct
+ 	imx6_pcie_deassert_core_reset(imx6_pcie);
+ 	dw_pcie_setup_rc(pp);
+ 
+-	ret = imx6_pcie_establish_link(imx6_pcie);
++	ret = imx6_pcie_start_link(imx6_pcie->pci);
+ 	if (ret < 0)
+ 		dev_info(dev, "pcie link is down after resume.\n");
+ 
+--- a/drivers/pci/controller/dwc/pci-keystone.c
++++ b/drivers/pci/controller/dwc/pci-keystone.c
+@@ -511,14 +511,8 @@ static void ks_pcie_stop_link(struct dw_
+ static int ks_pcie_start_link(struct dw_pcie *pci)
+ {
+ 	struct keystone_pcie *ks_pcie = to_keystone_pcie(pci);
+-	struct device *dev = pci->dev;
+ 	u32 val;
+ 
+-	if (dw_pcie_link_up(pci)) {
+-		dev_dbg(dev, "link is already up\n");
+-		return 0;
+-	}
+-
+ 	/* Initiate Link Training */
+ 	val = ks_pcie_app_readl(ks_pcie, CMD_STATUS);
+ 	ks_pcie_app_writel(ks_pcie, CMD_STATUS, LTSSM_EN_VAL | val);
+@@ -834,9 +828,6 @@ static int __init ks_pcie_host_init(stru
+ 			"Asynchronous external abort");
+ #endif
+ 
+-	ks_pcie_start_link(pci);
+-	dw_pcie_wait_for_link(pci);
+-
+ 	return 0;
+ }
+ 
+--- a/drivers/pci/controller/dwc/pci-meson.c
++++ b/drivers/pci/controller/dwc/pci-meson.c
+@@ -231,7 +231,7 @@ static void meson_pcie_assert_reset(stru
+ 	gpiod_set_value_cansleep(mp->reset_gpio, 0);
+ }
+ 
+-static void meson_pcie_init_dw(struct meson_pcie *mp)
++static void meson_pcie_ltssm_enable(struct meson_pcie *mp)
+ {
+ 	u32 val;
+ 
+@@ -289,20 +289,14 @@ static void meson_set_max_rd_req_size(st
+ 	dw_pcie_writel_dbi(pci, offset + PCI_EXP_DEVCTL, val);
+ }
+ 
+-static int meson_pcie_establish_link(struct meson_pcie *mp)
++static int meson_pcie_start_link(struct dw_pcie *pci)
+ {
+-	struct dw_pcie *pci = &mp->pci;
+-	struct pcie_port *pp = &pci->pp;
+-
+-	meson_pcie_init_dw(mp);
+-	meson_set_max_payload(mp, MAX_PAYLOAD_SIZE);
+-	meson_set_max_rd_req_size(mp, MAX_READ_REQ_SIZE);
+-
+-	dw_pcie_setup_rc(pp);
++	struct meson_pcie *mp = to_meson_pcie(pci);
+ 
++	meson_pcie_ltssm_enable(mp);
+ 	meson_pcie_assert_reset(mp);
+ 
+-	return dw_pcie_wait_for_link(pci);
++	return 0;
+ }
+ 
+ static int meson_pcie_rd_own_conf(struct pci_bus *bus, u32 devfn,
+@@ -380,14 +374,13 @@ static int meson_pcie_host_init(struct p
+ {
+ 	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+ 	struct meson_pcie *mp = to_meson_pcie(pci);
+-	int ret;
+ 
+ 	pp->bridge->ops = &meson_pci_ops;
+ 
+-	ret = meson_pcie_establish_link(mp);
+-	if (ret)
+-		return ret;
++	meson_set_max_payload(mp, MAX_PAYLOAD_SIZE);
++	meson_set_max_rd_req_size(mp, MAX_READ_REQ_SIZE);
+ 
++	dw_pcie_setup_rc(pp);
+ 	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+@@ -418,6 +411,7 @@ static int meson_add_pcie_port(struct me
+ 
+ static const struct dw_pcie_ops dw_pcie_ops = {
+ 	.link_up = meson_pcie_link_up,
++	.start_link = meson_pcie_start_link,
+ };
+ 
+ static int meson_pcie_probe(struct platform_device *pdev)
+--- a/drivers/pci/controller/dwc/pcie-armada8k.c
++++ b/drivers/pci/controller/dwc/pcie-armada8k.c
+@@ -154,10 +154,24 @@ static int armada8k_pcie_link_up(struct
+ 	return 0;
+ }
+ 
+-static void armada8k_pcie_establish_link(struct armada8k_pcie *pcie)
++static int armada8k_pcie_start_link(struct dw_pcie *pci)
++{
++	u32 reg;
++
++	/* Start LTSSM */
++	reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_CONTROL_REG);
++	reg |= PCIE_APP_LTSSM_EN;
++	dw_pcie_writel_dbi(pci, PCIE_GLOBAL_CONTROL_REG, reg);
++
++	return 0;
++}
++
++static int armada8k_pcie_host_init(struct pcie_port *pp)
+ {
+-	struct dw_pcie *pci = pcie->pci;
+ 	u32 reg;
++	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
++
++	dw_pcie_setup_rc(pp);
+ 
+ 	if (!dw_pcie_link_up(pci)) {
+ 		/* Disable LTSSM state machine to enable configuration */
+@@ -193,26 +207,6 @@ static void armada8k_pcie_establish_link
+ 	       PCIE_INT_C_ASSERT_MASK | PCIE_INT_D_ASSERT_MASK;
+ 	dw_pcie_writel_dbi(pci, PCIE_GLOBAL_INT_MASK1_REG, reg);
+ 
+-	if (!dw_pcie_link_up(pci)) {
+-		/* Configuration done. Start LTSSM */
+-		reg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_CONTROL_REG);
+-		reg |= PCIE_APP_LTSSM_EN;
+-		dw_pcie_writel_dbi(pci, PCIE_GLOBAL_CONTROL_REG, reg);
+-	}
+-
+-	/* Wait until the link becomes active again */
+-	if (dw_pcie_wait_for_link(pci))
+-		dev_err(pci->dev, "Link not up after reconfiguration\n");
+-}
+-
+-static int armada8k_pcie_host_init(struct pcie_port *pp)
+-{
+-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+-	struct armada8k_pcie *pcie = to_armada8k_pcie(pci);
+-
+-	dw_pcie_setup_rc(pp);
+-	armada8k_pcie_establish_link(pcie);
+-
+ 	return 0;
+ }
+ 
+@@ -269,6 +263,7 @@ static int armada8k_add_pcie_port(struct
+ 
+ static const struct dw_pcie_ops dw_pcie_ops = {
+ 	.link_up = armada8k_pcie_link_up,
++	.start_link = armada8k_pcie_start_link,
+ };
+ 
+ static int armada8k_pcie_probe(struct platform_device *pdev)
+--- a/drivers/pci/controller/dwc/pcie-artpec6.c
++++ b/drivers/pci/controller/dwc/pcie-artpec6.c
+@@ -329,8 +329,6 @@ static int artpec6_pcie_host_init(struct
+ 	artpec6_pcie_deassert_core_reset(artpec6_pcie);
+ 	artpec6_pcie_wait_for_phy(artpec6_pcie);
+ 	dw_pcie_setup_rc(pp);
+-	artpec6_pcie_establish_link(pci);
+-	dw_pcie_wait_for_link(pci);
+ 	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+--- a/drivers/pci/controller/dwc/pcie-designware-host.c
++++ b/drivers/pci/controller/dwc/pcie-designware-host.c
+@@ -416,6 +416,15 @@ int dw_pcie_host_init(struct pcie_port *
+ 			goto err_free_msi;
+ 	}
+ 
++	if (!dw_pcie_link_up(pci) && pci->ops->start_link) {
++		ret = pci->ops->start_link(pci);
++		if (ret)
++			goto err_free_msi;
++	}
++
++	/* Ignore errors, the link may come up later */
++	dw_pcie_wait_for_link(pci);
++
+ 	bridge->sysdata = pp;
+ 
+ 	ret = pci_host_probe(bridge);
+--- a/drivers/pci/controller/dwc/pcie-designware-plat.c
++++ b/drivers/pci/controller/dwc/pcie-designware-plat.c
+@@ -35,10 +35,7 @@ static const struct of_device_id dw_plat
+ 
+ static int dw_plat_pcie_host_init(struct pcie_port *pp)
+ {
+-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+-
+ 	dw_pcie_setup_rc(pp);
+-	dw_pcie_wait_for_link(pci);
+ 	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+--- a/drivers/pci/controller/dwc/pcie-histb.c
++++ b/drivers/pci/controller/dwc/pcie-histb.c
+@@ -169,39 +169,36 @@ static int histb_pcie_link_up(struct dw_
+ 	return 0;
+ }
+ 
+-static int histb_pcie_establish_link(struct pcie_port *pp)
++static int histb_pcie_start_link(struct dw_pcie *pci)
+ {
+-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+ 	struct histb_pcie *hipcie = to_histb_pcie(pci);
+ 	u32 regval;
+ 
+-	if (dw_pcie_link_up(pci)) {
+-		dev_info(pci->dev, "Link already up\n");
+-		return 0;
+-	}
+-
+-	/* PCIe RC work mode */
+-	regval = histb_pcie_readl(hipcie, PCIE_SYS_CTRL0);
+-	regval &= ~PCIE_DEVICE_TYPE_MASK;
+-	regval |= PCIE_WM_RC;
+-	histb_pcie_writel(hipcie, PCIE_SYS_CTRL0, regval);
+-
+-	/* setup root complex */
+-	dw_pcie_setup_rc(pp);
+-
+ 	/* assert LTSSM enable */
+ 	regval = histb_pcie_readl(hipcie, PCIE_SYS_CTRL7);
+ 	regval |= PCIE_APP_LTSSM_ENABLE;
+ 	histb_pcie_writel(hipcie, PCIE_SYS_CTRL7, regval);
+ 
+-	return dw_pcie_wait_for_link(pci);
++	return 0;
+ }
+ 
+ static int histb_pcie_host_init(struct pcie_port *pp)
+ {
++	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
++	struct histb_pcie *hipcie = to_histb_pcie(pci);
++	u32 regval;
++
+ 	pp->bridge->ops = &histb_pci_ops;
+ 
+-	histb_pcie_establish_link(pp);
++	/* PCIe RC work mode */
++	regval = histb_pcie_readl(hipcie, PCIE_SYS_CTRL0);
++	regval &= ~PCIE_DEVICE_TYPE_MASK;
++	regval |= PCIE_WM_RC;
++	histb_pcie_writel(hipcie, PCIE_SYS_CTRL0, regval);
++
++	/* setup root complex */
++	dw_pcie_setup_rc(pp);
++
+ 	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+@@ -300,6 +297,7 @@ static const struct dw_pcie_ops dw_pcie_
+ 	.read_dbi = histb_pcie_read_dbi,
+ 	.write_dbi = histb_pcie_write_dbi,
+ 	.link_up = histb_pcie_link_up,
++	.start_link = histb_pcie_start_link,
+ };
+ 
+ static int histb_pcie_probe(struct platform_device *pdev)
+--- a/drivers/pci/controller/dwc/pcie-kirin.c
++++ b/drivers/pci/controller/dwc/pcie-kirin.c
+@@ -395,32 +395,14 @@ static int kirin_pcie_link_up(struct dw_
+ 	return 0;
+ }
+ 
+-static int kirin_pcie_establish_link(struct pcie_port *pp)
++static int kirin_pcie_start_link(struct dw_pcie *pci)
+ {
+-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+ 	struct kirin_pcie *kirin_pcie = to_kirin_pcie(pci);
+-	struct device *dev = kirin_pcie->pci->dev;
+-	int count = 0;
+-
+-	if (kirin_pcie_link_up(pci))
+-		return 0;
+-
+-	dw_pcie_setup_rc(pp);
+ 
+ 	/* assert LTSSM enable */
+ 	kirin_apb_ctrl_writel(kirin_pcie, PCIE_LTSSM_ENABLE_BIT,
+ 			      PCIE_APP_LTSSM_ENABLE);
+ 
+-	/* check if the link is up or not */
+-	while (!kirin_pcie_link_up(pci)) {
+-		usleep_range(LINK_WAIT_MIN, LINK_WAIT_MAX);
+-		count++;
+-		if (count == 1000) {
+-			dev_err(dev, "Link Fail\n");
+-			return -EINVAL;
+-		}
+-	}
+-
+ 	return 0;
+ }
+ 
+@@ -428,7 +410,7 @@ static int kirin_pcie_host_init(struct p
+ {
+ 	pp->bridge->ops = &kirin_pci_ops;
+ 
+-	kirin_pcie_establish_link(pp);
++	dw_pcie_setup_rc(pp);
+ 	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+@@ -438,6 +420,7 @@ static const struct dw_pcie_ops kirin_dw
+ 	.read_dbi = kirin_pcie_read_dbi,
+ 	.write_dbi = kirin_pcie_write_dbi,
+ 	.link_up = kirin_pcie_link_up,
++	.start_link = kirin_pcie_start_link,
+ };
+ 
+ static const struct dw_pcie_host_ops kirin_pcie_host_ops = {
+--- a/drivers/pci/controller/dwc/pcie-qcom.c
++++ b/drivers/pci/controller/dwc/pcie-qcom.c
+@@ -207,18 +207,15 @@ static void qcom_ep_reset_deassert(struc
+ 	usleep_range(PERST_DELAY_US, PERST_DELAY_US + 500);
+ }
+ 
+-static int qcom_pcie_establish_link(struct qcom_pcie *pcie)
++static int qcom_pcie_start_link(struct dw_pcie *pci)
+ {
+-	struct dw_pcie *pci = pcie->pci;
+-
+-	if (dw_pcie_link_up(pci))
+-		return 0;
++	struct qcom_pcie *pcie = to_qcom_pcie(pci);
+ 
+ 	/* Enable Link Training state machine */
+ 	if (pcie->ops->ltssm_enable)
+ 		pcie->ops->ltssm_enable(pcie);
+ 
+-	return dw_pcie_wait_for_link(pci);
++	return 0;
+ }
+ 
+ static void qcom_pcie_2_1_0_ltssm_enable(struct qcom_pcie *pcie)
+@@ -1290,15 +1287,8 @@ static int qcom_pcie_host_init(struct pc
+ 
+ 	qcom_ep_reset_deassert(pcie);
+ 
+-	ret = qcom_pcie_establish_link(pcie);
+-	if (ret)
+-		goto err;
+-
+ 	return 0;
+-err:
+-	qcom_ep_reset_assert(pcie);
+-	if (pcie->ops->post_deinit)
+-		pcie->ops->post_deinit(pcie);
++
+ err_disable_phy:
+ 	phy_power_off(pcie->phy);
+ err_deinit:
+@@ -1365,6 +1355,7 @@ static const struct qcom_pcie_ops ops_2_
+ 
+ static const struct dw_pcie_ops dw_pcie_ops = {
+ 	.link_up = qcom_pcie_link_up,
++	.start_link = qcom_pcie_start_link,
+ };
+ 
+ static int qcom_pcie_probe(struct platform_device *pdev)
+--- a/drivers/pci/controller/dwc/pcie-tegra194.c
++++ b/drivers/pci/controller/dwc/pcie-tegra194.c
+@@ -1549,7 +1549,6 @@ static int tegra_pcie_deinit_controller(
+ 
+ static int tegra_pcie_config_rp(struct tegra_pcie_dw *pcie)
+ {
+-	struct pcie_port *pp = &pcie->pci.pp;
+ 	struct device *dev = pcie->dev;
+ 	char *name;
+ 	int ret;
+--- a/drivers/pci/controller/dwc/pcie-uniphier.c
++++ b/drivers/pci/controller/dwc/pcie-uniphier.c
+@@ -146,16 +146,13 @@ static int uniphier_pcie_link_up(struct
+ 	return (val & mask) == mask;
+ }
+ 
+-static int uniphier_pcie_establish_link(struct dw_pcie *pci)
++static int uniphier_pcie_start_link(struct dw_pcie *pci)
+ {
+ 	struct uniphier_pcie_priv *priv = to_uniphier_pcie(pci);
+ 
+-	if (dw_pcie_link_up(pci))
+-		return 0;
+-
+ 	uniphier_pcie_ltssm_enable(priv, true);
+ 
+-	return dw_pcie_wait_for_link(pci);
++	return 0;
+ }
+ 
+ static void uniphier_pcie_stop_link(struct dw_pcie *pci)
+@@ -318,10 +315,6 @@ static int uniphier_pcie_host_init(struc
+ 	uniphier_pcie_irq_enable(priv);
+ 
+ 	dw_pcie_setup_rc(pp);
+-	ret = uniphier_pcie_establish_link(pci);
+-	if (ret)
+-		return ret;
+-
+ 	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+@@ -385,7 +378,7 @@ out_clk_disable:
+ }
+ 
+ static const struct dw_pcie_ops dw_pcie_ops = {
+-	.start_link = uniphier_pcie_establish_link,
++	.start_link = uniphier_pcie_start_link,
+ 	.stop_link = uniphier_pcie_stop_link,
+ 	.link_up = uniphier_pcie_link_up,
+ };
diff --git a/target/linux/ipq807x/patches-5.10/014-v5.11-PCI-dwc-Move-dw_pcie_msi_init-into-core.patch b/target/linux/ipq807x/patches-5.10/014-v5.11-PCI-dwc-Move-dw_pcie_msi_init-into-core.patch
new file mode 100644
index 0000000..fda806e
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/014-v5.11-PCI-dwc-Move-dw_pcie_msi_init-into-core.patch
@@ -0,0 +1,272 @@
+From 02c98d70da854cd4d145afe800194768c5eefe1d Mon Sep 17 00:00:00 2001
+From: Rob Herring <robh@kernel.org>
+Date: Thu, 5 Nov 2020 15:11:54 -0600
+Subject: [PATCH 5/5] PCI: dwc: Move dw_pcie_msi_init() into core
+
+The host drivers which call dw_pcie_msi_init() are all the ones using
+the built-in MSI controller, so let's move it into the common DWC code.
+
+Link: https://lore.kernel.org/r/20201105211159.1814485-12-robh@kernel.org
+Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
+Signed-off-by: Rob Herring <robh@kernel.org>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Acked-by: Jingoo Han <jingoohan1@gmail.com>
+Cc: Kishon Vijay Abraham I <kishon@ti.com>
+Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Cc: Bjorn Helgaas <bhelgaas@google.com>
+Cc: Kukjin Kim <kgene@kernel.org>
+Cc: Krzysztof Kozlowski <krzk@kernel.org>
+Cc: Richard Zhu <hongxing.zhu@nxp.com>
+Cc: Lucas Stach <l.stach@pengutronix.de>
+Cc: Shawn Guo <shawnguo@kernel.org>
+Cc: Sascha Hauer <s.hauer@pengutronix.de>
+Cc: Pengutronix Kernel Team <kernel@pengutronix.de>
+Cc: Fabio Estevam <festevam@gmail.com>
+Cc: NXP Linux Team <linux-imx@nxp.com>
+Cc: Yue Wang <yue.wang@Amlogic.com>
+Cc: Kevin Hilman <khilman@baylibre.com>
+Cc: Neil Armstrong <narmstrong@baylibre.com>
+Cc: Jerome Brunet <jbrunet@baylibre.com>
+Cc: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+Cc: Jesper Nilsson <jesper.nilsson@axis.com>
+Cc: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
+Cc: Xiaowei Song <songxiaowei@hisilicon.com>
+Cc: Binghui Wang <wangbinghui@hisilicon.com>
+Cc: Stanimir Varbanov <svarbanov@mm-sol.com>
+Cc: Andy Gross <agross@kernel.org>
+Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
+Cc: Pratyush Anand <pratyush.anand@gmail.com>
+Cc: Thierry Reding <thierry.reding@gmail.com>
+Cc: Jonathan Hunter <jonathanh@nvidia.com>
+Cc: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
+Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
+Cc: linux-omap@vger.kernel.org
+Cc: linux-samsung-soc@vger.kernel.org
+Cc: linux-amlogic@lists.infradead.org
+Cc: linux-arm-kernel@axis.com
+Cc: linux-arm-msm@vger.kernel.org
+Cc: linux-tegra@vger.kernel.org
+---
+ drivers/pci/controller/dwc/pci-dra7xx.c           |  2 --
+ drivers/pci/controller/dwc/pci-exynos.c           |  4 ----
+ drivers/pci/controller/dwc/pci-imx6.c             |  1 -
+ drivers/pci/controller/dwc/pci-meson.c            |  1 -
+ drivers/pci/controller/dwc/pcie-artpec6.c         |  1 -
+ drivers/pci/controller/dwc/pcie-designware-host.c |  9 +++++----
+ drivers/pci/controller/dwc/pcie-designware-plat.c |  1 -
+ drivers/pci/controller/dwc/pcie-designware.h      | 10 ----------
+ drivers/pci/controller/dwc/pcie-histb.c           |  2 --
+ drivers/pci/controller/dwc/pcie-kirin.c           |  1 -
+ drivers/pci/controller/dwc/pcie-qcom.c            |  2 --
+ drivers/pci/controller/dwc/pcie-spear13xx.c       |  6 +-----
+ drivers/pci/controller/dwc/pcie-tegra194.c        |  2 --
+ drivers/pci/controller/dwc/pcie-uniphier.c        |  1 -
+ 14 files changed, 6 insertions(+), 37 deletions(-)
+
+--- a/drivers/pci/controller/dwc/pci-dra7xx.c
++++ b/drivers/pci/controller/dwc/pci-dra7xx.c
+@@ -182,8 +182,6 @@ static int dra7xx_pcie_host_init(struct
+ 	struct dra7xx_pcie *dra7xx = to_dra7xx_pcie(pci);
+ 
+ 	dw_pcie_setup_rc(pp);
+-
+-	dw_pcie_msi_init(pp);
+ 	dra7xx_pcie_enable_interrupts(dra7xx);
+ 
+ 	return 0;
+--- a/drivers/pci/controller/dwc/pci-exynos.c
++++ b/drivers/pci/controller/dwc/pci-exynos.c
+@@ -273,12 +273,8 @@ static irqreturn_t exynos_pcie_irq_handl
+ 
+ static void exynos_pcie_msi_init(struct exynos_pcie *ep)
+ {
+-	struct dw_pcie *pci = ep->pci;
+-	struct pcie_port *pp = &pci->pp;
+ 	u32 val;
+ 
+-	dw_pcie_msi_init(pp);
+-
+ 	/* enable MSI interrupt */
+ 	val = exynos_pcie_readl(ep->mem_res->elbi_base, PCIE_IRQ_EN_LEVEL);
+ 	val |= IRQ_MSI_ENABLE;
+--- a/drivers/pci/controller/dwc/pci-imx6.c
++++ b/drivers/pci/controller/dwc/pci-imx6.c
+@@ -835,7 +835,6 @@ static int imx6_pcie_host_init(struct pc
+ 	imx6_pcie_deassert_core_reset(imx6_pcie);
+ 	imx6_setup_phy_mpll(imx6_pcie);
+ 	dw_pcie_setup_rc(pp);
+-	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+ }
+--- a/drivers/pci/controller/dwc/pci-meson.c
++++ b/drivers/pci/controller/dwc/pci-meson.c
+@@ -381,7 +381,6 @@ static int meson_pcie_host_init(struct p
+ 	meson_set_max_rd_req_size(mp, MAX_READ_REQ_SIZE);
+ 
+ 	dw_pcie_setup_rc(pp);
+-	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+ }
+--- a/drivers/pci/controller/dwc/pcie-artpec6.c
++++ b/drivers/pci/controller/dwc/pcie-artpec6.c
+@@ -329,7 +329,6 @@ static int artpec6_pcie_host_init(struct
+ 	artpec6_pcie_deassert_core_reset(artpec6_pcie);
+ 	artpec6_pcie_wait_for_phy(artpec6_pcie);
+ 	dw_pcie_setup_rc(pp);
+-	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+ }
+--- a/drivers/pci/controller/dwc/pcie-designware-host.c
++++ b/drivers/pci/controller/dwc/pcie-designware-host.c
+@@ -256,7 +256,7 @@ int dw_pcie_allocate_domains(struct pcie
+ 	return 0;
+ }
+ 
+-void dw_pcie_free_msi(struct pcie_port *pp)
++static void dw_pcie_free_msi(struct pcie_port *pp)
+ {
+ 	if (pp->msi_irq) {
+ 		irq_set_chained_handler(pp->msi_irq, NULL);
+@@ -275,19 +275,18 @@ void dw_pcie_free_msi(struct pcie_port *
+ 	}
+ }
+ 
+-void dw_pcie_msi_init(struct pcie_port *pp)
++static void dw_pcie_msi_init(struct pcie_port *pp)
+ {
+ 	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+ 	u64 msi_target = (u64)pp->msi_data;
+ 
+-	if (!IS_ENABLED(CONFIG_PCI_MSI))
++	if (!pci_msi_enabled() || !pp->has_msi_ctrl)
+ 		return;
+ 
+ 	/* Program the msi_data */
+ 	dw_pcie_writel_dbi(pci, PCIE_MSI_ADDR_LO, lower_32_bits(msi_target));
+ 	dw_pcie_writel_dbi(pci, PCIE_MSI_ADDR_HI, upper_32_bits(msi_target));
+ }
+-EXPORT_SYMBOL_GPL(dw_pcie_msi_init);
+ 
+ int dw_pcie_host_init(struct pcie_port *pp)
+ {
+@@ -416,6 +415,8 @@ int dw_pcie_host_init(struct pcie_port *
+ 			goto err_free_msi;
+ 	}
+ 
++	dw_pcie_msi_init(pp);
++
+ 	if (!dw_pcie_link_up(pci) && pci->ops->start_link) {
+ 		ret = pci->ops->start_link(pci);
+ 		if (ret)
+--- a/drivers/pci/controller/dwc/pcie-designware-plat.c
++++ b/drivers/pci/controller/dwc/pcie-designware-plat.c
+@@ -36,7 +36,6 @@ static const struct of_device_id dw_plat
+ static int dw_plat_pcie_host_init(struct pcie_port *pp)
+ {
+ 	dw_pcie_setup_rc(pp);
+-	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+ }
+--- a/drivers/pci/controller/dwc/pcie-designware.h
++++ b/drivers/pci/controller/dwc/pcie-designware.h
+@@ -365,8 +365,6 @@ static inline void dw_pcie_dbi_ro_wr_dis
+ 
+ #ifdef CONFIG_PCIE_DW_HOST
+ irqreturn_t dw_handle_msi_irq(struct pcie_port *pp);
+-void dw_pcie_msi_init(struct pcie_port *pp);
+-void dw_pcie_free_msi(struct pcie_port *pp);
+ void dw_pcie_setup_rc(struct pcie_port *pp);
+ int dw_pcie_host_init(struct pcie_port *pp);
+ void dw_pcie_host_deinit(struct pcie_port *pp);
+@@ -379,14 +377,6 @@ static inline irqreturn_t dw_handle_msi_
+ 	return IRQ_NONE;
+ }
+ 
+-static inline void dw_pcie_msi_init(struct pcie_port *pp)
+-{
+-}
+-
+-static inline void dw_pcie_free_msi(struct pcie_port *pp)
+-{
+-}
+-
+ static inline void dw_pcie_setup_rc(struct pcie_port *pp)
+ {
+ }
+--- a/drivers/pci/controller/dwc/pcie-histb.c
++++ b/drivers/pci/controller/dwc/pcie-histb.c
+@@ -199,8 +199,6 @@ static int histb_pcie_host_init(struct p
+ 	/* setup root complex */
+ 	dw_pcie_setup_rc(pp);
+ 
+-	dw_pcie_msi_init(pp);
+-
+ 	return 0;
+ }
+ 
+--- a/drivers/pci/controller/dwc/pcie-kirin.c
++++ b/drivers/pci/controller/dwc/pcie-kirin.c
+@@ -411,7 +411,6 @@ static int kirin_pcie_host_init(struct p
+ 	pp->bridge->ops = &kirin_pci_ops;
+ 
+ 	dw_pcie_setup_rc(pp);
+-	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+ }
+--- a/drivers/pci/controller/dwc/pcie-qcom.c
++++ b/drivers/pci/controller/dwc/pcie-qcom.c
+@@ -1283,8 +1283,6 @@ static int qcom_pcie_host_init(struct pc
+ 	}
+ 
+ 	dw_pcie_setup_rc(pp);
+-	dw_pcie_msi_init(pp);
+-
+ 	qcom_ep_reset_deassert(pcie);
+ 
+ 	return 0;
+--- a/drivers/pci/controller/dwc/pcie-spear13xx.c
++++ b/drivers/pci/controller/dwc/pcie-spear13xx.c
+@@ -124,16 +124,12 @@ static irqreturn_t spear13xx_pcie_irq_ha
+ 
+ static void spear13xx_pcie_enable_interrupts(struct spear13xx_pcie *spear13xx_pcie)
+ {
+-	struct dw_pcie *pci = spear13xx_pcie->pci;
+-	struct pcie_port *pp = &pci->pp;
+ 	struct pcie_app_reg *app_reg = spear13xx_pcie->app_base;
+ 
+ 	/* Enable MSI interrupt */
+-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+-		dw_pcie_msi_init(pp);
++	if (IS_ENABLED(CONFIG_PCI_MSI))
+ 		writel(readl(&app_reg->int_mask) |
+ 				MSI_CTRL_INT, &app_reg->int_mask);
+-	}
+ }
+ 
+ static int spear13xx_pcie_link_up(struct dw_pcie *pci)
+--- a/drivers/pci/controller/dwc/pcie-tegra194.c
++++ b/drivers/pci/controller/dwc/pcie-tegra194.c
+@@ -765,8 +765,6 @@ static void tegra_pcie_enable_msi_interr
+ 	struct tegra_pcie_dw *pcie = to_tegra_pcie(pci);
+ 	u32 val;
+ 
+-	dw_pcie_msi_init(pp);
+-
+ 	/* Enable MSI interrupt generation */
+ 	val = appl_readl(pcie, APPL_INTR_EN_L0_0);
+ 	val |= APPL_INTR_EN_L0_0_SYS_MSI_INTR_EN;
+--- a/drivers/pci/controller/dwc/pcie-uniphier.c
++++ b/drivers/pci/controller/dwc/pcie-uniphier.c
+@@ -315,7 +315,6 @@ static int uniphier_pcie_host_init(struc
+ 	uniphier_pcie_irq_enable(priv);
+ 
+ 	dw_pcie_setup_rc(pp);
+-	dw_pcie_msi_init(pp);
+ 
+ 	return 0;
+ }
diff --git a/target/linux/ipq807x/patches-5.10/100-clk-qcom-ipq8074-fix-PCI-E-clock-oops.patch b/target/linux/ipq807x/patches-5.10/100-clk-qcom-ipq8074-fix-PCI-E-clock-oops.patch
new file mode 100644
index 0000000..87428c0
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/100-clk-qcom-ipq8074-fix-PCI-E-clock-oops.patch
@@ -0,0 +1,54 @@
+From 8d111d707f71bc17c616b0bcca327ee0a3db50e8 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Mon, 2 Nov 2020 19:03:59 +0100
+Subject: [PATCH] clk: qcom: ipq8074: fix PCI-E clock oops
+
+Fix PCI-E clock related kernel oops that are causes by missing
+parent_names.
+
+Without the use of parent_names kernel will panic on
+clk_core_get_parent_by_index() due to a NULL pointer.
+
+Without this earlycon is needed to even catch the OOPS as it will reset
+the board before serial is initialized.
+
+Fixes: f0cfcf1ade20 ("clk: qcom: ipq8074: Add missing clocks for pcie")
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ drivers/clk/qcom/gcc-ipq8074.c | 11 +++++------
+ 1 file changed, 5 insertions(+), 6 deletions(-)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -4329,8 +4329,7 @@ static struct clk_rcg2 pcie0_rchng_clk_s
+ 	.parent_map = gcc_xo_gpll0_map,
+ 	.clkr.hw.init = &(struct clk_init_data){
+ 		.name = "pcie0_rchng_clk_src",
+-		.parent_hws = (const struct clk_hw *[]) {
+-				&gpll0.clkr.hw },
++		.parent_names = gcc_xo_gpll0,
+ 		.num_parents = 2,
+ 		.ops = &clk_rcg2_ops,
+ 	},
+@@ -4344,8 +4343,8 @@ static struct clk_branch gcc_pcie0_rchng
+ 		.enable_mask = BIT(1),
+ 		.hw.init = &(struct clk_init_data){
+ 			.name = "gcc_pcie0_rchng_clk",
+-			.parent_hws = (const struct clk_hw *[]){
+-				&pcie0_rchng_clk_src.clkr.hw,
++			.parent_names = (const char *[]){
++				"pcie0_rchng_clk_src",
+ 			},
+ 			.num_parents = 1,
+ 			.flags = CLK_SET_RATE_PARENT,
+@@ -4362,8 +4361,8 @@ static struct clk_branch gcc_pcie0_axi_s
+ 		.enable_mask = BIT(0),
+ 		.hw.init = &(struct clk_init_data){
+ 			.name = "gcc_pcie0_axi_s_bridge_clk",
+-			.parent_hws = (const struct clk_hw *[]){
+-				&pcie0_axi_clk_src.clkr.hw,
++			.parent_names = (const char *[]){
++				"pcie0_axi_clk_src"
+ 			},
+ 			.num_parents = 1,
+ 			.flags = CLK_SET_RATE_PARENT,
diff --git a/target/linux/ipq807x/patches-5.10/101-arm64-dts-ipq8074-add-crypto-nodes.patch b/target/linux/ipq807x/patches-5.10/101-arm64-dts-ipq8074-add-crypto-nodes.patch
new file mode 100644
index 0000000..2d872d1
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/101-arm64-dts-ipq8074-add-crypto-nodes.patch
@@ -0,0 +1,48 @@
+From 69581d91675df8c0d9b5f746de7c2f3d73344280 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Tue, 11 May 2021 15:10:37 +0200
+Subject: [PATCH] arm64: dts: ipq8074: add crypto nodes
+
+IPQ8074 uses Qualcom QCE crypto engine v5.1
+which is already supported.
+
+So simply add nodes for its DMA and QCE itself.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 24 ++++++++++++++++++++++++
+ 1 file changed, 24 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -197,6 +197,30 @@
+ 			status = "disabled";
+ 		};
+ 
++		cryptobam: dma@704000 {
++			compatible = "qcom,bam-v1.7.0";
++			reg = <0x00704000 0x20000>;
++			interrupts = <GIC_SPI 207 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_CRYPTO_AHB_CLK>;
++			clock-names = "bam_clk";
++			#dma-cells = <1>;
++			qcom,ee = <1>;
++			qcom,controlled-remotely = <1>;
++			status = "disabled";
++		};
++
++		crypto: crypto@73a000 {
++			compatible = "qcom,crypto-v5.1";
++			reg = <0x0073a000 0x6000>;
++			clocks = <&gcc GCC_CRYPTO_AHB_CLK>,
++				 <&gcc GCC_CRYPTO_AXI_CLK>,
++				 <&gcc GCC_CRYPTO_CLK>;
++			clock-names = "iface", "bus", "core";
++			dmas = <&cryptobam 2>, <&cryptobam 3>;
++			dma-names = "rx", "tx";
++			status = "disabled";
++		};
++
+ 		tlmm: pinctrl@1000000 {
+ 			compatible = "qcom,ipq8074-pinctrl";
+ 			reg = <0x01000000 0x300000>;
diff --git a/target/linux/ipq807x/patches-5.10/102-arm64-dts-ipq8074-add-PRNG-node.patch b/target/linux/ipq807x/patches-5.10/102-arm64-dts-ipq8074-add-PRNG-node.patch
new file mode 100644
index 0000000..1aafef5
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/102-arm64-dts-ipq8074-add-PRNG-node.patch
@@ -0,0 +1,30 @@
+From ff46c62852e862ac360aeb1054180c8e715fbeb4 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Tue, 11 May 2021 15:23:53 +0200
+Subject: [PATCH] arm64: dts: ipq8074: add PRNG node
+
+PRNG insinde of IPQ8074 is already supported,
+so simply add the node for it.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -197,6 +197,14 @@
+ 			status = "disabled";
+ 		};
+ 
++		prng: rng@e3000 {
++			compatible = "qcom,prng-ee";
++			reg = <0x000e3000 0x1000>;
++			clocks = <&gcc GCC_PRNG_AHB_CLK>;
++			clock-names = "core";
++			status = "disabled";
++		};
++
+ 		cryptobam: dma@704000 {
+ 			compatible = "qcom,bam-v1.7.0";
+ 			reg = <0x00704000 0x20000>;
diff --git a/target/linux/ipq807x/patches-5.10/103-remoteproc-qcom-Add-PRNG-proxy-clock.patch b/target/linux/ipq807x/patches-5.10/103-remoteproc-qcom-Add-PRNG-proxy-clock.patch
new file mode 100644
index 0000000..b8e842b
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/103-remoteproc-qcom-Add-PRNG-proxy-clock.patch
@@ -0,0 +1,155 @@
+From e0d3c4e232c2b29532f7b894485814782201fdd9 Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Date: Sat, 30 Jan 2021 10:50:05 +0530
+Subject: [PATCH 08/16] remoteproc: qcom: Add PRNG proxy clock
+
+PRNG clock is needed by the secure PIL, support for the same
+is added in subsequent patches.
+
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Signed-off-by: Sricharan R <sricharan@codeaurora.org>
+Signed-off-by: Nikhil Prakash V <nprakash@codeaurora.org>
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 65 +++++++++++++++++++++--------
+ 1 file changed, 47 insertions(+), 18 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -91,19 +91,6 @@ enum {
+ 	WCSS_QCS404,
+ };
+ 
+-struct wcss_data {
+-	const char *firmware_name;
+-	unsigned int crash_reason_smem;
+-	u32 version;
+-	bool aon_reset_required;
+-	bool wcss_q6_reset_required;
+-	const char *ssr_name;
+-	const char *sysmon_name;
+-	int ssctl_id;
+-	const struct rproc_ops *ops;
+-	bool requires_force_stop;
+-};
+-
+ struct q6v5_wcss {
+ 	struct device *dev;
+ 
+@@ -128,6 +115,7 @@ struct q6v5_wcss {
+ 	struct clk *qdsp6ss_xo_cbcr;
+ 	struct clk *qdsp6ss_core_gfmux;
+ 	struct clk *lcc_bcr_sleep;
++	struct clk *prng_clk;
+ 	struct regulator *cx_supply;
+ 	struct qcom_sysmon *sysmon;
+ 
+@@ -151,6 +139,21 @@ struct q6v5_wcss {
+ 	struct qcom_rproc_ssr ssr_subdev;
+ };
+ 
++struct wcss_data {
++	int (*init_clock)(struct q6v5_wcss *wcss);
++	int (*init_regulator)(struct q6v5_wcss *wcss);
++	const char *firmware_name;
++	unsigned int crash_reason_smem;
++	u32 version;
++	bool aon_reset_required;
++	bool wcss_q6_reset_required;
++	const char *ssr_name;
++	const char *sysmon_name;
++	int ssctl_id;
++	const struct rproc_ops *ops;
++	bool requires_force_stop;
++};
++
+ static int q6v5_wcss_reset(struct q6v5_wcss *wcss)
+ {
+ 	int ret;
+@@ -240,6 +243,12 @@ static int q6v5_wcss_start(struct rproc
+ 	struct q6v5_wcss *wcss = rproc->priv;
+ 	int ret;
+ 
++	ret = clk_prepare_enable(wcss->prng_clk);
++	if (ret) {
++		dev_err(wcss->dev, "prng clock enable failed\n");
++		return ret;
++	}
++
+ 	qcom_q6v5_prepare(&wcss->q6v5);
+ 
+ 	/* Release Q6 and WCSS reset */
+@@ -732,6 +741,7 @@ static int q6v5_wcss_stop(struct rproc *
+ 			return ret;
+ 	}
+ 
++	clk_disable_unprepare(wcss->prng_clk);
+ 	qcom_q6v5_unprepare(&wcss->q6v5);
+ 
+ 	return 0;
+@@ -896,7 +906,21 @@ static int q6v5_alloc_memory_region(stru
+ 	return 0;
+ }
+ 
+-static int q6v5_wcss_init_clock(struct q6v5_wcss *wcss)
++static int ipq8074_init_clock(struct q6v5_wcss *wcss)
++{
++	int ret;
++
++	wcss->prng_clk = devm_clk_get(wcss->dev, "prng");
++	if (IS_ERR(wcss->prng_clk)) {
++		ret = PTR_ERR(wcss->prng_clk);
++		if (ret != -EPROBE_DEFER)
++			dev_err(wcss->dev, "Failed to get prng clock\n");
++		return ret;
++	}
++	return 0;
++}
++
++static int qcs404_init_clock(struct q6v5_wcss *wcss)
+ {
+ 	int ret;
+ 
+@@ -986,7 +1010,7 @@ static int q6v5_wcss_init_clock(struct q
+ 	return 0;
+ }
+ 
+-static int q6v5_wcss_init_regulator(struct q6v5_wcss *wcss)
++static int qcs404_init_regulator(struct q6v5_wcss *wcss)
+ {
+ 	wcss->cx_supply = devm_regulator_get(wcss->dev, "cx");
+ 	if (IS_ERR(wcss->cx_supply))
+@@ -1030,12 +1054,14 @@ static int q6v5_wcss_probe(struct platfo
+ 	if (ret)
+ 		goto free_rproc;
+ 
+-	if (wcss->version == WCSS_QCS404) {
+-		ret = q6v5_wcss_init_clock(wcss);
++	if (desc->init_clock) {
++		ret = desc->init_clock(wcss);
+ 		if (ret)
+ 			goto free_rproc;
++	}
+ 
+-		ret = q6v5_wcss_init_regulator(wcss);
++	if (desc->init_regulator) {
++		ret = desc->init_regulator(wcss);
+ 		if (ret)
+ 			goto free_rproc;
+ 	}
+@@ -1082,6 +1108,7 @@ static int q6v5_wcss_remove(struct platf
+ }
+ 
+ static const struct wcss_data wcss_ipq8074_res_init = {
++	.init_clock = ipq8074_init_clock,
+ 	.firmware_name = "IPQ8074/q6_fw.mdt",
+ 	.crash_reason_smem = WCSS_CRASH_REASON,
+ 	.aon_reset_required = true,
+@@ -1091,6 +1118,8 @@ static const struct wcss_data wcss_ipq80
+ };
+ 
+ static const struct wcss_data wcss_qcs404_res_init = {
++	.init_clock = qcs404_init_clock,
++	.init_regulator = qcs404_init_regulator,
+ 	.crash_reason_smem = WCSS_CRASH_REASON,
+ 	.firmware_name = "wcnss.mdt",
+ 	.version = WCSS_QCS404,
diff --git a/target/linux/ipq807x/patches-5.10/104-remoteproc-qcom-Add-secure-PIL-support.patch b/target/linux/ipq807x/patches-5.10/104-remoteproc-qcom-Add-secure-PIL-support.patch
new file mode 100644
index 0000000..1931b01
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/104-remoteproc-qcom-Add-secure-PIL-support.patch
@@ -0,0 +1,143 @@
+From a6256ebbd66f3457e4a285b72b362d452bc6854f Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Date: Sat, 30 Jan 2021 10:50:06 +0530
+Subject: [PATCH 09/16] remoteproc: qcom: Add secure PIL support
+
+IPQ8074 uses secure PIL. Hence, adding the support for the same.
+
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Signed-off-by: Sricharan R <sricharan@codeaurora.org>
+Signed-off-by: Nikhil Prakash V <nprakash@codeaurora.org>
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 43 +++++++++++++++++++++++++++--
+ 1 file changed, 40 insertions(+), 3 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -18,6 +18,7 @@
+ #include <linux/regulator/consumer.h>
+ #include <linux/reset.h>
+ #include <linux/soc/qcom/mdt_loader.h>
++#include <linux/qcom_scm.h>
+ #include "qcom_common.h"
+ #include "qcom_pil_info.h"
+ #include "qcom_q6v5.h"
+@@ -86,6 +87,9 @@
+ #define TCSR_WCSS_CLK_ENABLE	0x14
+ 
+ #define MAX_HALT_REG		3
++
++#define WCNSS_PAS_ID		6
++
+ enum {
+ 	WCSS_IPQ8074,
+ 	WCSS_QCS404,
+@@ -134,6 +138,7 @@ struct q6v5_wcss {
+ 	unsigned int crash_reason_smem;
+ 	u32 version;
+ 	bool requires_force_stop;
++	bool need_mem_protection;
+ 
+ 	struct qcom_rproc_glink glink_subdev;
+ 	struct qcom_rproc_ssr ssr_subdev;
+@@ -152,6 +157,7 @@ struct wcss_data {
+ 	int ssctl_id;
+ 	const struct rproc_ops *ops;
+ 	bool requires_force_stop;
++	bool need_mem_protection;
+ };
+ 
+ static int q6v5_wcss_reset(struct q6v5_wcss *wcss)
+@@ -251,6 +257,15 @@ static int q6v5_wcss_start(struct rproc
+ 
+ 	qcom_q6v5_prepare(&wcss->q6v5);
+ 
++	if (wcss->need_mem_protection) {
++		ret = qcom_scm_pas_auth_and_reset(WCNSS_PAS_ID);
++		if (ret) {
++			dev_err(wcss->dev, "wcss_reset failed\n");
++			return ret;
++		}
++		goto wait_for_reset;
++	}
++
+ 	/* Release Q6 and WCSS reset */
+ 	ret = reset_control_deassert(wcss->wcss_reset);
+ 	if (ret) {
+@@ -285,6 +300,7 @@ static int q6v5_wcss_start(struct rproc
+ 	if (ret)
+ 		goto wcss_q6_reset;
+ 
++wait_for_reset:
+ 	ret = qcom_q6v5_wait_for_start(&wcss->q6v5, 5 * HZ);
+ 	if (ret == -ETIMEDOUT)
+ 		dev_err(wcss->dev, "start timed out\n");
+@@ -717,6 +733,15 @@ static int q6v5_wcss_stop(struct rproc *
+ 	struct q6v5_wcss *wcss = rproc->priv;
+ 	int ret;
+ 
++	if (wcss->need_mem_protection) {
++		ret = qcom_scm_pas_shutdown(WCNSS_PAS_ID);
++		if (ret) {
++			dev_err(wcss->dev, "not able to shutdown\n");
++			return ret;
++		}
++		goto pas_done;
++	}
++
+ 	/* WCSS powerdown */
+ 	if (wcss->requires_force_stop) {
+ 		ret = qcom_q6v5_request_stop(&wcss->q6v5, NULL);
+@@ -741,6 +766,7 @@ static int q6v5_wcss_stop(struct rproc *
+ 			return ret;
+ 	}
+ 
++pas_done:
+ 	clk_disable_unprepare(wcss->prng_clk);
+ 	qcom_q6v5_unprepare(&wcss->q6v5);
+ 
+@@ -764,9 +790,15 @@ static int q6v5_wcss_load(struct rproc *
+ 	struct q6v5_wcss *wcss = rproc->priv;
+ 	int ret;
+ 
+-	ret = qcom_mdt_load_no_init(wcss->dev, fw, rproc->firmware,
+-				    0, wcss->mem_region, wcss->mem_phys,
+-				    wcss->mem_size, &wcss->mem_reloc);
++	if (wcss->need_mem_protection)
++		ret = qcom_mdt_load(wcss->dev, fw, rproc->firmware,
++				    WCNSS_PAS_ID, wcss->mem_region,
++				    wcss->mem_phys, wcss->mem_size,
++				    &wcss->mem_reloc);
++	else
++		ret = qcom_mdt_load_no_init(wcss->dev, fw, rproc->firmware,
++					    0, wcss->mem_region, wcss->mem_phys,
++					    wcss->mem_size, &wcss->mem_reloc);
+ 	if (ret)
+ 		return ret;
+ 
+@@ -1032,6 +1064,9 @@ static int q6v5_wcss_probe(struct platfo
+ 	if (!desc)
+ 		return -EINVAL;
+ 
++	if (desc->need_mem_protection && !qcom_scm_is_available())
++		return -EPROBE_DEFER;
++
+ 	rproc = rproc_alloc(&pdev->dev, pdev->name, desc->ops,
+ 			    desc->firmware_name, sizeof(*wcss));
+ 	if (!rproc) {
+@@ -1045,6 +1080,7 @@ static int q6v5_wcss_probe(struct platfo
+ 
+ 	wcss->version = desc->version;
+ 	wcss->requires_force_stop = desc->requires_force_stop;
++	wcss->need_mem_protection = desc->need_mem_protection;
+ 
+ 	ret = q6v5_wcss_init_mmio(wcss, pdev);
+ 	if (ret)
+@@ -1115,6 +1151,7 @@ static const struct wcss_data wcss_ipq80
+ 	.wcss_q6_reset_required = true,
+ 	.ops = &q6v5_wcss_ipq8074_ops,
+ 	.requires_force_stop = true,
++	.need_mem_protection = true,
+ };
+ 
+ static const struct wcss_data wcss_qcs404_res_init = {
diff --git a/target/linux/ipq807x/patches-5.10/105-remoteproc-qcom-Add-support-for-split-q6-m3-wlan-fir.patch b/target/linux/ipq807x/patches-5.10/105-remoteproc-qcom-Add-support-for-split-q6-m3-wlan-fir.patch
new file mode 100644
index 0000000..fd82c57
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/105-remoteproc-qcom-Add-support-for-split-q6-m3-wlan-fir.patch
@@ -0,0 +1,104 @@
+From ea44aa0384fec6d6fcd5bf6bf52175628bad7319 Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Date: Sat, 30 Jan 2021 10:50:07 +0530
+Subject: [PATCH 10/16] remoteproc: qcom: Add support for split q6 + m3 wlan
+ firmware
+
+IPQ8074 supports split firmware for q6 and m3 as well.
+So add support for loading the m3 firmware before q6.
+Now the drivers works fine for both split and unified
+firmwares.
+
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Signed-off-by: Sricharan R <sricharan@codeaurora.org>
+Signed-off-by: Nikhil Prakash V <nprakash@codeaurora.org>
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 33 +++++++++++++++++++++++++----
+ 1 file changed, 29 insertions(+), 4 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -139,6 +139,7 @@ struct q6v5_wcss {
+ 	u32 version;
+ 	bool requires_force_stop;
+ 	bool need_mem_protection;
++	const char *m3_firmware_name;
+ 
+ 	struct qcom_rproc_glink glink_subdev;
+ 	struct qcom_rproc_ssr ssr_subdev;
+@@ -147,7 +148,8 @@ struct q6v5_wcss {
+ struct wcss_data {
+ 	int (*init_clock)(struct q6v5_wcss *wcss);
+ 	int (*init_regulator)(struct q6v5_wcss *wcss);
+-	const char *firmware_name;
++	const char *q6_firmware_name;
++	const char *m3_firmware_name;
+ 	unsigned int crash_reason_smem;
+ 	u32 version;
+ 	bool aon_reset_required;
+@@ -788,8 +790,29 @@ static void *q6v5_wcss_da_to_va(struct r
+ static int q6v5_wcss_load(struct rproc *rproc, const struct firmware *fw)
+ {
+ 	struct q6v5_wcss *wcss = rproc->priv;
++	const struct firmware *m3_fw;
+ 	int ret;
+ 
++	if (wcss->m3_firmware_name) {
++		ret = request_firmware(&m3_fw, wcss->m3_firmware_name,
++				       wcss->dev);
++		if (ret)
++			goto skip_m3;
++
++		ret = qcom_mdt_load_no_init(wcss->dev, m3_fw,
++					    wcss->m3_firmware_name, 0,
++					    wcss->mem_region, wcss->mem_phys,
++					    wcss->mem_size, &wcss->mem_reloc);
++
++		release_firmware(m3_fw);
++
++		if (ret) {
++			dev_err(wcss->dev, "can't load m3_fw.bXX\n");
++			return ret;
++		}
++	}
++
++skip_m3:
+ 	if (wcss->need_mem_protection)
+ 		ret = qcom_mdt_load(wcss->dev, fw, rproc->firmware,
+ 				    WCNSS_PAS_ID, wcss->mem_region,
+@@ -1068,7 +1091,7 @@ static int q6v5_wcss_probe(struct platfo
+ 		return -EPROBE_DEFER;
+ 
+ 	rproc = rproc_alloc(&pdev->dev, pdev->name, desc->ops,
+-			    desc->firmware_name, sizeof(*wcss));
++			    desc->q6_firmware_name, sizeof(*wcss));
+ 	if (!rproc) {
+ 		dev_err(&pdev->dev, "failed to allocate rproc\n");
+ 		return -ENOMEM;
+@@ -1081,6 +1104,7 @@ static int q6v5_wcss_probe(struct platfo
+ 	wcss->version = desc->version;
+ 	wcss->requires_force_stop = desc->requires_force_stop;
+ 	wcss->need_mem_protection = desc->need_mem_protection;
++	wcss->m3_firmware_name = desc->m3_firmware_name;
+ 
+ 	ret = q6v5_wcss_init_mmio(wcss, pdev);
+ 	if (ret)
+@@ -1145,7 +1169,8 @@ static int q6v5_wcss_remove(struct platf
+ 
+ static const struct wcss_data wcss_ipq8074_res_init = {
+ 	.init_clock = ipq8074_init_clock,
+-	.firmware_name = "IPQ8074/q6_fw.mdt",
++	.q6_firmware_name = "IPQ8074/q6_fw.mdt",
++	.m3_firmware_name = "IPQ8074/m3_fw.mdt",
+ 	.crash_reason_smem = WCSS_CRASH_REASON,
+ 	.aon_reset_required = true,
+ 	.wcss_q6_reset_required = true,
+@@ -1158,7 +1183,7 @@ static const struct wcss_data wcss_qcs40
+ 	.init_clock = qcs404_init_clock,
+ 	.init_regulator = qcs404_init_regulator,
+ 	.crash_reason_smem = WCSS_CRASH_REASON,
+-	.firmware_name = "wcnss.mdt",
++	.q6_firmware_name = "wcnss.mdt",
+ 	.version = WCSS_QCS404,
+ 	.aon_reset_required = false,
+ 	.wcss_q6_reset_required = false,
diff --git a/target/linux/ipq807x/patches-5.10/106-remoteproc-qcom-Add-ssr-subdevice-identifier.patch b/target/linux/ipq807x/patches-5.10/106-remoteproc-qcom-Add-ssr-subdevice-identifier.patch
new file mode 100644
index 0000000..9307a94
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/106-remoteproc-qcom-Add-ssr-subdevice-identifier.patch
@@ -0,0 +1,24 @@
+From dcfc2e3a3e346e0cad4c5b8707aaab96f4bbb59d Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Date: Sat, 30 Jan 2021 10:50:08 +0530
+Subject: [PATCH 11/16] remoteproc: qcom: Add ssr subdevice identifier
+
+Add name for ssr subdevice on IPQ8074 SoC.
+
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Signed-off-by: Sricharan R <sricharan@codeaurora.org>
+Signed-off-by: Nikhil Prakash V <nprakash@codeaurora.org>
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -1174,6 +1174,7 @@ static const struct wcss_data wcss_ipq80
+ 	.crash_reason_smem = WCSS_CRASH_REASON,
+ 	.aon_reset_required = true,
+ 	.wcss_q6_reset_required = true,
++	.ssr_name = "q6wcss",
+ 	.ops = &q6v5_wcss_ipq8074_ops,
+ 	.requires_force_stop = true,
+ 	.need_mem_protection = true,
diff --git a/target/linux/ipq807x/patches-5.10/107-remoteproc-qcom-Update-regmap-offsets-for-halt-regis.patch b/target/linux/ipq807x/patches-5.10/107-remoteproc-qcom-Update-regmap-offsets-for-halt-regis.patch
new file mode 100644
index 0000000..d844aa7
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/107-remoteproc-qcom-Update-regmap-offsets-for-halt-regis.patch
@@ -0,0 +1,80 @@
+From 543a7093420b500a197fc64361084613f248f07a Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Date: Sat, 30 Jan 2021 10:50:09 +0530
+Subject: [PATCH 12/16] remoteproc: qcom: Update regmap offsets for halt
+ register
+
+Fixed issue in reading halt-regs parameter from device-tree.
+
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Signed-off-by: Sricharan R <sricharan@codeaurora.org>
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 22 ++++++++++++++--------
+ 1 file changed, 14 insertions(+), 8 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -86,7 +86,7 @@
+ #define TCSR_WCSS_CLK_MASK	0x1F
+ #define TCSR_WCSS_CLK_ENABLE	0x14
+ 
+-#define MAX_HALT_REG		3
++#define MAX_HALT_REG		4
+ 
+ #define WCNSS_PAS_ID		6
+ 
+@@ -154,6 +154,7 @@ struct wcss_data {
+ 	u32 version;
+ 	bool aon_reset_required;
+ 	bool wcss_q6_reset_required;
++	bool bcr_reset_required;
+ 	const char *ssr_name;
+ 	const char *sysmon_name;
+ 	int ssctl_id;
+@@ -874,10 +875,13 @@ static int q6v5_wcss_init_reset(struct q
+ 		}
+ 	}
+ 
+-	wcss->wcss_q6_bcr_reset = devm_reset_control_get_exclusive(dev, "wcss_q6_bcr_reset");
+-	if (IS_ERR(wcss->wcss_q6_bcr_reset)) {
+-		dev_err(wcss->dev, "unable to acquire wcss_q6_bcr_reset\n");
+-		return PTR_ERR(wcss->wcss_q6_bcr_reset);
++	if (desc->bcr_reset_required) {
++		wcss->wcss_q6_bcr_reset = devm_reset_control_get_exclusive(dev,
++									   "wcss_q6_bcr_reset");
++		if (IS_ERR(wcss->wcss_q6_bcr_reset)) {
++			dev_err(wcss->dev, "unable to acquire wcss_q6_bcr_reset\n");
++			return PTR_ERR(wcss->wcss_q6_bcr_reset);
++		}
+ 	}
+ 
+ 	return 0;
+@@ -925,9 +929,9 @@ static int q6v5_wcss_init_mmio(struct q6
+ 		return -EINVAL;
+ 	}
+ 
+-	wcss->halt_q6 = halt_reg[0];
+-	wcss->halt_wcss = halt_reg[1];
+-	wcss->halt_nc = halt_reg[2];
++	wcss->halt_q6 = halt_reg[1];
++	wcss->halt_wcss = halt_reg[2];
++	wcss->halt_nc = halt_reg[3];
+ 
+ 	return 0;
+ }
+@@ -1174,6 +1178,7 @@ static const struct wcss_data wcss_ipq80
+ 	.crash_reason_smem = WCSS_CRASH_REASON,
+ 	.aon_reset_required = true,
+ 	.wcss_q6_reset_required = true,
++	.bcr_reset_required = false,
+ 	.ssr_name = "q6wcss",
+ 	.ops = &q6v5_wcss_ipq8074_ops,
+ 	.requires_force_stop = true,
+@@ -1188,6 +1193,7 @@ static const struct wcss_data wcss_qcs40
+ 	.version = WCSS_QCS404,
+ 	.aon_reset_required = false,
+ 	.wcss_q6_reset_required = false,
++	.bcr_reset_required = true,
+ 	.ssr_name = "mpss",
+ 	.sysmon_name = "wcnss",
+ 	.ssctl_id = 0x12,
diff --git a/target/linux/ipq807x/patches-5.10/108-dt-bindings-clock-qcom-Add-reset-for-WCSSAON.patch b/target/linux/ipq807x/patches-5.10/108-dt-bindings-clock-qcom-Add-reset-for-WCSSAON.patch
new file mode 100644
index 0000000..516273f
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/108-dt-bindings-clock-qcom-Add-reset-for-WCSSAON.patch
@@ -0,0 +1,25 @@
+From 12c7588316e1aceb3a4918896735e8bc3757815f Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Date: Sat, 30 Jan 2021 10:50:10 +0530
+Subject: [PATCH 13/16] dt-bindings: clock: qcom: Add reset for WCSSAON
+
+Add binding for WCSSAON reset required for Q6v5 reset on IPQ8074 SoC.
+
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Signed-off-by: Sricharan R <sricharan@codeaurora.org>
+Signed-off-by: Nikhil Prakash V <nprakash@codeaurora.org>
+Acked-by: Rob Herring <robh@kernel.org>
+Acked-by: Stephen Boyd <sboyd@kernel.org>
+---
+ include/dt-bindings/clock/qcom,gcc-ipq8074.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/include/dt-bindings/clock/qcom,gcc-ipq8074.h
++++ b/include/dt-bindings/clock/qcom,gcc-ipq8074.h
+@@ -366,5 +366,6 @@
+ #define GCC_PCIE1_AHB_ARES			129
+ #define GCC_PCIE1_AXI_MASTER_STICKY_ARES	130
+ #define GCC_PCIE0_AXI_SLAVE_STICKY_ARES		131
++#define GCC_WCSSAON_RESET			132
+ 
+ #endif
diff --git a/target/linux/ipq807x/patches-5.10/109-clk-qcom-Add-WCSSAON-reset.patch b/target/linux/ipq807x/patches-5.10/109-clk-qcom-Add-WCSSAON-reset.patch
new file mode 100644
index 0000000..f36b560
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/109-clk-qcom-Add-WCSSAON-reset.patch
@@ -0,0 +1,25 @@
+From 6de5e246382d6b15f297cadbf26bdd78ee7f9fea Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Date: Sat, 30 Jan 2021 10:50:11 +0530
+Subject: [PATCH 14/16] clk: qcom: Add WCSSAON reset
+
+Add WCSSAON reset required for Q6v5 on IPQ8074 SoC.
+
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Signed-off-by: Sricharan R <sricharan@codeaurora.org>
+Signed-off-by: Nikhil Prakash V <nprakash@codeaurora.org>
+Acked-by: Stephen Boyd <sboyd@kernel.org>
+---
+ drivers/clk/qcom/gcc-ipq8074.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -4744,6 +4744,7 @@ static const struct qcom_reset_map gcc_i
+ 	[GCC_PCIE1_AXI_SLAVE_ARES] = { 0x76040, 4 },
+ 	[GCC_PCIE1_AHB_ARES] = { 0x76040, 5 },
+ 	[GCC_PCIE1_AXI_MASTER_STICKY_ARES] = { 0x76040, 6 },
++	[GCC_WCSSAON_RESET] = { 0x59010, 0 },
+ };
+ 
+ static const struct of_device_id gcc_ipq8074_match_table[] = {
diff --git a/target/linux/ipq807x/patches-5.10/110-arm64-dts-Add-support-for-scm-on-IPQ8074-SoCs.patch b/target/linux/ipq807x/patches-5.10/110-arm64-dts-Add-support-for-scm-on-IPQ8074-SoCs.patch
new file mode 100644
index 0000000..6dbabf1
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/110-arm64-dts-Add-support-for-scm-on-IPQ8074-SoCs.patch
@@ -0,0 +1,28 @@
+From b177148d326cac30723f5fe9c939db2919aab33a Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Date: Sat, 30 Jan 2021 10:50:12 +0530
+Subject: [PATCH 15/16] arm64: dts: Add support for scm on IPQ8074 SoCs
+
+Enables scm support, clock is not needed for enabling scm interface.
+
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Signed-off-by: Sricharan R <sricharan@codeaurora.org>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -76,6 +76,12 @@
+ 		method = "smc";
+ 	};
+ 
++	firmware {
++		scm {
++			compatible = "qcom,scm-ipq8074", "qcom,scm";
++		};
++	};
++
+ 	soc: soc {
+ 		#address-cells = <0x1>;
+ 		#size-cells = <0x1>;
diff --git a/target/linux/ipq807x/patches-5.10/111-arm64-dts-qcom-Enable-Q6v5-WCSS-for-ipq8074-SoC.patch b/target/linux/ipq807x/patches-5.10/111-arm64-dts-qcom-Enable-Q6v5-WCSS-for-ipq8074-SoC.patch
new file mode 100644
index 0000000..6883334
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/111-arm64-dts-qcom-Enable-Q6v5-WCSS-for-ipq8074-SoC.patch
@@ -0,0 +1,158 @@
+From 9428cd325c99212b25407df8035284012d65acdb Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Date: Sat, 30 Jan 2021 10:50:13 +0530
+Subject: [PATCH 16/16] arm64: dts: qcom: Enable Q6v5 WCSS for ipq8074 SoC
+
+Enable remoteproc WCSS PIL driver with glink
+and ssr subdevices. Also configures shared memory
+and enables smp2p and mailboxes required for IPC.
+
+Signed-off-by: Gokul Sriram Palanisamy <gokulsri@codeaurora.org>
+Signed-off-by: Sricharan R <sricharan@codeaurora.org>
+Signed-off-by: Nikhil Prakash V <nprakash@codeaurora.org>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 121 ++++++++++++++++++++++++++
+ 1 file changed, 121 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -76,12 +76,66 @@
+ 		method = "smc";
+ 	};
+ 
++	reserved-memory {
++		#address-cells = <2>;
++		#size-cells = <2>;
++		ranges;
++
++		smem_region: memory@4ab00000 {
++			no-map;
++			reg = <0x0 0x4ab00000 0x0 0x00100000>;
++		};
++
++		q6_region: memory@4b000000 {
++			no-map;
++			reg = <0x0 0x4b000000 0x0 0x05f00000>;
++		};
++	};
++
+ 	firmware {
+ 		scm {
+ 			compatible = "qcom,scm-ipq8074", "qcom,scm";
+ 		};
+ 	};
+ 
++	tcsr_mutex: hwlock@193d000 {
++		compatible = "qcom,tcsr-mutex";
++		syscon = <&tcsr_mutex_regs 0 0x80>;
++		#hwlock-cells = <1>;
++	};
++
++	smem {
++		compatible = "qcom,smem";
++		memory-region = <&smem_region>;
++		hwlocks = <&tcsr_mutex 0>;
++	};
++
++	wcss: smp2p-wcss {
++		compatible = "qcom,smp2p";
++		qcom,smem = <435>, <428>;
++
++		interrupt-parent = <&intc>;
++		interrupts = <0 322 1>;
++
++		mboxes = <&apcs_glb 9>;
++
++		qcom,local-pid = <0>;
++		qcom,remote-pid = <1>;
++
++		wcss_smp2p_out: master-kernel {
++			qcom,entry-name = "master-kernel";
++			qcom,smp2p-feature-ssr-ack;
++			#qcom,smem-state-cells = <1>;
++		};
++
++		wcss_smp2p_in: slave-kernel {
++			qcom,entry-name = "slave-kernel";
++
++			interrupt-controller;
++			#interrupt-cells = <2>;
++		};
++	};
++
+ 	soc: soc {
+ 		#address-cells = <0x1>;
+ 		#size-cells = <0x1>;
+@@ -727,5 +781,72 @@
+ 				      "axi_m_sticky";
+ 			status = "disabled";
+ 		};
++
++		tcsr_q6: syscon@1945000 {
++			compatible = "syscon";
++			reg = <0x01945000 0xe000>;
++		};
++
++		tcsr_mutex_regs: syscon@193d000 {
++			compatible = "syscon";
++			reg = <0x01905000 0x8000>;
++		};
++
++		apcs_glb: mailbox@b111000 {
++			compatible = "qcom,ipq8074-apcs-apps-global";
++			reg = <0x0b111000 0x1000>;
++
++			#mbox-cells = <1>;
++		};
++
++		q6v5_wcss: q6v5_wcss@cd00000 {
++			compatible = "qcom,ipq8074-wcss-pil";
++			reg = <0x0cd00000 0x4040>,
++			      <0x004ab000 0x20>;
++			reg-names = "qdsp6",
++				    "rmb";
++			qca,auto-restart;
++			qca,extended-intc;
++			interrupts-extended = <&intc 0 325 1>,
++					      <&wcss_smp2p_in 0 0>,
++					      <&wcss_smp2p_in 1 0>,
++					      <&wcss_smp2p_in 2 0>,
++					      <&wcss_smp2p_in 3 0>;
++			interrupt-names = "wdog",
++					  "fatal",
++					  "ready",
++					  "handover",
++					  "stop-ack";
++
++			resets = <&gcc GCC_WCSSAON_RESET>,
++				 <&gcc GCC_WCSS_BCR>,
++				 <&gcc GCC_WCSS_Q6_BCR>;
++
++			reset-names = "wcss_aon_reset",
++				      "wcss_reset",
++				      "wcss_q6_reset";
++
++			clocks = <&gcc GCC_PRNG_AHB_CLK>;
++			clock-names = "prng";
++
++			qcom,halt-regs = <&tcsr_q6 0xa000 0xd000 0x0>;
++
++			qcom,smem-states = <&wcss_smp2p_out 0>,
++					   <&wcss_smp2p_out 1>;
++			qcom,smem-state-names = "shutdown",
++						"stop";
++
++			memory-region = <&q6_region>;
++
++			glink-edge {
++				interrupts = <GIC_SPI 321 IRQ_TYPE_EDGE_RISING>;
++				qcom,remote-pid = <1>;
++				mboxes = <&apcs_glb 8>;
++
++				rpm_requests {
++					qcom,glink-channels = "IPCRTR";
++				};
++			};
++		};
+ 	};
+ };
diff --git a/target/linux/ipq807x/patches-5.10/112-qcom-socinfo-Add-IPQ8074-SoC-family-ID-s.patch b/target/linux/ipq807x/patches-5.10/112-qcom-socinfo-Add-IPQ8074-SoC-family-ID-s.patch
new file mode 100644
index 0000000..5fa58db
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/112-qcom-socinfo-Add-IPQ8074-SoC-family-ID-s.patch
@@ -0,0 +1,35 @@
+From 5454294f432c0c095f3e2b54fd45491be779c545 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Tue, 11 May 2021 18:11:13 +0200
+Subject: [PATCH] soc: qcom: socinfo: Add IPQ8074 SoC family ID-s
+
+Add ID-s for the Qualcomm IPQ8074 SoC family.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ drivers/soc/qcom/socinfo.c | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+--- a/drivers/soc/qcom/socinfo.c
++++ b/drivers/soc/qcom/socinfo.c
+@@ -224,8 +224,20 @@ static const struct soc_id soc_id[] = {
+ 	{ 312, "APQ8096SG" },
+ 	{ 318, "SDM630" },
+ 	{ 321, "SDM845" },
++	{ 323, "IPQ8074" },
+ 	{ 341, "SDA845" },
++	{ 342, "IPQ8072" },
++	{ 343, "IPQ8076" },
++	{ 344, "IPQ8078" },
+ 	{ 356, "SM8250" },
++	{ 375, "IPQ8070" },
++	{ 376, "IPQ8071" },
++	{ 389, "IPQ8072A" },
++	{ 390, "IPQ8074A" },
++	{ 391, "IPQ8076A" },
++	{ 392, "IPQ8078A" },
++	{ 395, "IPQ8070A" },
++	{ 396, "IPQ8071A" },
+ 	{ 402, "IPQ6018" },
+ 	{ 425, "SC7180" },
+ };
diff --git a/target/linux/ipq807x/patches-5.10/113-net-mdio-ipq4019-add-clock-handling.patch b/target/linux/ipq807x/patches-5.10/113-net-mdio-ipq4019-add-clock-handling.patch
new file mode 100644
index 0000000..863bf2b
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/113-net-mdio-ipq4019-add-clock-handling.patch
@@ -0,0 +1,49 @@
+From d91c466ec19e5ced30631cec703164c79525b986 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robert.marko@sartura.hr>
+Date: Sun, 27 Dec 2020 18:55:56 +0100
+Subject: [PATCH] net: mdio-ipq4019: add clock handling
+
+Newer SoC-s like IPQ807x and IPQ60xx use the same MDIO controller,
+but have separate MDIO clocks that need to be handled.
+So lets add support for doing that.
+
+Signed-off-by: Robert Marko <robert.marko@sartura.hr>
+---
+ drivers/net/mdio/mdio-ipq4019.c | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+--- a/drivers/net/mdio/mdio-ipq4019.c
++++ b/drivers/net/mdio/mdio-ipq4019.c
+@@ -2,6 +2,7 @@
+ /* Copyright (c) 2015, The Linux Foundation. All rights reserved. */
+ /* Copyright (c) 2020 Sartura Ltd. */
+ 
++#include <linux/clk.h>
+ #include <linux/delay.h>
+ #include <linux/kernel.h>
+ #include <linux/module.h>
+@@ -33,6 +34,7 @@
+ 
+ struct ipq4019_mdio_data {
+ 	void __iomem	*membase;
++	struct clk	*clk;
+ };
+ 
+ static int ipq4019_mdio_wait_busy(struct mii_bus *bus)
+@@ -187,6 +189,16 @@ static int ipq4019_mdio_probe(struct pla
+ 	if (IS_ERR(priv->membase))
+ 		return PTR_ERR(priv->membase);
+ 
++	priv->clk = devm_clk_get_optional(&pdev->dev, "mdio_ahb");
++	if (IS_ERR(priv->clk)) {
++		dev_err(&pdev->dev, "Failed getting clock!\n");
++		return PTR_ERR(priv->clk);
++	}
++
++	ret = clk_prepare_enable(priv->clk);
++	if (ret)
++		return ret;
++
+ 	bus->name = "ipq4019_mdio";
+ 	bus->read = ipq4019_mdio_read;
+ 	bus->write = ipq4019_mdio_write;
diff --git a/target/linux/ipq807x/patches-5.10/114-arm64-dts-ipq8074-Add-MDIO-support.patch b/target/linux/ipq807x/patches-5.10/114-arm64-dts-ipq8074-Add-MDIO-support.patch
new file mode 100644
index 0000000..8f9176e
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/114-arm64-dts-ipq8074-Add-MDIO-support.patch
@@ -0,0 +1,34 @@
+From 67ba6e563928123fc65dab604592a60da2cce648 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Tue, 11 May 2021 18:24:35 +0200
+Subject: [PATCH] arm64: dts: ipq8074: Add MDIO support
+
+MDIO controller is the same one as in IPQ4019, so
+lets add the node to support it.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -257,6 +257,18 @@
+ 			status = "disabled";
+ 		};
+ 
++		mdio: mdio@90000 {
++			compatible = "qcom,ipq4019-mdio";
++			reg = <0x00090000 0x64>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			clocks = <&gcc GCC_MDIO_AHB_CLK>;
++			clock-names = "mdio_ahb";
++
++			status = "disabled";
++		};
++
+ 		prng: rng@e3000 {
+ 			compatible = "qcom,prng-ee";
+ 			reg = <0x000e3000 0x1000>;
diff --git a/target/linux/ipq807x/patches-5.10/115-phy-qcom-qmp-Add-IPQ8074-PCIe-Gen3-QMP-PHY-support.patch b/target/linux/ipq807x/patches-5.10/115-phy-qcom-qmp-Add-IPQ8074-PCIe-Gen3-QMP-PHY-support.patch
new file mode 100644
index 0000000..4b9a378
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/115-phy-qcom-qmp-Add-IPQ8074-PCIe-Gen3-QMP-PHY-support.patch
@@ -0,0 +1,369 @@
+From 57887b141d68224dcf4039a2f5215011f43dd9f4 Mon Sep 17 00:00:00 2001
+From: Sivaprakash Murugesan <sivaprak@codeaurora.org>
+Date: Wed, 29 Jul 2020 21:00:04 +0530
+Subject: [PATCH] phy: qcom-qmp: Add IPQ8074 PCIe Gen3 QMP PHY support
+
+IPQ8074 has two PCIe ports, One Gen2 and one Gen3 port.
+Since support for Gen2 PHY is already available, add support for
+PCIe Gen3 PHY.
+
+Co-developed-by: Selvam Sathappan Periakaruppan <speriaka@codeaurora.org>
+Signed-off-by: Selvam Sathappan Periakaruppan <speriaka@codeaurora.org>
+Signed-off-by: Sivaprakash Murugesan <sivaprak@codeaurora.org>
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ drivers/phy/qualcomm/phy-qcom-pcie3-qmp.h | 139 ++++++++++++++++++
+ drivers/phy/qualcomm/phy-qcom-qmp.c       | 171 +++++++++++++++++++++-
+ 2 files changed, 308 insertions(+), 2 deletions(-)
+ create mode 100644 drivers/phy/qualcomm/phy-qcom-pcie3-qmp.h
+
+--- /dev/null
++++ b/drivers/phy/qualcomm/phy-qcom-pcie3-qmp.h
+@@ -0,0 +1,139 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++
++/*
++ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
++ */
++
++#ifndef PHY_QCOM_PCIE_H
++#define PHY_QCOM_PCIE_H
++
++/* QMP V2 PCIE PHY - Found in IPQ8074 gen3 port - QSERDES PLL registers */
++#define QSERDES_PLL_BG_TIMER				0x00c
++#define QSERDES_PLL_SSC_PER1				0x01c
++#define QSERDES_PLL_SSC_PER2				0x020
++#define QSERDES_PLL_SSC_STEP_SIZE1_MODE0		0x024
++#define QSERDES_PLL_SSC_STEP_SIZE2_MODE0		0x028
++#define QSERDES_PLL_SSC_STEP_SIZE1_MODE1		0x02c
++#define QSERDES_PLL_SSC_STEP_SIZE2_MODE1		0x030
++#define QSERDES_PLL_BIAS_EN_CLKBUFLR_EN			0x03c
++#define QSERDES_PLL_CLK_ENABLE1				0x040
++#define QSERDES_PLL_SYS_CLK_CTRL			0x044
++#define QSERDES_PLL_SYSCLK_BUF_ENABLE			0x048
++#define QSERDES_PLL_PLL_IVCO				0x050
++#define QSERDES_PLL_LOCK_CMP1_MODE0			0x054
++#define QSERDES_PLL_LOCK_CMP2_MODE0			0x058
++#define QSERDES_PLL_LOCK_CMP1_MODE1			0x060
++#define QSERDES_PLL_LOCK_CMP2_MODE1			0x064
++#define QSERDES_PLL_BG_TRIM				0x074
++#define QSERDES_PLL_CLK_EP_DIV_MODE0			0x078
++#define QSERDES_PLL_CLK_EP_DIV_MODE1			0x07c
++#define QSERDES_PLL_CP_CTRL_MODE0			0x080
++#define QSERDES_PLL_CP_CTRL_MODE1			0x084
++#define QSERDES_PLL_PLL_RCTRL_MODE0			0x088
++#define QSERDES_PLL_PLL_RCTRL_MODE1			0x08C
++#define QSERDES_PLL_PLL_CCTRL_MODE0			0x090
++#define QSERDES_PLL_PLL_CCTRL_MODE1			0x094
++#define QSERDES_PLL_BIAS_EN_CTRL_BY_PSM			0x0a4
++#define QSERDES_PLL_SYSCLK_EN_SEL			0x0a8
++#define QSERDES_PLL_RESETSM_CNTRL			0x0b0
++#define QSERDES_PLL_LOCK_CMP_EN				0x0c4
++#define QSERDES_PLL_DEC_START_MODE0			0x0cc
++#define QSERDES_PLL_DEC_START_MODE1			0x0d0
++#define QSERDES_PLL_DIV_FRAC_START1_MODE0		0x0d8
++#define QSERDES_PLL_DIV_FRAC_START2_MODE0		0x0dc
++#define QSERDES_PLL_DIV_FRAC_START3_MODE0		0x0e0
++#define QSERDES_PLL_DIV_FRAC_START1_MODE1		0x0e4
++#define QSERDES_PLL_DIV_FRAC_START2_MODE1		0x0e8
++#define QSERDES_PLL_DIV_FRAC_START3_MODE1		0x0eC
++#define QSERDES_PLL_INTEGLOOP_GAIN0_MODE0		0x100
++#define QSERDES_PLL_INTEGLOOP_GAIN1_MODE0		0x104
++#define QSERDES_PLL_INTEGLOOP_GAIN0_MODE1		0x108
++#define QSERDES_PLL_INTEGLOOP_GAIN1_MODE1		0x10c
++#define QSERDES_PLL_VCO_TUNE_MAP			0x120
++#define QSERDES_PLL_VCO_TUNE1_MODE0			0x124
++#define QSERDES_PLL_VCO_TUNE2_MODE0			0x128
++#define QSERDES_PLL_VCO_TUNE1_MODE1			0x12c
++#define QSERDES_PLL_VCO_TUNE2_MODE1			0x130
++#define QSERDES_PLL_VCO_TUNE_TIMER1			0x13c
++#define QSERDES_PLL_VCO_TUNE_TIMER2			0x140
++#define QSERDES_PLL_CLK_SELECT				0x16c
++#define QSERDES_PLL_HSCLK_SEL				0x170
++#define QSERDES_PLL_CORECLK_DIV				0x17c
++#define QSERDES_PLL_CORE_CLK_EN				0x184
++#define QSERDES_PLL_CMN_CONFIG				0x18c
++#define QSERDES_PLL_SVS_MODE_CLK_SEL			0x194
++#define QSERDES_PLL_CORECLK_DIV_MODE1			0x1b4
++
++/* QMP V2 PCIE PHY - Found in IPQ8074 gen3 port - - QSERDES TX registers */
++#define QSERDES_TX0_RES_CODE_LANE_OFFSET_TX		0x03c
++#define QSERDES_TX0_HIGHZ_DRVR_EN			0x058
++#define QSERDES_TX0_LANE_MODE_1				0x084
++#define QSERDES_TX0_RCV_DETECT_LVL_2			0x09c
++
++/* QMP V2 PCIE PHY - Found in IPQ8074 gen3 port - QSERDES RX registers */
++#define QSERDES_RX0_UCDR_FO_GAIN			0x008
++#define QSERDES_RX0_UCDR_SO_GAIN			0x014
++#define QSERDES_RX0_UCDR_SO_SATURATION_AND_ENABLE	0x034
++#define QSERDES_RX0_UCDR_PI_CONTROLS			0x044
++#define QSERDES_RX0_RX_EQU_ADAPTOR_CNTRL2		0x0ec
++#define QSERDES_RX0_RX_EQU_ADAPTOR_CNTRL3		0x0f0
++#define QSERDES_RX0_RX_EQU_ADAPTOR_CNTRL4		0x0f4
++#define QSERDES_RX0_RX_IDAC_TSETTLE_LOW			0x0f8
++#define QSERDES_RX0_RX_IDAC_TSETTLE_HIGH		0x0fc
++#define QSERDES_RX0_RX_EQ_OFFSET_ADAPTOR_CNTRL1		0x110
++#define QSERDES_RX0_RX_OFFSET_ADAPTOR_CNTRL2		0x114
++#define QSERDES_RX0_SIGDET_ENABLES			0x118
++#define QSERDES_RX0_SIGDET_CNTRL			0x11c
++#define QSERDES_RX0_SIGDET_DEGLITCH_CNTRL		0x124
++#define QSERDES_RX0_RX_MODE_00_LOW			0x170
++#define QSERDES_RX0_RX_MODE_00_HIGH			0x174
++#define QSERDES_RX0_RX_MODE_00_HIGH2			0x178
++#define QSERDES_RX0_RX_MODE_00_HIGH3			0x17c
++#define QSERDES_RX0_RX_MODE_00_HIGH4			0x180
++#define QSERDES_RX0_RX_MODE_01_LOW			0x184
++#define QSERDES_RX0_RX_MODE_01_HIGH			0x188
++#define QSERDES_RX0_RX_MODE_01_HIGH2			0x18c
++#define QSERDES_RX0_RX_MODE_01_HIGH3			0x190
++#define QSERDES_RX0_RX_MODE_01_HIGH4			0x194
++#define QSERDES_RX0_RX_MODE_10_LOW			0x198
++#define QSERDES_RX0_RX_MODE_10_HIGH			0x19c
++#define QSERDES_RX0_RX_MODE_10_HIGH2			0x1a0
++#define QSERDES_RX0_RX_MODE_10_HIGH3			0x1a4
++#define QSERDES_RX0_RX_MODE_10_HIGH4			0x1a8
++#define QSERDES_RX0_DFE_EN_TIMER			0x1b4
++
++/* QMP V2 PCIE PHY - Found in IPQ8074 gen3 port - PCS registers */
++
++#define PCS_COM_FLL_CNTRL1				0x098
++#define PCS_COM_FLL_CNTRL2				0x09c
++#define PCS_COM_FLL_CNT_VAL_L				0x0a0
++#define PCS_COM_FLL_CNT_VAL_H_TOL			0x0a4
++#define PCS_COM_FLL_MAN_CODE				0x0a8
++#define PCS_COM_REFGEN_REQ_CONFIG1			0x0dc
++#define PCS_COM_G12S1_TXDEEMPH_M3P5DB			0x16c
++#define PCS_COM_RX_SIGDET_LVL				0x188
++#define PCS_COM_P2U3_WAKEUP_DLY_TIME_AUXCLK_L		0x1a4
++#define PCS_COM_P2U3_WAKEUP_DLY_TIME_AUXCLK_H		0x1a8
++#define PCS_COM_RX_DCC_CAL_CONFIG			0x1d8
++#define PCS_COM_EQ_CONFIG5				0x1ec
++
++/* QMP V2 PCIE PHY - Found in IPQ8074 gen3 port - PCS Misc registers */
++
++#define PCS_PCIE_POWER_STATE_CONFIG2			0x40c
++#define PCS_PCIE_POWER_STATE_CONFIG4			0x414
++#define PCS_PCIE_ENDPOINT_REFCLK_DRIVE			0x41c
++#define PCS_PCIE_L1P1_WAKEUP_DLY_TIME_AUXCLK_L		0x440
++#define PCS_PCIE_L1P1_WAKEUP_DLY_TIME_AUXCLK_H		0x444
++#define PCS_PCIE_L1P2_WAKEUP_DLY_TIME_AUXCLK_L		0x448
++#define PCS_PCIE_L1P2_WAKEUP_DLY_TIME_AUXCLK_H		0x44c
++#define PCS_PCIE_OSC_DTCT_CONFIG2			0x45c
++#define PCS_PCIE_OSC_DTCT_MODE2_CONFIG2			0x478
++#define PCS_PCIE_OSC_DTCT_MODE2_CONFIG4			0x480
++#define PCS_PCIE_OSC_DTCT_MODE2_CONFIG5			0x484
++#define PCS_PCIE_OSC_DTCT_ACTIONS			0x490
++#define PCS_PCIE_EQ_CONFIG1				0x4a0
++#define PCS_PCIE_EQ_CONFIG2				0x4a4
++#define PCS_PCIE_PRESET_P10_PRE				0x4bc
++#define PCS_PCIE_PRESET_P10_POST			0x4e0
++
++#endif
+--- a/drivers/phy/qualcomm/phy-qcom-qmp.c
++++ b/drivers/phy/qualcomm/phy-qcom-qmp.c
+@@ -23,6 +23,7 @@
+ #include <dt-bindings/phy/phy.h>
+ 
+ #include "phy-qcom-qmp.h"
++#include "phy-qcom-pcie3-qmp.h"
+ 
+ /* QPHY_SW_RESET bit */
+ #define SW_RESET				BIT(0)
+@@ -676,6 +677,132 @@ static const struct qmp_phy_init_tbl ipq
+ 	QMP_PHY_INIT_CFG_L(QPHY_START_CTRL, 0x3),
+ };
+ 
++static const struct qmp_phy_init_tbl ipq8074_pcie_gen3_serdes_tbl[] = {
++	QMP_PHY_INIT_CFG(QSERDES_PLL_BIAS_EN_CLKBUFLR_EN, 0x18),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_BIAS_EN_CTRL_BY_PSM, 0x01),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CLK_SELECT, 0x31),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_PLL_IVCO, 0x0f),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_BG_TRIM, 0x0f),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CMN_CONFIG, 0x06),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_LOCK_CMP_EN, 0x42),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_RESETSM_CNTRL, 0x20),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_SVS_MODE_CLK_SEL, 0x01),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_VCO_TUNE_MAP, 0x04),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_SVS_MODE_CLK_SEL, 0x05),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_VCO_TUNE_TIMER1, 0xff),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_VCO_TUNE_TIMER2, 0x3f),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CORE_CLK_EN, 0x30),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_HSCLK_SEL, 0x21),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_DEC_START_MODE0, 0x82),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_DIV_FRAC_START3_MODE0, 0x03),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_DIV_FRAC_START2_MODE0, 0x355),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_DIV_FRAC_START1_MODE0, 0x35555),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_LOCK_CMP2_MODE0, 0x1a),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_LOCK_CMP1_MODE0, 0x1a0a),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CP_CTRL_MODE0, 0xb),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_PLL_RCTRL_MODE0, 0x16),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_PLL_CCTRL_MODE0, 0x28),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_INTEGLOOP_GAIN1_MODE0, 0x0),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_INTEGLOOP_GAIN0_MODE0, 0x40),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_VCO_TUNE2_MODE0, 0x02),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_VCO_TUNE1_MODE0, 0x24),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_SVS_MODE_CLK_SEL, 0x05),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CORE_CLK_EN, 0x20),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CORECLK_DIV, 0xa),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CLK_SELECT, 0x32),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_SYS_CLK_CTRL, 0x02),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_SYSCLK_BUF_ENABLE, 0x07),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_SYSCLK_EN_SEL, 0x08),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_BG_TIMER, 0xa),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_HSCLK_SEL, 0x1),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_DEC_START_MODE1, 0x68),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_DIV_FRAC_START3_MODE1, 0x2),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_DIV_FRAC_START2_MODE1, 0x2aa),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_DIV_FRAC_START1_MODE1, 0x2aaab),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CLK_ENABLE1, 0x90),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_LOCK_CMP2_MODE1, 0x34),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_LOCK_CMP1_MODE1, 0x3414),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CP_CTRL_MODE1, 0x0b),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_PLL_RCTRL_MODE1, 0x16),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_PLL_CCTRL_MODE1, 0x28),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_INTEGLOOP_GAIN1_MODE1, 0x0),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_INTEGLOOP_GAIN0_MODE1, 0x40),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_VCO_TUNE2_MODE1, 0x03),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_VCO_TUNE1_MODE1, 0xb4),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_SVS_MODE_CLK_SEL, 0x05),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CORE_CLK_EN, 0x0),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CORECLK_DIV_MODE1, 0x08),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CLK_EP_DIV_MODE0, 0x19),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CLK_EP_DIV_MODE1, 0x28),
++	QMP_PHY_INIT_CFG(QSERDES_PLL_CLK_ENABLE1, 0x90),
++};
++
++static const struct qmp_phy_init_tbl ipq8074_pcie_gen3_tx_tbl[] = {
++	QMP_PHY_INIT_CFG(QSERDES_TX0_RES_CODE_LANE_OFFSET_TX, 0x02),
++	QMP_PHY_INIT_CFG(QSERDES_TX0_RCV_DETECT_LVL_2, 0x12),
++	QMP_PHY_INIT_CFG(QSERDES_TX0_HIGHZ_DRVR_EN, 0x10),
++	QMP_PHY_INIT_CFG(QSERDES_TX0_LANE_MODE_1, 0x06),
++};
++
++static const struct qmp_phy_init_tbl ipq8074_pcie_gen3_rx_tbl[] = {
++	QMP_PHY_INIT_CFG(QSERDES_RX0_SIGDET_CNTRL, 0x03),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_SIGDET_ENABLES, 0x1c),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_SIGDET_DEGLITCH_CNTRL, 0x14),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_EQU_ADAPTOR_CNTRL2, 0xe),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_EQU_ADAPTOR_CNTRL3, 0x4),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_EQU_ADAPTOR_CNTRL4, 0x1b),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_DFE_EN_TIMER, 0x04),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_UCDR_SO_SATURATION_AND_ENABLE, 0x7f),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_UCDR_PI_CONTROLS, 0x70),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_EQ_OFFSET_ADAPTOR_CNTRL1, 0x73),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_OFFSET_ADAPTOR_CNTRL2, 0x80),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_10_LOW, 0x00),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_10_HIGH, 0x02),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_10_HIGH2, 0xc8),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_10_HIGH3, 0x09),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_10_HIGH4, 0xb1),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_01_LOW, 0x01),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_01_HIGH, 0x02),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_01_HIGH2, 0xc8),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_01_HIGH3, 0x09),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_01_HIGH4, 0xb1),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_00_LOW, 0xf0),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_00_HIGH, 0x2),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_00_HIGH2, 0x2f),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_00_HIGH3, 0xd3),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_MODE_00_HIGH4, 0x40),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_IDAC_TSETTLE_HIGH, 0x00),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_RX_IDAC_TSETTLE_LOW, 0xc0),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_UCDR_FO_GAIN, 0x0c),
++	QMP_PHY_INIT_CFG(QSERDES_RX0_UCDR_SO_GAIN, 0x02),
++};
++
++static const struct qmp_phy_init_tbl ipq8074_pcie_gen3_pcs_tbl[] = {
++	QMP_PHY_INIT_CFG(PCS_COM_FLL_CNTRL2, 0x83),
++	QMP_PHY_INIT_CFG(PCS_COM_FLL_CNT_VAL_L, 0x9),
++	QMP_PHY_INIT_CFG(PCS_COM_FLL_CNT_VAL_H_TOL, 0x42),
++	QMP_PHY_INIT_CFG(PCS_COM_FLL_MAN_CODE, 0x40),
++	QMP_PHY_INIT_CFG(PCS_COM_FLL_CNTRL1, 0x01),
++	QMP_PHY_INIT_CFG(PCS_COM_P2U3_WAKEUP_DLY_TIME_AUXCLK_H, 0x0),
++	QMP_PHY_INIT_CFG(PCS_COM_P2U3_WAKEUP_DLY_TIME_AUXCLK_L, 0x1),
++	QMP_PHY_INIT_CFG(PCS_PCIE_OSC_DTCT_ACTIONS, 0x0),
++	QMP_PHY_INIT_CFG(PCS_PCIE_L1P1_WAKEUP_DLY_TIME_AUXCLK_H, 0x00),
++	QMP_PHY_INIT_CFG(PCS_PCIE_L1P1_WAKEUP_DLY_TIME_AUXCLK_L, 0x01),
++	QMP_PHY_INIT_CFG(PCS_PCIE_L1P2_WAKEUP_DLY_TIME_AUXCLK_H, 0x00),
++	QMP_PHY_INIT_CFG(PCS_PCIE_L1P2_WAKEUP_DLY_TIME_AUXCLK_L, 0x01),
++	QMP_PHY_INIT_CFG(PCS_PCIE_EQ_CONFIG1, 0x11),
++	QMP_PHY_INIT_CFG(PCS_PCIE_EQ_CONFIG2, 0xb),
++	QMP_PHY_INIT_CFG(PCS_PCIE_POWER_STATE_CONFIG4, 0x07),
++	QMP_PHY_INIT_CFG(PCS_PCIE_OSC_DTCT_CONFIG2, 0x52),
++	QMP_PHY_INIT_CFG(PCS_PCIE_OSC_DTCT_MODE2_CONFIG2, 0x50),
++	QMP_PHY_INIT_CFG(PCS_PCIE_OSC_DTCT_MODE2_CONFIG4, 0x1a),
++	QMP_PHY_INIT_CFG(PCS_PCIE_OSC_DTCT_MODE2_CONFIG5, 0x6),
++	QMP_PHY_INIT_CFG(PCS_COM_G12S1_TXDEEMPH_M3P5DB, 0x10),
++	QMP_PHY_INIT_CFG(PCS_PCIE_ENDPOINT_REFCLK_DRIVE, 0xc1),
++	QMP_PHY_INIT_CFG(PCS_COM_RX_DCC_CAL_CONFIG, 0x01),
++	QMP_PHY_INIT_CFG(PCS_COM_RX_SIGDET_LVL, 0xaa),
++	QMP_PHY_INIT_CFG(PCS_COM_REFGEN_REQ_CONFIG1, 0x0d),
++};
+ static const struct qmp_phy_init_tbl sdm845_qmp_pcie_serdes_tbl[] = {
+ 	QMP_PHY_INIT_CFG(QSERDES_V3_COM_BIAS_EN_CLKBUFLR_EN, 0x14),
+ 	QMP_PHY_INIT_CFG(QSERDES_V3_COM_CLK_SELECT, 0x30),
+@@ -2187,6 +2314,36 @@ static const struct qmp_phy_cfg ipq8074_
+ 	.pwrdn_delay_max	= 1005,		/* us */
+ };
+ 
++static const struct qmp_phy_cfg ipq8074_pciephy_gen3_cfg = {
++	.type			= PHY_TYPE_PCIE,
++	.nlanes			= 1,
++
++	.serdes_tbl		= ipq8074_pcie_gen3_serdes_tbl,
++	.serdes_tbl_num		= ARRAY_SIZE(ipq8074_pcie_gen3_serdes_tbl),
++	.tx_tbl			= ipq8074_pcie_gen3_tx_tbl,
++	.tx_tbl_num		= ARRAY_SIZE(ipq8074_pcie_gen3_tx_tbl),
++	.rx_tbl			= ipq8074_pcie_gen3_rx_tbl,
++	.rx_tbl_num		= ARRAY_SIZE(ipq8074_pcie_gen3_rx_tbl),
++	.pcs_tbl		= ipq8074_pcie_gen3_pcs_tbl,
++	.pcs_tbl_num		= ARRAY_SIZE(ipq8074_pcie_gen3_pcs_tbl),
++	.clk_list		= ipq8074_pciephy_clk_l,
++	.num_clks		= ARRAY_SIZE(ipq8074_pciephy_clk_l),
++	.reset_list		= ipq8074_pciephy_reset_l,
++	.num_resets		= ARRAY_SIZE(ipq8074_pciephy_reset_l),
++	.vreg_list		= NULL,
++	.num_vregs		= 0,
++	.regs			= qmp_v4_usb3phy_regs_layout,
++
++	.start_ctrl		= SERDES_START | PCS_START,
++	.pwrdn_ctrl		= SW_PWRDN | REFCLK_DRV_DSBL,
++
++	.has_phy_com_ctrl	= false,
++	.has_lane_rst		= false,
++	.has_pwrdn_delay	= true,
++	.pwrdn_delay_min	= 995,		/* us */
++	.pwrdn_delay_max	= 1005,		/* us */
++};
++
+ static const struct qmp_phy_cfg sdm845_qmp_pciephy_cfg = {
+ 	.type = PHY_TYPE_PCIE,
+ 	.nlanes = 1,
+@@ -3476,8 +3633,15 @@ static int phy_pipe_clk_register(struct
+ 
+ 	init.ops = &clk_fixed_rate_ops;
+ 
+-	/* controllers using QMP phys use 125MHz pipe clock interface */
+-	fixed->fixed_rate = 125000000;
++	/*
++	 * controllers using QMP phys use 125MHz pipe clock interface unless
++	 * other frequency is specified in dts
++	 */
++	ret = of_property_read_u32(np, "clock-output-rate",
++				   (u32 *)&fixed->fixed_rate);
++	if (ret)
++		fixed->fixed_rate = 125000000;
++
+ 	fixed->hw.init = &init;
+ 
+ 	ret = devm_clk_hw_register(qmp->dev, &fixed->hw);
+@@ -3859,6 +4023,9 @@ static const struct of_device_id qcom_qm
+ 		.compatible = "qcom,ipq8074-qmp-pcie-phy",
+ 		.data = &ipq8074_pciephy_cfg,
+ 	}, {
++		.compatible = "qcom,ipq8074-qmp-pcie-gen3-phy",
++		.data = &ipq8074_pciephy_gen3_cfg,
++	}, {
+ 		.compatible = "qcom,sc7180-qmp-usb3-phy",
+ 		.data = &sc7180_usb3phy_cfg,
+ 	}, {
diff --git a/target/linux/ipq807x/patches-5.10/116-PCI-dwc-tegra-move-GEN3_RELATED-DBI-register-to-comm.patch b/target/linux/ipq807x/patches-5.10/116-PCI-dwc-tegra-move-GEN3_RELATED-DBI-register-to-comm.patch
new file mode 100644
index 0000000..fe76db6
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/116-PCI-dwc-tegra-move-GEN3_RELATED-DBI-register-to-comm.patch
@@ -0,0 +1,44 @@
+From 35df745d335bd21094f522dc9dff7eaae92114d9 Mon Sep 17 00:00:00 2001
+From: Baruch Siach <baruch@tkos.co.il>
+Date: Wed, 5 May 2021 12:18:29 +0300
+Subject: [PATCH] PCI: dwc: tegra: move GEN3_RELATED DBI register to common
+ header
+
+These are common dwc macros that will be used for other platforms.
+
+Signed-off-by: Baruch Siach <baruch@tkos.co.il>
+---
+ drivers/pci/controller/dwc/pcie-designware.h | 6 ++++++
+ drivers/pci/controller/dwc/pcie-tegra194.c   | 6 ------
+ 2 files changed, 6 insertions(+), 6 deletions(-)
+
+--- a/drivers/pci/controller/dwc/pcie-designware.h
++++ b/drivers/pci/controller/dwc/pcie-designware.h
+@@ -74,6 +74,12 @@
+ #define PCIE_MSI_INTR0_MASK		0x82C
+ #define PCIE_MSI_INTR0_STATUS		0x830
+ 
++#define GEN3_RELATED_OFF			0x890
++#define GEN3_RELATED_OFF_GEN3_ZRXDC_NONCOMPL	BIT(0)
++#define GEN3_RELATED_OFF_GEN3_EQ_DISABLE	BIT(16)
++#define GEN3_RELATED_OFF_RATE_SHADOW_SEL_SHIFT	24
++#define GEN3_RELATED_OFF_RATE_SHADOW_SEL_MASK	GENMASK(25, 24)
++
+ #define PCIE_PORT_MULTI_LANE_CTRL	0x8C0
+ #define PORT_MLTI_UPCFG_SUPPORT		BIT(7)
+ 
+--- a/drivers/pci/controller/dwc/pcie-tegra194.c
++++ b/drivers/pci/controller/dwc/pcie-tegra194.c
+@@ -193,12 +193,6 @@
+ #define GEN3_EQ_CONTROL_OFF_PSET_REQ_VEC_MASK	GENMASK(23, 8)
+ #define GEN3_EQ_CONTROL_OFF_FB_MODE_MASK	GENMASK(3, 0)
+ 
+-#define GEN3_RELATED_OFF			0x890
+-#define GEN3_RELATED_OFF_GEN3_ZRXDC_NONCOMPL	BIT(0)
+-#define GEN3_RELATED_OFF_GEN3_EQ_DISABLE	BIT(16)
+-#define GEN3_RELATED_OFF_RATE_SHADOW_SEL_SHIFT	24
+-#define GEN3_RELATED_OFF_RATE_SHADOW_SEL_MASK	GENMASK(25, 24)
+-
+ #define PORT_LOGIC_AMBA_ERROR_RESPONSE_DEFAULT	0x8D0
+ #define AMBA_ERROR_RESPONSE_CRS_SHIFT		3
+ #define AMBA_ERROR_RESPONSE_CRS_MASK		GENMASK(1, 0)
diff --git a/target/linux/ipq807x/patches-5.10/117-PCI-qcom-add-support-for-IPQ60xx-PCIe-controller.patch b/target/linux/ipq807x/patches-5.10/117-PCI-qcom-add-support-for-IPQ60xx-PCIe-controller.patch
new file mode 100644
index 0000000..382ca98
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/117-PCI-qcom-add-support-for-IPQ60xx-PCIe-controller.patch
@@ -0,0 +1,230 @@
+From 809a720946f720dca2009bac29294992375a31b9 Mon Sep 17 00:00:00 2001
+From: Selvam Sathappan Periakaruppan <speriaka@codeaurora.org>
+Date: Tue, 11 May 2021 21:53:08 +0200
+Subject: [PATCH] PCI: qcom: add support for IPQ60xx PCIe controller
+
+IPQ60xx series of SoCs have one port of PCIe gen 3. Add support for that
+platform.
+
+The code is based on downstream Codeaurora kernel v5.4. Split out the
+DBI registers access part from .init into .post_init. DBI registers are
+only accessible after phy_power_on().
+
+Signed-off-by: Selvam Sathappan Periakaruppan <speriaka@codeaurora.org>
+Signed-off-by: Baruch Siach <baruch@tkos.co.il>
+---
+ drivers/pci/controller/dwc/pcie-designware.h |   1 +
+ drivers/pci/controller/dwc/pcie-qcom.c       | 150 +++++++++++++++++++
+ 2 files changed, 151 insertions(+)
+
+--- a/drivers/pci/controller/dwc/pcie-designware.h
++++ b/drivers/pci/controller/dwc/pcie-designware.h
+@@ -76,6 +76,7 @@
+ 
+ #define GEN3_RELATED_OFF			0x890
+ #define GEN3_RELATED_OFF_GEN3_ZRXDC_NONCOMPL	BIT(0)
++#define GEN3_RELATED_OFF_RXEQ_RGRDLESS_RXTS	BIT(13)
+ #define GEN3_RELATED_OFF_GEN3_EQ_DISABLE	BIT(16)
+ #define GEN3_RELATED_OFF_RATE_SHADOW_SEL_SHIFT	24
+ #define GEN3_RELATED_OFF_RATE_SHADOW_SEL_MASK	GENMASK(25, 24)
+--- a/drivers/pci/controller/dwc/pcie-qcom.c
++++ b/drivers/pci/controller/dwc/pcie-qcom.c
+@@ -51,6 +51,10 @@
+ #define PCIE20_PARF_DBI_BASE_ADDR		0x168
+ #define PCIE20_PARF_SLV_ADDR_SPACE_SIZE		0x16C
+ #define PCIE20_PARF_MHI_CLOCK_RESET_CTRL	0x174
++#define AHB_CLK_EN				BIT(0)
++#define MSTR_AXI_CLK_EN				BIT(1)
++#define BYPASS					BIT(4)
++
+ #define PCIE20_PARF_AXI_MSTR_WR_ADDR_HALT	0x178
+ #define PCIE20_PARF_AXI_MSTR_WR_ADDR_HALT_V2	0x1A8
+ #define PCIE20_PARF_LTSSM			0x1B0
+@@ -92,6 +96,12 @@
+ #define SLV_ADDR_SPACE_SZ			0x10000000
+ 
+ #define PCIE20_LNK_CONTROL2_LINK_STATUS2	0xa0
++#define PCIE_CAP_CURR_DEEMPHASIS		BIT(16)
++#define SPEED_GEN1				0x1
++#define SPEED_GEN2				0x2
++#define SPEED_GEN3				0x3
++#define AXI_CLK_RATE				200000000
++#define RCHNG_CLK_RATE				100000000
+ 
+ #define DEVICE_TYPE_RC				0x4
+ 
+@@ -161,6 +171,11 @@ struct qcom_pcie_resources_2_7_0 {
+ 	struct clk *pipe_clk;
+ };
+ 
++struct qcom_pcie_resources_2_9_0 {
++	struct clk_bulk_data clks[5];
++	struct reset_control *rst;
++};
++
+ union qcom_pcie_resources {
+ 	struct qcom_pcie_resources_1_0_0 v1_0_0;
+ 	struct qcom_pcie_resources_2_1_0 v2_1_0;
+@@ -168,6 +183,7 @@ union qcom_pcie_resources {
+ 	struct qcom_pcie_resources_2_3_3 v2_3_3;
+ 	struct qcom_pcie_resources_2_4_0 v2_4_0;
+ 	struct qcom_pcie_resources_2_7_0 v2_7_0;
++	struct qcom_pcie_resources_2_9_0 v2_9_0;
+ };
+ 
+ struct qcom_pcie;
+@@ -1252,6 +1268,130 @@ static void qcom_pcie_post_deinit_2_7_0(
+ 	clk_disable_unprepare(res->pipe_clk);
+ }
+ 
++static int qcom_pcie_get_resources_2_9_0(struct qcom_pcie *pcie)
++{
++	struct qcom_pcie_resources_2_9_0 *res = &pcie->res.v2_9_0;
++	struct dw_pcie *pci = pcie->pci;
++	struct device *dev = pci->dev;
++	int ret;
++
++	res->clks[0].id = "iface";
++	res->clks[1].id = "axi_m";
++	res->clks[2].id = "axi_s";
++	res->clks[3].id = "axi_bridge";
++	res->clks[4].id = "rchng";
++
++	ret = devm_clk_bulk_get(dev, ARRAY_SIZE(res->clks), res->clks);
++	if (ret < 0)
++		return ret;
++
++	res->rst = devm_reset_control_array_get_exclusive(dev);
++	if (IS_ERR(res->rst))
++		return PTR_ERR(res->rst);
++
++	return 0;
++}
++
++static void qcom_pcie_deinit_2_9_0(struct qcom_pcie *pcie)
++{
++	struct qcom_pcie_resources_2_9_0 *res = &pcie->res.v2_9_0;
++
++	clk_bulk_disable_unprepare(ARRAY_SIZE(res->clks), res->clks);
++}
++
++static int qcom_pcie_init_2_9_0(struct qcom_pcie *pcie)
++{
++	struct qcom_pcie_resources_2_9_0 *res = &pcie->res.v2_9_0;
++	struct device *dev = pcie->pci->dev;
++	int ret;
++
++	ret = reset_control_assert(res->rst);
++	if (ret) {
++		dev_err(dev, "reset assert failed (%d)\n", ret);
++		return ret;
++	}
++
++	usleep_range(2000, 2500);
++
++	ret = reset_control_deassert(res->rst);
++	if (ret) {
++		dev_err(dev, "reset deassert failed (%d)\n", ret);
++		return ret;
++	}
++
++	/*
++	 * Don't have a way to see if the reset has completed.
++	 * Wait for some time.
++	 */
++	usleep_range(2000, 2500);
++
++	ret = clk_bulk_prepare_enable(ARRAY_SIZE(res->clks), res->clks);
++	if (ret)
++		goto err_reset;
++
++	return 0;
++
++	/*
++	 * Not checking for failure, will anyway return
++	 * the original failure in 'ret'.
++	 */
++err_reset:
++	reset_control_assert(res->rst);
++
++	return ret;
++}
++
++static int qcom_pcie_post_init_2_9_0(struct qcom_pcie *pcie)
++{
++	struct dw_pcie *pci = pcie->pci;
++	u16 offset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);
++	u32 val;
++	int i;
++
++	writel(SLV_ADDR_SPACE_SZ,
++		pcie->parf + PCIE20_v3_PARF_SLV_ADDR_SPACE_SIZE);
++
++	val = readl(pcie->parf + PCIE20_PARF_PHY_CTRL);
++	val &= ~BIT(0);
++	writel(val, pcie->parf + PCIE20_PARF_PHY_CTRL);
++
++	writel(0, pcie->parf + PCIE20_PARF_DBI_BASE_ADDR);
++
++	writel(DEVICE_TYPE_RC, pcie->parf + PCIE20_PARF_DEVICE_TYPE);
++	writel(BYPASS | MSTR_AXI_CLK_EN | AHB_CLK_EN,
++		pcie->parf + PCIE20_PARF_MHI_CLOCK_RESET_CTRL);
++	writel(GEN3_RELATED_OFF_RXEQ_RGRDLESS_RXTS
++		| GEN3_RELATED_OFF_GEN3_ZRXDC_NONCOMPL,
++		pci->dbi_base + GEN3_RELATED_OFF);
++
++	writel(MST_WAKEUP_EN | SLV_WAKEUP_EN | MSTR_ACLK_CGC_DIS
++		| SLV_ACLK_CGC_DIS | CORE_CLK_CGC_DIS |
++		AUX_PWR_DET | L23_CLK_RMV_DIS | L1_CLK_RMV_DIS,
++		pcie->parf + PCIE20_PARF_SYS_CTRL);
++
++	writel(0, pcie->parf + PCIE20_PARF_Q2A_FLUSH);
++
++	dw_pcie_dbi_ro_wr_en(pci);
++	writel(PCIE_CAP_LINK1_VAL, pci->dbi_base + offset + PCI_EXP_SLTCAP);
++
++	/* Configure PCIe link capabilities for ASPM */
++	val = readl(pci->dbi_base + offset + PCI_EXP_LNKCAP);
++	val &= ~PCI_EXP_LNKCAP_ASPMS;
++	writel(val, pci->dbi_base + offset + PCI_EXP_LNKCAP);
++
++	writel(PCI_EXP_DEVCTL2_COMP_TMOUT_DIS, pci->dbi_base + offset +
++			PCI_EXP_DEVCTL2);
++
++	writel(PCIE_CAP_CURR_DEEMPHASIS | SPEED_GEN3,
++			pci->dbi_base + offset + PCI_EXP_DEVCTL2);
++
++	for (i = 0;i < 256;i++)
++		writel(0x0, pcie->parf + PCIE20_PARF_BDF_TO_SID_TABLE_N
++				+ (4 * i));
++
++	return 0;
++}
++
+ static int qcom_pcie_link_up(struct dw_pcie *pci)
+ {
+ 	u16 offset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);
+@@ -1351,6 +1491,15 @@ static const struct qcom_pcie_ops ops_2_
+ 	.post_deinit = qcom_pcie_post_deinit_2_7_0,
+ };
+ 
++/* Qcom IP rev.: 2.9.0  Synopsys IP rev.: 5.00a */
++static const struct qcom_pcie_ops ops_2_9_0 = {
++	.get_resources = qcom_pcie_get_resources_2_9_0,
++	.init = qcom_pcie_init_2_9_0,
++	.post_init = qcom_pcie_post_init_2_9_0,
++	.deinit = qcom_pcie_deinit_2_9_0,
++	.ltssm_enable = qcom_pcie_2_3_2_ltssm_enable,
++};
++
+ static const struct dw_pcie_ops dw_pcie_ops = {
+ 	.link_up = qcom_pcie_link_up,
+ 	.start_link = qcom_pcie_start_link,
+@@ -1457,6 +1606,7 @@ static const struct of_device_id qcom_pc
+ 	{ .compatible = "qcom,pcie-ipq4019", .data = &ops_2_4_0 },
+ 	{ .compatible = "qcom,pcie-qcs404", .data = &ops_2_4_0 },
+ 	{ .compatible = "qcom,pcie-sdm845", .data = &ops_2_7_0 },
++	{ .compatible = "qcom,pcie-ipq6018", .data = &ops_2_9_0 },
+ 	{ }
+ };
+ 
diff --git a/target/linux/ipq807x/patches-5.10/118-arm64-dts-ipq8074-Fixup-PCIe-dts-nodes.patch b/target/linux/ipq807x/patches-5.10/118-arm64-dts-ipq8074-Fixup-PCIe-dts-nodes.patch
new file mode 100644
index 0000000..0f1472f
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/118-arm64-dts-ipq8074-Fixup-PCIe-dts-nodes.patch
@@ -0,0 +1,196 @@
+From f46a2d9ff3346809e64fbf5c1796651207b57f00 Mon Sep 17 00:00:00 2001
+From: Sivaprakash Murugesan <sivaprak@codeaurora.org>
+Date: Wed, 29 Jul 2020 21:00:07 +0530
+Subject: [PATCH] arm64: dts: ipq8074: Fixup PCIe dts nodes
+
+ipq8074 PCIe nodes missing required properties to make them work.
+Add these properties.
+
+Signed-off-by: Sivaprakash Murugesan <sivaprak@codeaurora.org>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 109 +++++++++++++++++---------
+ 1 file changed, 74 insertions(+), 35 deletions(-)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -227,34 +227,66 @@
+ 			resets = <&gcc GCC_QUSB2_0_PHY_BCR>;
+ 		};
+ 
+-		pcie_phy0: phy@86000 {
+-			compatible = "qcom,ipq8074-qmp-pcie-phy";
+-			reg = <0x00086000 0x1000>;
+-			#phy-cells = <0>;
+-			clocks = <&gcc GCC_PCIE0_PIPE_CLK>;
+-			clock-names = "pipe_clk";
+-			clock-output-names = "pcie20_phy0_pipe_clk";
++		qmp_pcie_phy0: phy@84000 {
++			compatible = "qcom,ipq8074-qmp-pcie-gen3-phy";
++			reg = <0x00084000 0x1bc>;
++			#address-cells = <1>;
++			#size-cells = <1>;
++			ranges;
++
++			clocks = <&gcc GCC_PCIE0_AUX_CLK>,
++				 <&gcc GCC_PCIE0_AHB_CLK>;
++			clock-names = "aux", "cfg_ahb";
+ 
+ 			resets = <&gcc GCC_PCIE0_PHY_BCR>,
+-				<&gcc GCC_PCIE0PHY_PHY_BCR>;
++				 <&gcc GCC_PCIE0PHY_PHY_BCR>;
+ 			reset-names = "phy",
+ 				      "common";
++
+ 			status = "disabled";
++			pcie_phy0: lane@84200 {
++				reg = <0x84200 0x16c>, /* Serdes Tx */
++				      <0x84400 0x200>, /* Serdes Rx */
++				      <0x84800 0x4f4>; /* PCS: Lane0, COM, PCIE */
++				#phy-cells = <0>;
++
++				clocks = <&gcc GCC_PCIE0_PIPE_CLK>;
++				clock-names = "pipe0";
++				clock-output-names = "gcc_pcie0_pipe_clk_src";
++				clock-output-rate = <250000000>;
++				#clock-cells = <0>;
++			};
+ 		};
+ 
+-		pcie_phy1: phy@8e000 {
++		qmp_pcie_phy1: phy@8e000 {
+ 			compatible = "qcom,ipq8074-qmp-pcie-phy";
+-			reg = <0x0008e000 0x1000>;
+-			#phy-cells = <0>;
+-			clocks = <&gcc GCC_PCIE1_PIPE_CLK>;
+-			clock-names = "pipe_clk";
+-			clock-output-names = "pcie20_phy1_pipe_clk";
++			reg = <0x8e000 0x1c4>; /* Serdes PLL */
++			#address-cells = <1>;
++			#size-cells = <1>;
++			ranges;
++
++			clocks = <&gcc GCC_PCIE1_AUX_CLK>,
++				 <&gcc GCC_PCIE1_AHB_CLK>;
++			clock-names = "aux", "cfg_ahb";
+ 
+ 			resets = <&gcc GCC_PCIE1_PHY_BCR>,
+-				<&gcc GCC_PCIE1PHY_PHY_BCR>;
++				 <&gcc GCC_PCIE1PHY_PHY_BCR>;
+ 			reset-names = "phy",
+ 				      "common";
++
+ 			status = "disabled";
++			pcie_phy1: lane@8e200 {
++				reg = <0x8e200 0x130>, /* Serdes Tx */
++				      <0x8e400 0x200>, /* Serdes Rx */
++				      <0x8e800 0x1f8>; /* PCS */
++				#phy-cells = <0>;
++
++				clocks = <&gcc GCC_PCIE1_PIPE_CLK>;
++				clock-names = "pipe0";
++				clock-output-names = "gcc_pcie1_pipe_clk_src";
++				clock-output-rate = <125000000>;
++				#clock-cells = <0>;
++			};
+ 		};
+ 
+ 		mdio: mdio@90000 {
+@@ -671,10 +703,10 @@
+ 
+ 		pcie1: pci@10000000 {
+ 			compatible = "qcom,pcie-ipq8074";
+-			reg =  <0x10000000 0xf1d
+-				0x10000f20 0xa8
+-				0x00088000 0x2000
+-				0x10100000 0x1000>;
++			reg =  <0x10000000 0xf1d>,
++			       <0x10000f20 0xa8>,
++			       <0x00088000 0x2000>,
++			       <0x10100000 0x1000>;
+ 			reg-names = "dbi", "elbi", "parf", "config";
+ 			device_type = "pci";
+ 			linux,pci-domain = <1>;
+@@ -687,9 +719,9 @@
+ 			phy-names = "pciephy";
+ 
+ 			ranges = <0x81000000 0 0x10200000 0x10200000
+-				  0 0x100000   /* downstream I/O */
+-				  0x82000000 0 0x10300000 0x10300000
+-				  0 0xd00000>; /* non-prefetchable memory */
++				  0 0x100000>,   /* downstream I/O */
++				 <0x82000000 0 0x10220000 0x10220000
++				  0 0xfde0000>; /* non-prefetchable memory */
+ 
+ 			interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "msi";
+@@ -732,12 +764,13 @@
+ 		};
+ 
+ 		pcie0: pci@20000000 {
+-			compatible = "qcom,pcie-ipq8074";
+-			reg =  <0x20000000 0xf1d
+-				0x20000f20 0xa8
+-				0x00080000 0x2000
+-				0x20100000 0x1000>;
+-			reg-names = "dbi", "elbi", "parf", "config";
++			compatible = "qcom,pcie-ipq8074-gen3";
++			reg =  <0x20000000 0xf1d>,
++			       <0x20000f20 0xa8>,
++			       <0x20001000 0x1000>,
++			       <0x00080000 0x4000>,
++			       <0x20100000 0x1000>;
++			reg-names = "dbi", "elbi", "atu", "parf", "config";
+ 			device_type = "pci";
+ 			linux,pci-domain = <0>;
+ 			bus-range = <0x00 0xff>;
+@@ -749,9 +782,9 @@
+ 			phy-names = "pciephy";
+ 
+ 			ranges = <0x81000000 0 0x20200000 0x20200000
+-				  0 0x100000   /* downstream I/O */
+-				  0x82000000 0 0x20300000 0x20300000
+-				  0 0xd00000>; /* non-prefetchable memory */
++				  0 0x100000>,   /* downstream I/O */
++				 <0x82000000 0 0x20220000 0x20220000
++				  0 0xfde0000>; /* non-prefetchable memory */
+ 
+ 			interrupts = <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "msi";
+@@ -770,27 +803,33 @@
+ 				 <&gcc GCC_PCIE0_AXI_M_CLK>,
+ 				 <&gcc GCC_PCIE0_AXI_S_CLK>,
+ 				 <&gcc GCC_PCIE0_AHB_CLK>,
+-				 <&gcc GCC_PCIE0_AUX_CLK>;
++				 <&gcc GCC_PCIE0_AUX_CLK>,
++				 <&gcc GCC_PCIE0_AXI_S_BRIDGE_CLK>,
++				 <&gcc GCC_PCIE0_RCHNG_CLK>;
+ 
+ 			clock-names = "iface",
+ 				      "axi_m",
+ 				      "axi_s",
+ 				      "ahb",
+-				      "aux";
++				      "aux",
++				      "axi_bridge",
++				      "rchng";
+ 			resets = <&gcc GCC_PCIE0_PIPE_ARES>,
+ 				 <&gcc GCC_PCIE0_SLEEP_ARES>,
+ 				 <&gcc GCC_PCIE0_CORE_STICKY_ARES>,
+ 				 <&gcc GCC_PCIE0_AXI_MASTER_ARES>,
+ 				 <&gcc GCC_PCIE0_AXI_SLAVE_ARES>,
+ 				 <&gcc GCC_PCIE0_AHB_ARES>,
+-				 <&gcc GCC_PCIE0_AXI_MASTER_STICKY_ARES>;
++				 <&gcc GCC_PCIE0_AXI_MASTER_STICKY_ARES>,
++				 <&gcc GCC_PCIE0_AXI_SLAVE_STICKY_ARES>;
+ 			reset-names = "pipe",
+ 				      "sleep",
+ 				      "sticky",
+ 				      "axi_m",
+ 				      "axi_s",
+ 				      "ahb",
+-				      "axi_m_sticky";
++				      "axi_m_sticky",
++				      "axi_s_sticky";
+ 			status = "disabled";
+ 		};
+ 
diff --git a/target/linux/ipq807x/patches-5.10/119-qcom-backport-register-define.patch b/target/linux/ipq807x/patches-5.10/119-qcom-backport-register-define.patch
new file mode 100644
index 0000000..b1e5c82
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/119-qcom-backport-register-define.patch
@@ -0,0 +1,26 @@
+From 5d3f9ed5a9eb305a2531015cc65200d48be5dbf4 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Tue, 11 May 2021 22:21:57 +0200
+Subject: [PATCH 1/2] PCI: qcom: backport register define
+
+This is used by the pending IPQ6018 PCI support which
+uses the same Gen3 IP and the one we are reusing for
+IPQ8074.
+
+Without it compilation will break.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ drivers/pci/controller/dwc/pcie-qcom.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/pci/controller/dwc/pcie-qcom.c
++++ b/drivers/pci/controller/dwc/pcie-qcom.c
+@@ -61,6 +61,7 @@
+ #define PCIE20_PARF_SID_OFFSET			0x234
+ #define PCIE20_PARF_BDF_TRANSLATE_CFG		0x24C
+ #define PCIE20_PARF_DEVICE_TYPE			0x1000
++#define PCIE20_PARF_BDF_TO_SID_TABLE_N		0x2000
+ 
+ #define PCIE20_ELBI_SYS_CTRL			0x04
+ #define PCIE20_ELBI_SYS_CTRL_LT_ENABLE		BIT(0)
diff --git a/target/linux/ipq807x/patches-5.10/120-PCI-qcom-Add-IPQ8074-PCIe-Gen3-support.patch b/target/linux/ipq807x/patches-5.10/120-PCI-qcom-Add-IPQ8074-PCIe-Gen3-support.patch
new file mode 100644
index 0000000..0cb6aa8
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/120-PCI-qcom-Add-IPQ8074-PCIe-Gen3-support.patch
@@ -0,0 +1,48 @@
+From 9467e9860e72d7351b24dc6d77f0e9fe141ce166 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Wed, 26 May 2021 16:06:32 +0200
+Subject: [PATCH] PCI: qcom: Add IPQ8074 PCIe Gen3 support
+
+IPQ6018 uses the same v2.9.0 IP for the Gen3 PCIe
+controller.
+
+So, lets reuse that and add clocks that the IPQ6018
+patch missed.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ drivers/pci/controller/dwc/pcie-qcom.c | 9 ++++++---
+ 1 file changed, 6 insertions(+), 3 deletions(-)
+
+--- a/drivers/pci/controller/dwc/pcie-qcom.c
++++ b/drivers/pci/controller/dwc/pcie-qcom.c
+@@ -173,7 +173,7 @@ struct qcom_pcie_resources_2_7_0 {
+ };
+ 
+ struct qcom_pcie_resources_2_9_0 {
+-	struct clk_bulk_data clks[5];
++	struct clk_bulk_data clks[7];
+ 	struct reset_control *rst;
+ };
+ 
+@@ -1279,8 +1279,10 @@ static int qcom_pcie_get_resources_2_9_0
+ 	res->clks[0].id = "iface";
+ 	res->clks[1].id = "axi_m";
+ 	res->clks[2].id = "axi_s";
+-	res->clks[3].id = "axi_bridge";
+-	res->clks[4].id = "rchng";
++	res->clks[3].id = "ahb";
++	res->clks[4].id = "aux";
++	res->clks[5].id = "axi_bridge";
++	res->clks[6].id = "rchng";
+ 
+ 	ret = devm_clk_bulk_get(dev, ARRAY_SIZE(res->clks), res->clks);
+ 	if (ret < 0)
+@@ -1608,6 +1610,7 @@ static const struct of_device_id qcom_pc
+ 	{ .compatible = "qcom,pcie-qcs404", .data = &ops_2_4_0 },
+ 	{ .compatible = "qcom,pcie-sdm845", .data = &ops_2_7_0 },
+ 	{ .compatible = "qcom,pcie-ipq6018", .data = &ops_2_9_0 },
++	{ .compatible = "qcom,pcie-ipq8074-gen3", .data = &ops_2_9_0 },
+ 	{ }
+ };
+ 
diff --git a/target/linux/ipq807x/patches-5.10/122-arm64-uaccess-include-scheduler.h.patch b/target/linux/ipq807x/patches-5.10/122-arm64-uaccess-include-scheduler.h.patch
new file mode 100644
index 0000000..40244b0
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/122-arm64-uaccess-include-scheduler.h.patch
@@ -0,0 +1,27 @@
+From 5fcad0d86d985b068eb97e55b55f7be87cd1b008 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Wed, 12 May 2021 17:01:29 +0200
+Subject: [PATCH] arm64: uaccess: include scheduler.h
+
+Qualcomm SSDK exposed a bug in which the uaccess is
+using a struct and header definition that are not
+included.
+
+So, simply: #include <linux/sched.h> to fix it.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/include/asm/uaccess.h | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/arch/arm64/include/asm/uaccess.h
++++ b/arch/arm64/include/asm/uaccess.h
+@@ -24,6 +24,8 @@
+ #include <asm/memory.h>
+ #include <asm/extable.h>
+ 
++#include <linux/sched.h>
++
+ #define get_fs()	(current_thread_info()->addr_limit)
+ 
+ static inline void set_fs(mm_segment_t fs)
diff --git a/target/linux/ipq807x/patches-5.10/123-arm64-dts-ipq8074-add-networking-nodes.patch b/target/linux/ipq807x/patches-5.10/123-arm64-dts-ipq8074-add-networking-nodes.patch
new file mode 100644
index 0000000..d1b15b7
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/123-arm64-dts-ipq8074-add-networking-nodes.patch
@@ -0,0 +1,170 @@
+From f581e7b004d0d997acc1f0fa5b2c454f90f0b2de Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Wed, 12 May 2021 18:49:30 +0200
+Subject: [PATCH] arm64: dts: ipq8074: add networking nodes
+
+Add networking nodes required for SSDK and NSS-DP.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 150 ++++++++++++++++++++++++++
+ 1 file changed, 150 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -899,5 +899,155 @@
+ 				};
+ 			};
+ 		};
++
++		ess_switch: ess-switch@3a000000 {
++			compatible = "qcom,ess-switch-ipq807x";
++			reg = <0x3a000000 0x1000000>;
++			switch_access_mode = "local bus";
++			switch_cpu_bmp = <0x1>;  /* cpu port bitmap */
++			switch_inner_bmp = <0x80>; /*inner port bitmap*/
++			mdio-bus = <&mdio>;
++			clocks = <&gcc GCC_CMN_12GPLL_AHB_CLK>,
++				 <&gcc GCC_CMN_12GPLL_SYS_CLK>,
++				 <&gcc GCC_UNIPHY0_AHB_CLK>,
++				 <&gcc GCC_UNIPHY0_SYS_CLK>,
++				 <&gcc GCC_UNIPHY1_AHB_CLK>,
++				 <&gcc GCC_UNIPHY1_SYS_CLK>,
++				 <&gcc GCC_UNIPHY2_AHB_CLK>,
++				 <&gcc GCC_UNIPHY2_SYS_CLK>,
++				 <&gcc GCC_PORT1_MAC_CLK>,
++				 <&gcc GCC_PORT2_MAC_CLK>,
++				 <&gcc GCC_PORT3_MAC_CLK>,
++				 <&gcc GCC_PORT4_MAC_CLK>,
++				 <&gcc GCC_PORT5_MAC_CLK>,
++				 <&gcc GCC_PORT6_MAC_CLK>,
++				 <&gcc GCC_NSS_PPE_CLK>,
++				 <&gcc GCC_NSS_PPE_CFG_CLK>,
++				 <&gcc GCC_NSSNOC_PPE_CLK>,
++				 <&gcc GCC_NSSNOC_PPE_CFG_CLK>,
++				 <&gcc GCC_NSS_EDMA_CLK>,
++				 <&gcc GCC_NSS_EDMA_CFG_CLK>,
++				 <&gcc GCC_NSS_PPE_IPE_CLK>,
++				 <&gcc GCC_NSS_PPE_BTQ_CLK>,
++				 <&gcc GCC_NSS_NOC_CLK>,
++				 <&gcc GCC_NSSNOC_SNOC_CLK>,
++				 <&gcc GCC_MEM_NOC_NSS_AXI_CLK>,
++				 <&gcc GCC_NSS_CRYPTO_CLK>,
++				 <&gcc GCC_NSS_IMEM_CLK>,
++				 <&gcc GCC_NSS_PTP_REF_CLK>,
++				 <&gcc GCC_NSS_PORT1_RX_CLK>,
++				 <&gcc GCC_NSS_PORT1_TX_CLK>,
++				 <&gcc GCC_NSS_PORT2_RX_CLK>,
++				 <&gcc GCC_NSS_PORT2_TX_CLK>,
++				 <&gcc GCC_NSS_PORT3_RX_CLK>,
++				 <&gcc GCC_NSS_PORT3_TX_CLK>,
++				 <&gcc GCC_NSS_PORT4_RX_CLK>,
++				 <&gcc GCC_NSS_PORT4_TX_CLK>,
++				 <&gcc GCC_NSS_PORT5_RX_CLK>,
++				 <&gcc GCC_NSS_PORT5_TX_CLK>,
++				 <&gcc GCC_NSS_PORT6_RX_CLK>,
++				 <&gcc GCC_NSS_PORT6_TX_CLK>,
++				 <&gcc GCC_UNIPHY0_PORT1_RX_CLK>,
++				 <&gcc GCC_UNIPHY0_PORT1_TX_CLK>,
++				 <&gcc GCC_UNIPHY0_PORT2_RX_CLK>,
++				 <&gcc GCC_UNIPHY0_PORT2_TX_CLK>,
++				 <&gcc GCC_UNIPHY0_PORT3_RX_CLK>,
++				 <&gcc GCC_UNIPHY0_PORT3_TX_CLK>,
++				 <&gcc GCC_UNIPHY0_PORT4_RX_CLK>,
++				 <&gcc GCC_UNIPHY0_PORT4_TX_CLK>,
++				 <&gcc GCC_UNIPHY0_PORT5_RX_CLK>,
++				 <&gcc GCC_UNIPHY0_PORT5_TX_CLK>,
++				 <&gcc GCC_UNIPHY1_PORT5_RX_CLK>,
++				 <&gcc GCC_UNIPHY1_PORT5_TX_CLK>,
++				 <&gcc GCC_UNIPHY2_PORT6_RX_CLK>,
++				 <&gcc GCC_UNIPHY2_PORT6_TX_CLK>,
++				 <&gcc NSS_PORT5_RX_CLK_SRC>,
++				 <&gcc NSS_PORT5_TX_CLK_SRC>;
++			clock-names = "cmn_ahb_clk", "cmn_sys_clk",
++					"uniphy0_ahb_clk", "uniphy0_sys_clk",
++					"uniphy1_ahb_clk", "uniphy1_sys_clk",
++					"uniphy2_ahb_clk", "uniphy2_sys_clk",
++					"port1_mac_clk", "port2_mac_clk",
++					"port3_mac_clk", "port4_mac_clk",
++					"port5_mac_clk", "port6_mac_clk",
++					"nss_ppe_clk", "nss_ppe_cfg_clk",
++					"nssnoc_ppe_clk", "nssnoc_ppe_cfg_clk",
++					"nss_edma_clk", "nss_edma_cfg_clk",
++					"nss_ppe_ipe_clk", "nss_ppe_btq_clk",
++					"gcc_nss_noc_clk",
++					"gcc_nssnoc_snoc_clk",
++					"gcc_mem_noc_nss_axi_clk",
++					"gcc_nss_crypto_clk",
++					"gcc_nss_imem_clk",
++					"gcc_nss_ptp_ref_clk",
++					"nss_port1_rx_clk", "nss_port1_tx_clk",
++					"nss_port2_rx_clk", "nss_port2_tx_clk",
++					"nss_port3_rx_clk", "nss_port3_tx_clk",
++					"nss_port4_rx_clk", "nss_port4_tx_clk",
++					"nss_port5_rx_clk", "nss_port5_tx_clk",
++					"nss_port6_rx_clk", "nss_port6_tx_clk",
++					"uniphy0_port1_rx_clk",
++					"uniphy0_port1_tx_clk",
++					"uniphy0_port2_rx_clk",
++					"uniphy0_port2_tx_clk",
++					"uniphy0_port3_rx_clk",
++					"uniphy0_port3_tx_clk",
++					"uniphy0_port4_rx_clk",
++					"uniphy0_port4_tx_clk",
++					"uniphy0_port5_rx_clk",
++					"uniphy0_port5_tx_clk",
++					"uniphy1_port5_rx_clk",
++					"uniphy1_port5_tx_clk",
++					"uniphy2_port6_rx_clk",
++					"uniphy2_port6_tx_clk",
++					"nss_port5_rx_clk_src",
++					"nss_port5_tx_clk_src";
++			resets = <&gcc GCC_PPE_FULL_RESET>,
++				 <&gcc GCC_UNIPHY0_SOFT_RESET>,
++				 <&gcc GCC_UNIPHY0_XPCS_RESET>,
++				 <&gcc GCC_UNIPHY1_SOFT_RESET>,
++				 <&gcc GCC_UNIPHY1_XPCS_RESET>,
++				 <&gcc GCC_UNIPHY2_SOFT_RESET>,
++				 <&gcc GCC_UNIPHY2_XPCS_RESET>,
++				 <&gcc GCC_NSSPORT1_RESET>,
++				 <&gcc GCC_NSSPORT2_RESET>,
++				 <&gcc GCC_NSSPORT3_RESET>,
++				 <&gcc GCC_NSSPORT4_RESET>,
++				 <&gcc GCC_NSSPORT5_RESET>,
++				 <&gcc GCC_NSSPORT6_RESET>;
++			reset-names = "ppe_rst", "uniphy0_soft_rst",
++					"uniphy0_xpcs_rst", "uniphy1_soft_rst",
++					"uniphy1_xpcs_rst", "uniphy2_soft_rst",
++					"uniphy2_xpcs_rst", "nss_port1_rst",
++					"nss_port2_rst", "nss_port3_rst",
++					"nss_port4_rst", "nss_port5_rst",
++					"nss_port6_rst";
++		};
++
++		ess-uniphy@7a00000 {
++			compatible = "qcom,ess-uniphy";
++			reg = <0x7a00000 0x30000>;
++			uniphy_access_mode = "local bus";
++		};
++
++		edma@3ab00000 {
++			compatible = "qcom,edma";
++			reg = <0x3ab00000 0x76900>;
++			reg-names = "edma-reg-base";
++			qcom,txdesc-ring-start = <23>;
++			qcom,txdesc-rings = <1>;
++			qcom,txcmpl-ring-start = <7>;
++			qcom,txcmpl-rings = <1>;
++			qcom,rxfill-ring-start = <7>;
++			qcom,rxfill-rings = <1>;
++			qcom,rxdesc-ring-start = <15>;
++			qcom,rxdesc-rings = <1>;
++			interrupts = <GIC_SPI 345 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 353 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 361 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 344 IRQ_TYPE_LEVEL_HIGH>;
++			resets = <&gcc GCC_EDMA_HW_RESET>;
++			reset-names = "edma_rst";
++		};
+ 	};
+ };
diff --git a/target/linux/ipq807x/patches-5.10/124-clk-ipq-support-for-resetting-multiple-bits.patch b/target/linux/ipq807x/patches-5.10/124-clk-ipq-support-for-resetting-multiple-bits.patch
new file mode 100644
index 0000000..4819a67
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/124-clk-ipq-support-for-resetting-multiple-bits.patch
@@ -0,0 +1,56 @@
+From 027818c51e6732f8a2f7986515264cebaf9a1704 Mon Sep 17 00:00:00 2001
+From: Rajkumar Ayyasamy <arajkuma@codeaurora.org>
+Date: Wed, 18 Mar 2020 17:08:11 +0530
+Subject: [PATCH 1/8] clk: ipq: support for resetting multiple bits
+
+Current reset structure takes only one reset bit and
+calculates the bitmask in its reset operation. Some of the
+reset registers contains multiple bits in which each bit
+will be associated with subsystem reset inside the block. To
+reset properly the complete block, all the subsystem reset
+should be triggered at same time i.e the register write
+should go in one AHB write.
+
+This patch adds the support for giving the complete bitmask
+in reset structure and reset operation will use this bitmask
+for all reset operations.
+
+Change-Id: Ief49f8746624a0fc1e067d815725ae7c254c2c6f
+Signed-off-by: Abhishek Sahu <absahu@codeaurora.org>
+(cherry picked from commit ef555fc1cffa6e823a9d929711cacae0821b35ec)
+Signed-off-by: Rajkumar Ayyasamy <arajkuma@codeaurora.org>
+---
+ drivers/clk/qcom/reset.c | 4 ++--
+ drivers/clk/qcom/reset.h | 1 +
+ 2 files changed, 3 insertions(+), 2 deletions(-)
+
+--- a/drivers/clk/qcom/reset.c
++++ b/drivers/clk/qcom/reset.c
+@@ -28,7 +28,7 @@ qcom_reset_assert(struct reset_controlle
+ 
+ 	rst = to_qcom_reset_controller(rcdev);
+ 	map = &rst->reset_map[id];
+-	mask = BIT(map->bit);
++	mask = map->bitmask ? map->bitmask : BIT(map->bit);
+ 
+ 	return regmap_update_bits(rst->regmap, map->reg, mask, mask);
+ }
+@@ -42,7 +42,7 @@ qcom_reset_deassert(struct reset_control
+ 
+ 	rst = to_qcom_reset_controller(rcdev);
+ 	map = &rst->reset_map[id];
+-	mask = BIT(map->bit);
++	mask = map->bitmask ? map->bitmask : BIT(map->bit);
+ 
+ 	return regmap_update_bits(rst->regmap, map->reg, mask, 0);
+ }
+--- a/drivers/clk/qcom/reset.h
++++ b/drivers/clk/qcom/reset.h
+@@ -11,6 +11,7 @@
+ struct qcom_reset_map {
+ 	unsigned int reg;
+ 	u8 bit;
++	u32 bitmask;
+ };
+ 
+ struct regmap;
diff --git a/target/linux/ipq807x/patches-5.10/125-ipq8074-gcc-Added-support-for-NSS-clocks.patch b/target/linux/ipq807x/patches-5.10/125-ipq8074-gcc-Added-support-for-NSS-clocks.patch
new file mode 100644
index 0000000..ff3c7d0
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/125-ipq8074-gcc-Added-support-for-NSS-clocks.patch
@@ -0,0 +1,212 @@
+From 4f579facd45c39f8f8b9993570944f4d83a95955 Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Wed, 5 Feb 2020 10:13:01 +0530
+Subject: [PATCH 2/8] ipq8074: gcc: Added support for NSS clocks
+
+Change-Id: I446e84dbc3498618425677811a73124b99b5c0ad
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+Signed-off-by: Rajkumar Ayyasamy <arajkuma@codeaurora.org>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi        | 12 ++++
+ drivers/clk/qcom/gcc-ipq8074.c               | 68 +++++++++++++++++++-
+ include/dt-bindings/clock/qcom,gcc-ipq8074.h |  1 +
+ 3 files changed, 80 insertions(+), 1 deletion(-)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -1049,5 +1049,17 @@
+ 			resets = <&gcc GCC_EDMA_HW_RESET>;
+ 			reset-names = "edma_rst";
+ 		};
++
++		bias_pll_cc_clk {
++			compatible = "fixed-clock";
++			clock-frequency = <300000000>;
++			#clock-cells = <0>;
++		};
++
++		bias_pll_nss_noc_clk {
++			compatible = "fixed-clock";
++			clock-frequency = <416500000>;
++			#clock-cells = <0>;
++		};
+ 	};
+ };
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -3174,6 +3174,24 @@ static struct clk_branch gcc_nss_ptp_ref
+ 	},
+ };
+ 
++static struct clk_branch gcc_crypto_ppe_clk = {
++	.halt_reg = 0x68310,
++	.halt_bit = 31,
++	.clkr = {
++		.enable_reg = 0x68310,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data){
++			.name = "gcc_crypto_ppe_clk",
++			.parent_names = (const char *[]){
++				"nss_ppe_clk_src"
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
+ static struct clk_branch gcc_nssnoc_ce_apb_clk = {
+ 	.halt_reg = 0x6830c,
+ 	.clkr = {
+@@ -3346,6 +3364,7 @@ static struct clk_branch gcc_nssnoc_ubi1
+ 
+ static struct clk_branch gcc_ubi0_ahb_clk = {
+ 	.halt_reg = 0x6820c,
++	.halt_check = BRANCH_HALT_DELAY,
+ 	.clkr = {
+ 		.enable_reg = 0x6820c,
+ 		.enable_mask = BIT(0),
+@@ -3363,6 +3382,7 @@ static struct clk_branch gcc_ubi0_ahb_cl
+ 
+ static struct clk_branch gcc_ubi0_axi_clk = {
+ 	.halt_reg = 0x68200,
++	.halt_check = BRANCH_HALT_DELAY,
+ 	.clkr = {
+ 		.enable_reg = 0x68200,
+ 		.enable_mask = BIT(0),
+@@ -3380,6 +3400,7 @@ static struct clk_branch gcc_ubi0_axi_cl
+ 
+ static struct clk_branch gcc_ubi0_nc_axi_clk = {
+ 	.halt_reg = 0x68204,
++	.halt_check = BRANCH_HALT_DELAY,
+ 	.clkr = {
+ 		.enable_reg = 0x68204,
+ 		.enable_mask = BIT(0),
+@@ -3397,6 +3418,7 @@ static struct clk_branch gcc_ubi0_nc_axi
+ 
+ static struct clk_branch gcc_ubi0_core_clk = {
+ 	.halt_reg = 0x68210,
++	.halt_check = BRANCH_HALT_DELAY,
+ 	.clkr = {
+ 		.enable_reg = 0x68210,
+ 		.enable_mask = BIT(0),
+@@ -3414,6 +3436,7 @@ static struct clk_branch gcc_ubi0_core_c
+ 
+ static struct clk_branch gcc_ubi0_mpt_clk = {
+ 	.halt_reg = 0x68208,
++	.halt_check = BRANCH_HALT_DELAY,
+ 	.clkr = {
+ 		.enable_reg = 0x68208,
+ 		.enable_mask = BIT(0),
+@@ -3431,6 +3454,7 @@ static struct clk_branch gcc_ubi0_mpt_cl
+ 
+ static struct clk_branch gcc_ubi1_ahb_clk = {
+ 	.halt_reg = 0x6822c,
++	.halt_check = BRANCH_HALT_DELAY,
+ 	.clkr = {
+ 		.enable_reg = 0x6822c,
+ 		.enable_mask = BIT(0),
+@@ -3448,6 +3472,7 @@ static struct clk_branch gcc_ubi1_ahb_cl
+ 
+ static struct clk_branch gcc_ubi1_axi_clk = {
+ 	.halt_reg = 0x68220,
++	.halt_check = BRANCH_HALT_DELAY,
+ 	.clkr = {
+ 		.enable_reg = 0x68220,
+ 		.enable_mask = BIT(0),
+@@ -3465,6 +3490,7 @@ static struct clk_branch gcc_ubi1_axi_cl
+ 
+ static struct clk_branch gcc_ubi1_nc_axi_clk = {
+ 	.halt_reg = 0x68224,
++	.halt_check = BRANCH_HALT_DELAY,
+ 	.clkr = {
+ 		.enable_reg = 0x68224,
+ 		.enable_mask = BIT(0),
+@@ -3482,6 +3508,7 @@ static struct clk_branch gcc_ubi1_nc_axi
+ 
+ static struct clk_branch gcc_ubi1_core_clk = {
+ 	.halt_reg = 0x68230,
++	.halt_check = BRANCH_HALT_DELAY,
+ 	.clkr = {
+ 		.enable_reg = 0x68230,
+ 		.enable_mask = BIT(0),
+@@ -3499,6 +3526,7 @@ static struct clk_branch gcc_ubi1_core_c
+ 
+ static struct clk_branch gcc_ubi1_mpt_clk = {
+ 	.halt_reg = 0x68228,
++	.halt_check = BRANCH_HALT_DELAY,
+ 	.clkr = {
+ 		.enable_reg = 0x68228,
+ 		.enable_mask = BIT(0),
+@@ -4381,6 +4409,33 @@ static struct clk_hw *gcc_ipq8074_hws[]
+ 	&nss_ppe_cdiv_clk_src.hw,
+ };
+ 
++static const struct alpha_pll_config ubi32_pll_config = {
++	.l = 0x4e,
++	.config_ctl_val = 0x200d4aa8,
++	.config_ctl_hi_val = 0x3c2,
++	.main_output_mask = BIT(0),
++	.aux_output_mask = BIT(1),
++	.pre_div_val = 0x0,
++	.pre_div_mask = BIT(12),
++	.post_div_val = 0x0,
++	.post_div_mask = GENMASK(9, 8),
++};
++
++static const struct alpha_pll_config nss_crypto_pll_config = {
++	.l = 0x3e,
++	.alpha = 0x0,
++	.alpha_hi = 0x80,
++	.config_ctl_val = 0x4001055b,
++	.main_output_mask = BIT(0),
++	.pre_div_val = 0x0,
++	.pre_div_mask = GENMASK(14, 12),
++	.post_div_val = 0x1 << 8,
++	.post_div_mask = GENMASK(11, 8),
++	.vco_mask = GENMASK(21, 20),
++	.vco_val = 0x0,
++	.alpha_en_mask = BIT(24),
++};
++
+ static struct clk_regmap *gcc_ipq8074_clks[] = {
+ 	[GPLL0_MAIN] = &gpll0_main.clkr,
+ 	[GPLL0] = &gpll0.clkr,
+@@ -4562,6 +4617,7 @@ static struct clk_regmap *gcc_ipq8074_cl
+ 	[GCC_CMN_12GPLL_AHB_CLK] = &gcc_cmn_12gpll_ahb_clk.clkr,
+ 	[GCC_CMN_12GPLL_SYS_CLK] = &gcc_cmn_12gpll_sys_clk.clkr,
+ 	[GCC_MDIO_AHB_CLK] = &gcc_mdio_ahb_clk.clkr,
++	[GCC_CRYPTO_PPE_CLK] = &gcc_crypto_ppe_clk.clkr,
+ 	[GCC_UNIPHY0_AHB_CLK] = &gcc_uniphy0_ahb_clk.clkr,
+ 	[GCC_UNIPHY0_SYS_CLK] = &gcc_uniphy0_sys_clk.clkr,
+ 	[GCC_UNIPHY1_AHB_CLK] = &gcc_uniphy1_ahb_clk.clkr,
+@@ -4773,7 +4829,17 @@ static const struct qcom_cc_desc gcc_ipq
+ 
+ static int gcc_ipq8074_probe(struct platform_device *pdev)
+ {
+-	return qcom_cc_probe(pdev, &gcc_ipq8074_desc);
++	struct regmap *regmap;
++
++	regmap = qcom_cc_map(pdev, &gcc_ipq8074_desc);
++	if (IS_ERR(regmap))
++		return PTR_ERR(regmap);
++
++	clk_alpha_pll_configure(&ubi32_pll_main, regmap, &ubi32_pll_config);
++	clk_alpha_pll_configure(&nss_crypto_pll_main, regmap,
++				&nss_crypto_pll_config);
++
++	return qcom_cc_really_probe(pdev, &gcc_ipq8074_desc, regmap);
+ }
+ 
+ static struct platform_driver gcc_ipq8074_driver = {
+--- a/include/dt-bindings/clock/qcom,gcc-ipq8074.h
++++ b/include/dt-bindings/clock/qcom,gcc-ipq8074.h
+@@ -233,6 +233,7 @@
+ #define GCC_PCIE0_AXI_S_BRIDGE_CLK		224
+ #define GCC_PCIE0_RCHNG_CLK_SRC			225
+ #define GCC_PCIE0_RCHNG_CLK			226
++#define GCC_CRYPTO_PPE_CLK 			227
+ 
+ #define GCC_BLSP1_BCR				0
+ #define GCC_BLSP1_QUP1_BCR			1
diff --git a/target/linux/ipq807x/patches-5.10/126-clk-ipq8074-Support-added-for-necessary-clocks-and-r.patch b/target/linux/ipq807x/patches-5.10/126-clk-ipq8074-Support-added-for-necessary-clocks-and-r.patch
new file mode 100644
index 0000000..6fc0586
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/126-clk-ipq8074-Support-added-for-necessary-clocks-and-r.patch
@@ -0,0 +1,352 @@
+From 6504bc9edeb1a2a54d813f4bb5d0267e7bf827f9 Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Thu, 6 Feb 2020 17:35:42 +0530
+Subject: [PATCH 4/8] clk: ipq8074: Support added for necessary clocks and
+ reset
+
+Change-Id: I21a76a44185f766e9b6dcba274392ea8e599718b
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+Signed-off-by: Rajkumar Ayyasamy <arajkuma@codeaurora.org>
+---
+ drivers/clk/qcom/gcc-ipq8074.c               | 238 ++++++++++++++++++-
+ include/dt-bindings/clock/qcom,gcc-ipq8074.h |  35 ++-
+ 2 files changed, 258 insertions(+), 15 deletions(-)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -396,6 +396,22 @@ static const struct parent_map gcc_xo_gp
+ 	{ P_SLEEP_CLK, 6 },
+ };
+ 
++static const char * const gcc_xo_gpll4_gpll0_gpll6_gpll0_div2[] = {
++	"xo",
++	"gpll4",
++	"gpll0",
++	"gpll6",
++	"gpll0_out_main_div2",
++};
++
++static const struct parent_map gcc_xo_gpll4_gpll0_gpll6_gpll0_div2_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL4, 1 },
++	{ P_GPLL0, 2 },
++	{ P_GPLL6, 3 },
++	{ P_GPLL0_DIV2, 4 },
++};
++
+ static struct clk_alpha_pll gpll0_main = {
+ 	.offset = 0x21000,
+ 	.regs = clk_alpha_pll_regs[CLK_ALPHA_PLL_TYPE_DEFAULT],
+@@ -962,6 +978,12 @@ static const struct freq_tbl ftbl_pcie_a
+ 	{ }
+ };
+ 
++struct freq_tbl ftbl_pcie_rchng_clk_src[] = {
++	F(19200000, P_XO, 1, 0, 0),
++	F(100000000, P_GPLL0, 8, 0, 0),
++	{ }
++};
++
+ static struct clk_rcg2 pcie0_axi_clk_src = {
+ 	.cmd_rcgr = 0x75054,
+ 	.freq_tbl = ftbl_pcie_axi_clk_src,
+@@ -2013,6 +2035,78 @@ static struct clk_rcg2 gp3_clk_src = {
+ 	},
+ };
+ 
++struct freq_tbl ftbl_qdss_tsctr_clk_src[] = {
++	F(160000000, P_GPLL0_DIV2, 2.5, 0, 0),
++	F(320000000, P_GPLL0, 2.5, 0, 0),
++	F(600000000, P_GPLL6, 2, 0, 0),
++	{ }
++};
++
++struct clk_rcg2 qdss_tsctr_clk_src = {
++	.cmd_rcgr = 0x29064,
++	.freq_tbl = ftbl_qdss_tsctr_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll4_gpll0_gpll6_gpll0_div2_map,
++	.clkr.hw.init = &(struct clk_init_data){
++		.name = "qdss_tsctr_clk_src",
++		.parent_names = gcc_xo_gpll4_gpll0_gpll6_gpll0_div2,
++		.num_parents = 5,
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_fixed_factor qdss_dap_sync_clk_src = {
++	.mult = 1,
++	.div = 4,
++	.hw.init = &(struct clk_init_data){
++		.name = "qdss_dap_sync_clk_src",
++		.parent_names = (const char *[]){
++			"qdss_tsctr_clk_src"
++		},
++		.num_parents = 1,
++		.ops = &clk_fixed_factor_ops,
++	},
++};
++
++struct freq_tbl ftbl_qdss_at_clk_src[] = {
++	F(66670000, P_GPLL0_DIV2, 6, 0, 0),
++	F(240000000, P_GPLL6, 6, 0, 0),
++	{ }
++};
++
++struct clk_rcg2 qdss_at_clk_src = {
++	.cmd_rcgr = 0x2900c,
++	.freq_tbl = ftbl_qdss_at_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll4_gpll0_gpll6_gpll0_div2_map,
++	.clkr.hw.init = &(struct clk_init_data){
++		.name = "qdss_at_clk_src",
++		.parent_names = gcc_xo_gpll4_gpll0_gpll6_gpll0_div2,
++		.num_parents = 5,
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++
++struct freq_tbl ftbl_adss_pwm_clk_src[] = {
++	F(19200000, P_XO, 1, 0, 0),
++	F(200000000, P_GPLL0, 4, 0, 0),
++	{ }
++};
++
++struct clk_rcg2 adss_pwm_clk_src = {
++	.cmd_rcgr = 0x1c008,
++	.freq_tbl = ftbl_adss_pwm_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data){
++		.name = "adss_pwm_clk_src",
++		.parent_names = gcc_xo_gpll0,
++		.num_parents = 2,
++		.ops = &clk_rcg2_ops,
++	},
++};
++
+ static struct clk_branch gcc_blsp1_ahb_clk = {
+ 	.halt_reg = 0x01008,
+ 	.clkr = {
+@@ -4344,13 +4438,7 @@ static struct clk_branch gcc_gp3_clk = {
+ 	},
+ };
+ 
+-static const struct freq_tbl ftbl_pcie_rchng_clk_src[] = {
+-	F(19200000, P_XO, 1, 0, 0),
+-	F(100000000, P_GPLL0, 8, 0, 0),
+-	{ }
+-};
+-
+-static struct clk_rcg2 pcie0_rchng_clk_src = {
++struct clk_rcg2 pcie0_rchng_clk_src = {
+ 	.cmd_rcgr = 0x75070,
+ 	.freq_tbl = ftbl_pcie_rchng_clk_src,
+ 	.hid_width = 5,
+@@ -4399,6 +4487,114 @@ static struct clk_branch gcc_pcie0_axi_s
+ 	},
+ };
+ 
++static struct clk_branch gcc_snoc_bus_timeout2_ahb_clk = {
++	.halt_reg = 0x4700c,
++	.halt_bit = 31,
++	.clkr = {
++		.enable_reg = 0x4700c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data){
++			.name = "gcc_snoc_bus_timeout2_ahb_clk",
++			.parent_names = (const char *[]){
++				"usb0_master_clk_src"
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_snoc_bus_timeout3_ahb_clk = {
++	.halt_reg = 0x47014,
++	.halt_bit = 31,
++	.clkr = {
++		.enable_reg = 0x47014,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data){
++			.name = "gcc_snoc_bus_timeout3_ahb_clk",
++			.parent_names = (const char *[]){
++				"usb1_master_clk_src"
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_dcc_clk = {
++	.halt_reg = 0x77004,
++	.halt_bit = 31,
++	.clkr = {
++		.enable_reg = 0x77004,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data){
++			.name = "gcc_dcc_clk",
++			.parent_names = (const char *[]){
++				"pcnoc_clk_src"
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qdss_at_clk = {
++	.halt_reg = 0x29024,
++	.halt_bit = 31,
++	.clkr = {
++		.enable_reg = 0x29024,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data){
++			.name = "gcc_qdss_at_clk",
++			.parent_names = (const char *[]){
++				"qdss_at_clk_src"
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qdss_dap_clk = {
++	.halt_reg = 0x29084,
++	.halt_bit = 31,
++	.clkr = {
++		.enable_reg = 0x29084,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data){
++			.name = "gcc_qdss_dap_clk",
++			.parent_names = (const char *[]){
++				"qdss_dap_sync_clk_src"
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_adss_pwm_clk = {
++	.halt_reg = 0x1c020,
++	.halt_bit = 31,
++	.clkr = {
++		.enable_reg = 0x1c020,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data){
++			.name = "gcc_adss_pwm_clk",
++			.parent_names = (const char *[]){
++				"adss_pwm_clk_src"
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
+ static struct clk_hw *gcc_ipq8074_hws[] = {
+ 	&gpll0_out_main_div2.hw,
+ 	&gpll6_out_main_div2.hw,
+@@ -4407,6 +4603,7 @@ static struct clk_hw *gcc_ipq8074_hws[]
+ 	&gcc_xo_div4_clk_src.hw,
+ 	&nss_noc_clk_src.hw,
+ 	&nss_ppe_cdiv_clk_src.hw,
++	&qdss_dap_sync_clk_src.hw,
+ };
+ 
+ static const struct alpha_pll_config ubi32_pll_config = {
+@@ -4665,6 +4862,15 @@ static struct clk_regmap *gcc_ipq8074_cl
+ 	[GCC_PCIE0_RCHNG_CLK_SRC] = &pcie0_rchng_clk_src.clkr,
+ 	[GCC_PCIE0_RCHNG_CLK] = &gcc_pcie0_rchng_clk.clkr,
+ 	[GCC_PCIE0_AXI_S_BRIDGE_CLK] = &gcc_pcie0_axi_s_bridge_clk.clkr,
++	[GCC_SNOC_BUS_TIMEOUT2_AHB_CLK] = &gcc_snoc_bus_timeout2_ahb_clk.clkr,
++	[GCC_SNOC_BUS_TIMEOUT3_AHB_CLK] = &gcc_snoc_bus_timeout3_ahb_clk.clkr,
++	[GCC_DCC_CLK] = &gcc_dcc_clk.clkr,
++	[QDSS_TSCTR_CLK_SRC] = &qdss_tsctr_clk_src.clkr,
++	[QDSS_AT_CLK_SRC] = &qdss_at_clk_src.clkr,
++	[GCC_QDSS_AT_CLK] = &gcc_qdss_at_clk.clkr,
++	[GCC_QDSS_DAP_CLK] = &gcc_qdss_dap_clk.clkr,
++	[ADSS_PWM_CLK_SRC] = &adss_pwm_clk_src.clkr,
++	[GCC_ADSS_PWM_CLK] = &gcc_adss_pwm_clk.clkr,
+ };
+ 
+ static const struct qcom_reset_map gcc_ipq8074_resets[] = {
+@@ -4801,6 +5007,20 @@ static const struct qcom_reset_map gcc_i
+ 	[GCC_PCIE1_AHB_ARES] = { 0x76040, 5 },
+ 	[GCC_PCIE1_AXI_MASTER_STICKY_ARES] = { 0x76040, 6 },
+ 	[GCC_WCSSAON_RESET] = { 0x59010, 0 },
++	[GCC_PPE_FULL_RESET] = { 0x68014, 0, 0xf0000},
++	[GCC_UNIPHY0_SOFT_RESET] = { 0x56004, 0, 0x3ff2},
++	[GCC_UNIPHY0_XPCS_RESET] = { 0x56004, 2 },
++	[GCC_UNIPHY1_SOFT_RESET] = { 0x56104, 0, 0x32},
++	[GCC_UNIPHY1_XPCS_RESET] = { 0x56104, 2 },
++	[GCC_UNIPHY2_SOFT_RESET] = { 0x56204, 0, 0x32},
++	[GCC_UNIPHY2_XPCS_RESET] = { 0x56204, 2 },
++	[GCC_EDMA_HW_RESET] = { 0x68014, 0, 0x300000},
++	[GCC_NSSPORT1_RESET] = { 0x68014, 0, 0x1000003},
++	[GCC_NSSPORT2_RESET] = { 0x68014, 0, 0x200000c},
++	[GCC_NSSPORT3_RESET] = { 0x68014, 0, 0x4000030},
++	[GCC_NSSPORT4_RESET] = { 0x68014, 0, 0x8000300},
++	[GCC_NSSPORT5_RESET] = { 0x68014, 0, 0x10000c00},
++	[GCC_NSSPORT6_RESET] = { 0x68014, 0, 0x20003000},
+ };
+ 
+ static const struct of_device_id gcc_ipq8074_match_table[] = {
+--- a/include/dt-bindings/clock/qcom,gcc-ipq8074.h
++++ b/include/dt-bindings/clock/qcom,gcc-ipq8074.h
+@@ -230,10 +230,19 @@
+ #define GCC_GP1_CLK				221
+ #define GCC_GP2_CLK				222
+ #define GCC_GP3_CLK				223
+-#define GCC_PCIE0_AXI_S_BRIDGE_CLK		224
+-#define GCC_PCIE0_RCHNG_CLK_SRC			225
+-#define GCC_PCIE0_RCHNG_CLK			226
+-#define GCC_CRYPTO_PPE_CLK 			227
++#define GCC_CRYPTO_PPE_CLK 			224
++#define GCC_PCIE0_RCHNG_CLK_SRC 		225
++#define GCC_PCIE0_RCHNG_CLK 			226
++#define GCC_PCIE0_AXI_S_BRIDGE_CLK 		227
++#define GCC_SNOC_BUS_TIMEOUT2_AHB_CLK 		228
++#define GCC_SNOC_BUS_TIMEOUT3_AHB_CLK 		229
++#define GCC_DCC_CLK 				230
++#define ADSS_PWM_CLK_SRC 			231
++#define GCC_ADSS_PWM_CLK 			232
++#define QDSS_TSCTR_CLK_SRC 			233
++#define QDSS_AT_CLK_SRC 			234
++#define GCC_QDSS_AT_CLK 			235
++#define GCC_QDSS_DAP_CLK 			236
+ 
+ #define GCC_BLSP1_BCR				0
+ #define GCC_BLSP1_QUP1_BCR			1
+@@ -368,5 +377,19 @@
+ #define GCC_PCIE1_AXI_MASTER_STICKY_ARES	130
+ #define GCC_PCIE0_AXI_SLAVE_STICKY_ARES		131
+ #define GCC_WCSSAON_RESET			132
++#define GCC_PPE_FULL_RESET			133
++#define GCC_UNIPHY0_SOFT_RESET			134
++#define GCC_UNIPHY0_XPCS_RESET			135
++#define GCC_UNIPHY1_SOFT_RESET			136
++#define GCC_UNIPHY1_XPCS_RESET			137
++#define GCC_UNIPHY2_SOFT_RESET			138
++#define GCC_UNIPHY2_XPCS_RESET			139
++#define GCC_EDMA_HW_RESET			140
++#define GCC_NSSPORT1_RESET			141
++#define GCC_NSSPORT2_RESET			142
++#define GCC_NSSPORT3_RESET			143
++#define GCC_NSSPORT4_RESET			144
++#define GCC_NSSPORT5_RESET			145
++#define GCC_NSSPORT6_RESET			146
+ 
+ #endif
diff --git a/target/linux/ipq807x/patches-5.10/127-clk-qcom-ipq8074-Fix-gcc_snoc_bus_timeout_ahb_clk-of.patch b/target/linux/ipq807x/patches-5.10/127-clk-qcom-ipq8074-Fix-gcc_snoc_bus_timeout_ahb_clk-of.patch
new file mode 100644
index 0000000..978aa4e
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/127-clk-qcom-ipq8074-Fix-gcc_snoc_bus_timeout_ahb_clk-of.patch
@@ -0,0 +1,44 @@
+From 462aa0c53397ec5bf78e3e7f68aa8a3ca300f4ba Mon Sep 17 00:00:00 2001
+From: Selvam Sathappan Periakaruppan <speriaka@codeaurora.org>
+Date: Tue, 24 Mar 2020 19:09:38 +0530
+Subject: [PATCH 5/8] clk: qcom: ipq8074: Fix gcc_snoc_bus_timeout_ahb_clk
+ offset
+
+By default, the ipq8074 V2 clks are provided in the gcc driver.
+Updating the gcc_snoc_bus_timeout_ahb_clk offsets also as needed
+in ipq8074 V2.
+
+Change-Id: I5a6e98d002f5c3354a804e55dd9ebb1f83f7f974
+Signed-off-by: Selvam Sathappan Periakaruppan <speriaka@codeaurora.org>
+---
+ drivers/clk/qcom/gcc-ipq8074.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -4488,10 +4488,10 @@ static struct clk_branch gcc_pcie0_axi_s
+ };
+ 
+ static struct clk_branch gcc_snoc_bus_timeout2_ahb_clk = {
+-	.halt_reg = 0x4700c,
++	.halt_reg = 0x47014,
+ 	.halt_bit = 31,
+ 	.clkr = {
+-		.enable_reg = 0x4700c,
++		.enable_reg = 0x47014,
+ 		.enable_mask = BIT(0),
+ 		.hw.init = &(struct clk_init_data){
+ 			.name = "gcc_snoc_bus_timeout2_ahb_clk",
+@@ -4506,10 +4506,10 @@ static struct clk_branch gcc_snoc_bus_ti
+ };
+ 
+ static struct clk_branch gcc_snoc_bus_timeout3_ahb_clk = {
+-	.halt_reg = 0x47014,
++	.halt_reg = 0x4701C,
+ 	.halt_bit = 31,
+ 	.clkr = {
+-		.enable_reg = 0x47014,
++		.enable_reg = 0x4701C,
+ 		.enable_mask = BIT(0),
+ 		.hw.init = &(struct clk_init_data){
+ 			.name = "gcc_snoc_bus_timeout3_ahb_clk",
diff --git a/target/linux/ipq807x/patches-5.10/128-qcom-clk-ipq8074-fix-port-6-clock-issue-for-1G.patch b/target/linux/ipq807x/patches-5.10/128-qcom-clk-ipq8074-fix-port-6-clock-issue-for-1G.patch
new file mode 100644
index 0000000..5f648d3
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/128-qcom-clk-ipq8074-fix-port-6-clock-issue-for-1G.patch
@@ -0,0 +1,35 @@
+From d4f5b0945dd4ec3638009fca0b4d13098155dca9 Mon Sep 17 00:00:00 2001
+From: zhongjia <zhongjia@codeaurora.org>
+Date: Thu, 13 Aug 2020 00:38:46 +0800
+Subject: [PATCH 6/8] qcom: clk: ipq8074: fix port 6 clock issue for 1G
+
+Change-Id: I279321a33f77404f75d4c60c607892df36fb25be
+Signed-off-by: zhongjia <zhongjia@codeaurora.org>
+---
+ drivers/clk/qcom/gcc-ipq8074.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -1889,8 +1889,10 @@ static struct clk_regmap_div nss_port5_t
+ 
+ static const struct freq_tbl ftbl_nss_port6_rx_clk_src[] = {
+ 	F(19200000, P_XO, 1, 0, 0),
++	F(25000000, P_UNIPHY2_RX, 5, 0, 0),
+ 	F(25000000, P_UNIPHY2_RX, 12.5, 0, 0),
+ 	F(78125000, P_UNIPHY2_RX, 4, 0, 0),
++	F(125000000, P_UNIPHY2_RX, 1, 0, 0),
+ 	F(125000000, P_UNIPHY2_RX, 2.5, 0, 0),
+ 	F(156250000, P_UNIPHY2_RX, 2, 0, 0),
+ 	F(312500000, P_UNIPHY2_RX, 1, 0, 0),
+@@ -1929,8 +1931,10 @@ static struct clk_regmap_div nss_port6_r
+ 
+ static const struct freq_tbl ftbl_nss_port6_tx_clk_src[] = {
+ 	F(19200000, P_XO, 1, 0, 0),
++	F(25000000, P_UNIPHY2_TX, 5, 0, 0),
+ 	F(25000000, P_UNIPHY2_TX, 12.5, 0, 0),
+ 	F(78125000, P_UNIPHY2_TX, 4, 0, 0),
++	F(125000000, P_UNIPHY2_TX, 1, 0, 0),
+ 	F(125000000, P_UNIPHY2_TX, 2.5, 0, 0),
+ 	F(156250000, P_UNIPHY2_TX, 2, 0, 0),
+ 	F(312500000, P_UNIPHY2_TX, 1, 0, 0),
diff --git a/target/linux/ipq807x/patches-5.10/129-clk-qcom-ipq8074-Add-NSS-PORT-clocks-frequencies.patch b/target/linux/ipq807x/patches-5.10/129-clk-qcom-ipq8074-Add-NSS-PORT-clocks-frequencies.patch
new file mode 100644
index 0000000..174db4b
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/129-clk-qcom-ipq8074-Add-NSS-PORT-clocks-frequencies.patch
@@ -0,0 +1,41 @@
+From 6cc04849eea4d87b3b274cc900c6a14a1ac866f5 Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Wed, 12 Jul 2017 21:42:11 +0530
+Subject: [PATCH 7/8] clk: qcom: ipq8074: Add NSS PORT clocks frequencies
+
+The port clock uses different frequency which depends upon
+ethernet PHY mode.
+
+Signed-off-by: Abhishek Sahu <absahu@codeaurora.org>
+(cherry picked from commit ae5f033e8929d0ffc34320c89b5683f801c3121c)
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+
+Change-Id: I7f5d24bc400b3c35d68ef08ae73ab8395b7dd87b
+---
+ drivers/clk/qcom/gcc-ipq8074.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -1810,8 +1810,10 @@ static struct clk_regmap_div nss_port4_t
+ static const struct freq_tbl ftbl_nss_port5_rx_clk_src[] = {
+ 	F(19200000, P_XO, 1, 0, 0),
+ 	F(25000000, P_UNIPHY1_RX, 12.5, 0, 0),
++	F(25000000, P_UNIPHY0_RX, 5, 0, 0),
+ 	F(78125000, P_UNIPHY1_RX, 4, 0, 0),
+ 	F(125000000, P_UNIPHY1_RX, 2.5, 0, 0),
++	F(125000000, P_UNIPHY0_RX, 1, 0, 0),
+ 	F(156250000, P_UNIPHY1_RX, 2, 0, 0),
+ 	F(312500000, P_UNIPHY1_RX, 1, 0, 0),
+ 	{ }
+@@ -1849,8 +1851,10 @@ static struct clk_regmap_div nss_port5_r
+ 
+ static const struct freq_tbl ftbl_nss_port5_tx_clk_src[] = {
+ 	F(19200000, P_XO, 1, 0, 0),
++	F(25000000, P_UNIPHY0_TX, 5, 0, 0),
+ 	F(25000000, P_UNIPHY1_TX, 12.5, 0, 0),
+ 	F(78125000, P_UNIPHY1_TX, 4, 0, 0),
++	F(125000000, P_UNIPHY0_TX, 1, 0, 0),
+ 	F(125000000, P_UNIPHY1_TX, 2.5, 0, 0),
+ 	F(156250000, P_UNIPHY1_TX, 2, 0, 0),
+ 	F(312500000, P_UNIPHY1_TX, 1, 0, 0),
diff --git a/target/linux/ipq807x/patches-5.10/130-clk-qcom-ipq8074-change-freq-table-for-port5_tx_clk_.patch b/target/linux/ipq807x/patches-5.10/130-clk-qcom-ipq8074-change-freq-table-for-port5_tx_clk_.patch
new file mode 100644
index 0000000..ad02baa
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/130-clk-qcom-ipq8074-change-freq-table-for-port5_tx_clk_.patch
@@ -0,0 +1,38 @@
+From be45ad064b7afdbc1e4f36c5a04c27cc364900c2 Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Tue, 7 Nov 2017 15:03:52 +0530
+Subject: [PATCH 8/8] clk: qcom: ipq8074: change freq table for
+ port5_tx_clk_src
+
+Originally QCOM clock framework assumes that there will be
+only one entry for each freq but in port5, the same freq can be
+supplied by 2 sources, uniphy0 and uniphy1. We need to move
+uniphy1 above uniphy0 in frequency table so that uniphy1 will be
+selected instead of uniphy0 if uniphy0 is running in
+125 Mhz and uniphy1 is running in 312 Mhz.
+
+Signed-off-by: Abhishek Sahu <absahu@codeaurora.org>
+(cherry picked from commit 559fcf09e9681f7d1fcbd981a5de7957ffb3e496)
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+
+Change-Id: I91c17714922afc1ef4cdb5e6e47e2e813e2e9777
+---
+ drivers/clk/qcom/gcc-ipq8074.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -1851,11 +1851,11 @@ static struct clk_regmap_div nss_port5_r
+ 
+ static const struct freq_tbl ftbl_nss_port5_tx_clk_src[] = {
+ 	F(19200000, P_XO, 1, 0, 0),
+-	F(25000000, P_UNIPHY0_TX, 5, 0, 0),
+ 	F(25000000, P_UNIPHY1_TX, 12.5, 0, 0),
++	F(25000000, P_UNIPHY0_TX, 5, 0, 0),
+ 	F(78125000, P_UNIPHY1_TX, 4, 0, 0),
+-	F(125000000, P_UNIPHY0_TX, 1, 0, 0),
+ 	F(125000000, P_UNIPHY1_TX, 2.5, 0, 0),
++	F(125000000, P_UNIPHY0_TX, 1, 0, 0),
+ 	F(156250000, P_UNIPHY1_TX, 2, 0, 0),
+ 	F(312500000, P_UNIPHY1_TX, 1, 0, 0),
+ 	{ }
diff --git a/target/linux/ipq807x/patches-5.10/131-arm64-dts-ipq8074-add-SPMI-bus.patch b/target/linux/ipq807x/patches-5.10/131-arm64-dts-ipq8074-add-SPMI-bus.patch
new file mode 100644
index 0000000..bdfbff2
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/131-arm64-dts-ipq8074-add-SPMI-bus.patch
@@ -0,0 +1,41 @@
+From 43d5a2b56802327a27a3acb30eb1e458959f5794 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Thu, 13 May 2021 11:14:02 +0200
+Subject: [PATCH] arm64: dts: ipq8074: add SPMI bus
+
+IPQ8074 has a SPMI v2 arbiter, so add the node
+for it.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 19 +++++++++++++++++++
+ 1 file changed, 19 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -390,6 +390,25 @@
+ 			#reset-cells = <0x1>;
+ 		};
+ 
++		spmi_bus: qcom,spmi@200f000 {
++			compatible = "qcom,spmi-pmic-arb";
++			reg = <0x200f000 0x1000>,
++				<0x2400000 0x800000>,
++				<0x2c00000 0x800000>,
++				<0x3800000 0x200000>,
++				<0x200a000 0x000700>;
++			reg-names = "core", "chnls", "obsrvr", "intr", "cnfg";
++			interrupts = <GIC_SPI 190 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-names = "periph_irq";
++			qcom,ee = <0>;
++			qcom,channel = <0>;
++			#address-cells = <2>;
++			#size-cells = <0>;
++			interrupt-controller;
++			#interrupt-cells = <4>;
++			cell-index = <0>;
++		};
++
+ 		sdhc_1: sdhci@7824900 {
+ 			compatible = "qcom,sdhci-msm-v4";
+ 			reg = <0x7824900 0x500>, <0x7824000 0x800>;
diff --git a/target/linux/ipq807x/patches-5.10/132-regulator-qcom_spmi-Add-PMD9655-SPMI-regulator.patch b/target/linux/ipq807x/patches-5.10/132-regulator-qcom_spmi-Add-PMD9655-SPMI-regulator.patch
new file mode 100644
index 0000000..6b3ca0e
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/132-regulator-qcom_spmi-Add-PMD9655-SPMI-regulator.patch
@@ -0,0 +1,38 @@
+From 43361c2201bc9b67ee42a6afab7a3a476eaf6156 Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Tue, 31 Mar 2020 22:00:27 +0530
+Subject: [PATCH 1/6] regulator: qcom_spmi: Add PMD9655 SPMI regulator
+
+PMD9655 is used in IPQ8074 and provides S3 for cores,
+S4 for UBI core and LDO11 for SDIO/eMMC.
+
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ drivers/regulator/qcom_spmi-regulator.c | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+--- a/drivers/regulator/qcom_spmi-regulator.c
++++ b/drivers/regulator/qcom_spmi-regulator.c
+@@ -2082,6 +2082,13 @@ static const struct spmi_regulator_data
+ 	{ }
+ };
+ 
++static const struct spmi_regulator_data pmd9655_regulators[] = {
++	{ "s3", 0x1a00, "vdd_s3",},
++	{ "s4", 0x1d00, "vdd_s4",},
++	{ "ldo11", 0x4a00, "vdd_ldo11",},
++	{ }
++};
++
+ static const struct of_device_id qcom_spmi_regulator_match[] = {
+ 	{ .compatible = "qcom,pm8004-regulators", .data = &pm8004_regulators },
+ 	{ .compatible = "qcom,pm8005-regulators", .data = &pm8005_regulators },
+@@ -2094,6 +2101,7 @@ static const struct of_device_id qcom_sp
+ 	{ .compatible = "qcom,pm660-regulators", .data = &pm660_regulators },
+ 	{ .compatible = "qcom,pm660l-regulators", .data = &pm660l_regulators },
+ 	{ .compatible = "qcom,pms405-regulators", .data = &pms405_regulators },
++	{ .compatible = "qcom,pmd9655-regulators", .data = &pmd9655_regulators },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(of, qcom_spmi_regulator_match);
diff --git a/target/linux/ipq807x/patches-5.10/133-regulator-qcom_spmi-SMPS-range-is-added-to-support-P.patch b/target/linux/ipq807x/patches-5.10/133-regulator-qcom_spmi-SMPS-range-is-added-to-support-P.patch
new file mode 100644
index 0000000..06628ad
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/133-regulator-qcom_spmi-SMPS-range-is-added-to-support-P.patch
@@ -0,0 +1,22 @@
+From 095567c1736af28ef6b472e2ab728a2222a425da Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Mon, 4 May 2020 19:31:00 +0530
+Subject: [PATCH 2/6] regulator: qcom_spmi: SMPS range is added to support
+ PMD9655 PMIC
+
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+Change-Id: I5571801debec25527fd763d95aff27cc42f53bde
+---
+ drivers/regulator/qcom_spmi-regulator.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/regulator/qcom_spmi-regulator.c
++++ b/drivers/regulator/qcom_spmi-regulator.c
+@@ -480,6 +480,7 @@ static struct spmi_voltage_range ln_ldo_
+ };
+ 
+ static struct spmi_voltage_range smps_ranges[] = {
++	SPMI_VOLTAGE_RANGE(2,  670000,  670000, 990000,  990000,  8000),
+ 	SPMI_VOLTAGE_RANGE(0,  375000,  375000, 1562500, 1562500, 12500),
+ 	SPMI_VOLTAGE_RANGE(1, 1550000, 1575000, 3125000, 3125000, 25000),
+ };
diff --git a/target/linux/ipq807x/patches-5.10/134-regulator-qcom_spmi-Initialize-slew-rate-only-if-req.patch b/target/linux/ipq807x/patches-5.10/134-regulator-qcom_spmi-Initialize-slew-rate-only-if-req.patch
new file mode 100644
index 0000000..b7fd176
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/134-regulator-qcom_spmi-Initialize-slew-rate-only-if-req.patch
@@ -0,0 +1,35 @@
+From 0890aba3f364ed0764fdfa79bd77db130396e594 Mon Sep 17 00:00:00 2001
+From: PRAVEENKUMAR I <ipkumar@codeaurora.org>
+Date: Tue, 5 May 2020 07:57:21 +0530
+Subject: [PATCH 3/6] regulator: qcom_spmi: Initialize slew rate only if
+ required
+
+Initialize slew rate only if set_voltage_time_sel in ops
+is defined.
+
+Change-Id: I661c88d2f4a8f26cc85b1e2d4c8aa3170420ba6c
+Signed-off-by: Rajith Cherian <rajith@codeaurora.org>
+(cherry picked from commit 608a6f171ef4017197fbe2069b5910b582923027)
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+
+Change-Id: Ida3cf3d754e1207e34a164d6d86c6e1aa109ef1e
+---
+ drivers/regulator/qcom_spmi-regulator.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+--- a/drivers/regulator/qcom_spmi-regulator.c
++++ b/drivers/regulator/qcom_spmi-regulator.c
+@@ -1610,6 +1610,13 @@ static int spmi_regulator_init_slew_rate
+ 	int step, delay, slew_rate, step_delay;
+ 	const struct spmi_voltage_range *range;
+ 
++	/*
++	 * Slew rate need not be initialized if
++	 * set_voltage_time_sel in the ops is not defined.
++	 */
++	if (!vreg->desc.ops->set_voltage_time_sel)
++		return 0;
++
+ 	ret = spmi_vreg_read(vreg, SPMI_COMMON_REG_STEP_CTRL, &reg, 1);
+ 	if (ret) {
+ 		dev_err(vreg->dev, "spmi read failed, ret=%d\n", ret);
diff --git a/target/linux/ipq807x/patches-5.10/135-regulator-qcom_spmi-Add-support-for-VMPWM_CTL-subtyp.patch b/target/linux/ipq807x/patches-5.10/135-regulator-qcom_spmi-Add-support-for-VMPWM_CTL-subtyp.patch
new file mode 100644
index 0000000..0b36cee
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/135-regulator-qcom_spmi-Add-support-for-VMPWM_CTL-subtyp.patch
@@ -0,0 +1,159 @@
+From 50b5c040b8c1928990baad8e07126df63aa09cce Mon Sep 17 00:00:00 2001
+From: PRAVEENKUMAR I <ipkumar@codeaurora.org>
+Date: Tue, 5 May 2020 07:57:52 +0530
+Subject: [PATCH 4/6] regulator: qcom_spmi: Add support for VMPWM_CTL subtype
+
+Support for Voltage Mode PWM Controller (VMPWM_CTL).
+Set/Get microvolts functions added. Function to find the
+voltage range for this particular subtype added.
+
+Change-Id: Ib4bf35ee65de17a917f01e63208368c7770401d4
+Signed-off-by: Rajith Cherian <rajith@codeaurora.org>
+(cherry picked from commit 31e7e4183b5afaf18dbca3548f4988c420ebb58b)
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+
+Change-Id: Id7a3caef84499b9e2eefda9f57576923c84234f0
+---
+ drivers/regulator/qcom_spmi-regulator.c | 82 +++++++++++++++++++++++++
+ 1 file changed, 82 insertions(+)
+
+--- a/drivers/regulator/qcom_spmi-regulator.c
++++ b/drivers/regulator/qcom_spmi-regulator.c
+@@ -163,6 +163,7 @@ enum spmi_regulator_subtype {
+ 	SPMI_REGULATOR_SUBTYPE_ULT_HF_CTL3	= 0x0f,
+ 	SPMI_REGULATOR_SUBTYPE_ULT_HF_CTL4	= 0x10,
+ 	SPMI_REGULATOR_SUBTYPE_HFS430		= 0x0a,
++	SPMI_REGULATOR_SUBTYPE_VMPWM_CTL	= 0x0a,
+ };
+ 
+ enum spmi_common_regulator_registers {
+@@ -288,6 +289,10 @@ enum spmi_common_control_register_index
+ #define SPMI_FTSMPS_STEP_CTRL_DELAY_MASK	0x07
+ #define SPMI_FTSMPS_STEP_CTRL_DELAY_SHIFT	0
+ 
++#define SPMI_SMPS_VMPWM_VSET_UB_SHIFT		8
++#define SPMI_SMPS_VMPWM_VSET_UB_MASK		0xf00
++#define SPMI_SMPS_VMPWM_VSET_LB_MASK		0xff
++
+ /* Clock rate in kHz of the FTSMPS regulator reference clock. */
+ #define SPMI_FTSMPS_CLOCK_RATE		19200
+ 
+@@ -485,6 +490,10 @@ static struct spmi_voltage_range smps_ra
+ 	SPMI_VOLTAGE_RANGE(1, 1550000, 1575000, 3125000, 3125000, 25000),
+ };
+ 
++static struct spmi_voltage_range smps_vmpwm_ranges[] = {
++	SPMI_VOLTAGE_RANGE(0,  664000,  664000, 1104000, 1104000, 8000),
++};
++
+ static struct spmi_voltage_range ftsmps_ranges[] = {
+ 	SPMI_VOLTAGE_RANGE(0,       0,  350000, 1275000, 1275000,  5000),
+ 	SPMI_VOLTAGE_RANGE(1,       0, 1280000, 2040000, 2040000, 10000),
+@@ -550,6 +559,7 @@ static DEFINE_SPMI_SET_POINTS(nldo2);
+ static DEFINE_SPMI_SET_POINTS(nldo3);
+ static DEFINE_SPMI_SET_POINTS(ln_ldo);
+ static DEFINE_SPMI_SET_POINTS(smps);
++static DEFINE_SPMI_SET_POINTS(smps_vmpwm);
+ static DEFINE_SPMI_SET_POINTS(ftsmps);
+ static DEFINE_SPMI_SET_POINTS(ftsmps2p5);
+ static DEFINE_SPMI_SET_POINTS(ftsmps426);
+@@ -740,6 +750,24 @@ spmi_regulator_find_range(struct spmi_re
+ 	return NULL;
+ }
+ 
++static const struct spmi_voltage_range *
++spmi_regulator_find_uV_range(struct spmi_regulator *vreg, int min, int max)
++{
++	const struct spmi_voltage_range *range, *end;
++
++	if (!vreg->set_points || !vreg->set_points->count)
++		return 0;
++
++	range = vreg->set_points->range;
++	end = range + vreg->set_points->count;
++
++	for (; range < end; range++)
++		if ((range->min_uV <= min) && (range->max_uV >= max))
++			return range;
++
++	return 0;
++}
++
+ static int spmi_regulator_select_voltage_same_range(struct spmi_regulator *vreg,
+ 		int min_uV, int max_uV)
+ {
+@@ -961,6 +989,47 @@ static int spmi_regulator_ult_lo_smps_ge
+ 	return spmi_hw_selector_to_sw(vreg, voltage_sel, range);
+ }
+ 
++static int spmi_regulator_smps_vmpwm_set_vol_uV(struct regulator_dev *rdev,
++				int min_uV, int max_uV, unsigned *selector)
++{
++	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
++	const struct spmi_voltage_range *range;
++	int req_vol;
++	u8 reg[2];
++
++	range = spmi_regulator_find_uV_range(vreg, min_uV, max_uV);
++	if (!range)
++		return -EINVAL;
++
++	*selector = spmi_regulator_select_voltage(vreg, min_uV, max_uV);
++	req_vol = range->set_point_min_uV + (range->step_uV * (*selector));
++
++	/* Convert uV to mV as the register supports mV */
++	req_vol = req_vol/1000;
++
++	/*
++	 * Voltage set point bits<7:0>. 2-Byte Word (lower byte word)
++	 */
++	reg[0] = req_vol & SPMI_SMPS_VMPWM_VSET_LB_MASK;
++	/*
++	 * Voltage set point bit <11:8>. 2-Byte Word (upper byte word)
++	 */
++	reg[1] = (req_vol & SPMI_SMPS_VMPWM_VSET_UB_MASK)
++			>> SPMI_SMPS_VMPWM_VSET_UB_SHIFT;
++
++	return spmi_vreg_write(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, reg, 2);
++}
++
++static int spmi_regulator_smps_vmpwm_get_vol_uV(struct regulator_dev *rdev)
++{
++	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
++	u8 reg[2];
++
++	spmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, reg, 2);
++
++	return ((reg[1] << SPMI_SMPS_VMPWM_VSET_UB_SHIFT) | reg[0]) * 1000;
++}
++
+ static int spmi_regulator_common_list_voltage(struct regulator_dev *rdev,
+ 			unsigned selector)
+ {
+@@ -1309,6 +1378,18 @@ static const struct regulator_ops spmi_s
+ 	.set_pull_down		= spmi_regulator_common_set_pull_down,
+ };
+ 
++static const struct regulator_ops spmi_smps_vmpwm_ops = {
++	.enable			= regulator_enable_regmap,
++	.disable		= regulator_disable_regmap,
++	.is_enabled		= regulator_is_enabled_regmap,
++	.set_voltage		= spmi_regulator_smps_vmpwm_set_vol_uV,
++	.get_voltage		= spmi_regulator_smps_vmpwm_get_vol_uV,
++	.map_voltage		= spmi_regulator_common_map_voltage,
++	.list_voltage		= spmi_regulator_common_list_voltage,
++	.set_mode		= spmi_regulator_common_set_mode,
++	.get_mode		= spmi_regulator_common_get_mode,
++};
++
+ static const struct regulator_ops spmi_ldo_ops = {
+ 	.enable			= regulator_enable_regmap,
+ 	.disable		= regulator_disable_regmap,
+@@ -1454,6 +1535,7 @@ static const struct regulator_ops spmi_h
+ 
+ static const struct spmi_regulator_mapping supported_regulators[] = {
+ 	/*           type subtype dig_min dig_max ltype ops setpoints hpm_min */
++	SPMI_VREG(BUCK,  VMPWM_CTL, 0, INF, SMPS, smps_vmpwm, smps_vmpwm, 0),
+ 	SPMI_VREG(BUCK,  GP_CTL,   0, INF, SMPS,   smps,   smps,   100000),
+ 	SPMI_VREG(BUCK,  HFS430,   0, INF, HFS430, hfs430, hfs430,  10000),
+ 	SPMI_VREG(LDO,   N300,     0, INF, LDO,    ldo,    nldo1,   10000),
diff --git a/target/linux/ipq807x/patches-5.10/136-ipq807x-sdhc-Fixed-SDR104-mode-card-detection.patch b/target/linux/ipq807x/patches-5.10/136-ipq807x-sdhc-Fixed-SDR104-mode-card-detection.patch
new file mode 100644
index 0000000..30519f3
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/136-ipq807x-sdhc-Fixed-SDR104-mode-card-detection.patch
@@ -0,0 +1,53 @@
+From 84d0ae645dc1c3d8726bf8cd482be052f915f00b Mon Sep 17 00:00:00 2001
+From: Vasudevan Murugesan <vmuruges@codeaurora.org>
+Date: Thu, 8 Jun 2017 19:13:48 +0530
+Subject: [PATCH 5/6] ipq807x: sdhc: Fixed SDR104 mode card detection
+
+Change-Id: I353356284d28d09d79bf7d318c4ebcdbc15e5b02
+Signed-off-by: Vasudevan Murugesan <vmuruges@codeaurora.org>
+Signed-off-by: Saravanan Jaganathan <sjaganat@codeaurora.org>
+(cherry picked from commit 080d3f390aa409ef2b5adf59a175b6bb2aa863fd)
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+
+Change-Id: Ie5edb7b3d972e06f3eb2525e10597b49e9bae14d
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi   | 1 -
+ drivers/regulator/qcom_spmi-regulator.c | 3 +++
+ 2 files changed, 3 insertions(+), 1 deletion(-)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -430,7 +430,6 @@
+ 
+ 			status = "disabled";
+ 		};
+-
+ 		blsp_dma: dma@7884000 {
+ 			compatible = "qcom,bam-v1.7.0";
+ 			reg = <0x07884000 0x2b000>;
+--- a/drivers/regulator/qcom_spmi-regulator.c
++++ b/drivers/regulator/qcom_spmi-regulator.c
+@@ -164,6 +164,7 @@ enum spmi_regulator_subtype {
+ 	SPMI_REGULATOR_SUBTYPE_ULT_HF_CTL4	= 0x10,
+ 	SPMI_REGULATOR_SUBTYPE_HFS430		= 0x0a,
+ 	SPMI_REGULATOR_SUBTYPE_VMPWM_CTL	= 0x0a,
++	SPMI_REGULATOR_SUBTYPE_HT_P150		= 0x35,
+ };
+ 
+ enum spmi_common_regulator_registers {
+@@ -492,6 +493,7 @@ static struct spmi_voltage_range smps_ra
+ 
+ static struct spmi_voltage_range smps_vmpwm_ranges[] = {
+ 	SPMI_VOLTAGE_RANGE(0,  664000,  664000, 1104000, 1104000, 8000),
++	SPMI_VOLTAGE_RANGE(1,  1104000, 1104000, 3300000, 3300000, 8000),
+ };
+ 
+ static struct spmi_voltage_range ftsmps_ranges[] = {
+@@ -1535,6 +1537,7 @@ static const struct regulator_ops spmi_h
+ 
+ static const struct spmi_regulator_mapping supported_regulators[] = {
+ 	/*           type subtype dig_min dig_max ltype ops setpoints hpm_min */
++	SPMI_VREG(LDO,  HT_P150, 0, INF, LDO, smps_vmpwm, smps_vmpwm, 0),
+ 	SPMI_VREG(BUCK,  VMPWM_CTL, 0, INF, SMPS, smps_vmpwm, smps_vmpwm, 0),
+ 	SPMI_VREG(BUCK,  GP_CTL,   0, INF, SMPS,   smps,   smps,   100000),
+ 	SPMI_VREG(BUCK,  HFS430,   0, INF, HFS430, hfs430, hfs430,  10000),
diff --git a/target/linux/ipq807x/patches-5.10/137-ipq807x-spmi-regulator-Add-separate-voltage-range-fo.patch b/target/linux/ipq807x/patches-5.10/137-ipq807x-spmi-regulator-Add-separate-voltage-range-fo.patch
new file mode 100644
index 0000000..4e4b3f1
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/137-ipq807x-spmi-regulator-Add-separate-voltage-range-fo.patch
@@ -0,0 +1,49 @@
+From c603c7a1e2d5cc432d8e1250baff8130755a6f43 Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Mon, 13 Jul 2020 18:13:48 +0530
+Subject: [PATCH 6/6] ipq807x: spmi regulator: Add separate voltage range for
+ LDO
+
+When LDO voltage range added in SMPS voltage range structure,
+selector value used during set voltage is wrongly calculated.
+Because the SMPS voltage range is also taken into account for LDO.
+
+So, a separate voltage range structure is introduced for LDO.
+
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+Change-Id: I883518ae0686762a3774750b1dd480c4fe7298f3
+---
+ drivers/regulator/qcom_spmi-regulator.c | 8 ++++++--
+ 1 file changed, 6 insertions(+), 2 deletions(-)
+
+--- a/drivers/regulator/qcom_spmi-regulator.c
++++ b/drivers/regulator/qcom_spmi-regulator.c
+@@ -493,7 +493,10 @@ static struct spmi_voltage_range smps_ra
+ 
+ static struct spmi_voltage_range smps_vmpwm_ranges[] = {
+ 	SPMI_VOLTAGE_RANGE(0,  664000,  664000, 1104000, 1104000, 8000),
+-	SPMI_VOLTAGE_RANGE(1,  1104000, 1104000, 3300000, 3300000, 8000),
++};
++
++static struct spmi_voltage_range ldo_vmpwm_ranges[] = {
++	SPMI_VOLTAGE_RANGE(0,  1104000, 1104000, 3300000, 3300000, 8000),
+ };
+ 
+ static struct spmi_voltage_range ftsmps_ranges[] = {
+@@ -562,6 +565,7 @@ static DEFINE_SPMI_SET_POINTS(nldo3);
+ static DEFINE_SPMI_SET_POINTS(ln_ldo);
+ static DEFINE_SPMI_SET_POINTS(smps);
+ static DEFINE_SPMI_SET_POINTS(smps_vmpwm);
++static DEFINE_SPMI_SET_POINTS(ldo_vmpwm);
+ static DEFINE_SPMI_SET_POINTS(ftsmps);
+ static DEFINE_SPMI_SET_POINTS(ftsmps2p5);
+ static DEFINE_SPMI_SET_POINTS(ftsmps426);
+@@ -1537,7 +1541,7 @@ static const struct regulator_ops spmi_h
+ 
+ static const struct spmi_regulator_mapping supported_regulators[] = {
+ 	/*           type subtype dig_min dig_max ltype ops setpoints hpm_min */
+-	SPMI_VREG(LDO,  HT_P150, 0, INF, LDO, smps_vmpwm, smps_vmpwm, 0),
++	SPMI_VREG(LDO,  HT_P150, 0, INF, LDO, smps_vmpwm, ldo_vmpwm, 0),
+ 	SPMI_VREG(BUCK,  VMPWM_CTL, 0, INF, SMPS, smps_vmpwm, smps_vmpwm, 0),
+ 	SPMI_VREG(BUCK,  GP_CTL,   0, INF, SMPS,   smps,   smps,   100000),
+ 	SPMI_VREG(BUCK,  HFS430,   0, INF, HFS430, hfs430, hfs430,  10000),
diff --git a/target/linux/ipq807x/patches-5.10/138-arm64-dts-ipq8074-add-SPMI-PMIC-regulators.patch b/target/linux/ipq807x/patches-5.10/138-arm64-dts-ipq8074-add-SPMI-PMIC-regulators.patch
new file mode 100644
index 0000000..ee723f2
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/138-arm64-dts-ipq8074-add-SPMI-PMIC-regulators.patch
@@ -0,0 +1,84 @@
+From df848f06020c609950107f87c39f41e7eee92b5e Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Thu, 13 May 2021 11:54:35 +0200
+Subject: [PATCH] arm64: dts: ipq8074: add SPMI PMIC regulators
+
+PMD9655 is used in IPQ8074 and provides S3 for cores,
+S4 for UBI core and LDO11 for SDIO/eMMC.
+
+So, lets add the nodes in preparation for DVFS later.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 46 +++++++++++++++++++++++++++
+ 1 file changed, 46 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -5,6 +5,7 @@
+ 
+ #include <dt-bindings/interrupt-controller/arm-gic.h>
+ #include <dt-bindings/clock/qcom,gcc-ipq8074.h>
++#include <dt-bindings/spmi/spmi.h>
+ 
+ / {
+ 	model = "Qualcomm Technologies, Inc. IPQ8074";
+@@ -136,6 +137,15 @@
+ 		};
+ 	};
+ 
++	e_smps1_reg: fixed-regulator@0 {
++		compatible = "regulator-fixed";
++		regulator-name = "e-smps1-reg";
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-always-on;
++		regulator-boot-on;
++	};
++
+ 	soc: soc {
+ 		#address-cells = <0x1>;
+ 		#size-cells = <0x1>;
+@@ -407,6 +417,42 @@
+ 			interrupt-controller;
+ 			#interrupt-cells = <4>;
+ 			cell-index = <0>;
++
++			pmic@1 {
++				compatible ="qcom,spmi-pmic";
++				reg = <0x1 SPMI_USID>;
++				#address-cells = <1>;
++				#size-cells = <0>;
++
++				regulators {
++					compatible = "qcom,pmd9655-regulators";
++					vdd_s3-supply = <&e_smps1_reg>;
++					vdd_s4-supply = <&e_smps1_reg>;
++					vdd_ldo11-supply = <&e_smps1_reg>;
++
++					s3: s3 {
++						regulator-name = "pmd9655_s3";
++						regulator-min-microvolt = <592000>;
++						regulator-max-microvolt = <1064000>;
++						regulator-always-on;
++						regulator-boot-on;
++					};
++
++					s4: s4 {
++						regulator-name = "pmd9655_s4";
++						regulator-min-microvolt = <712000>;
++						regulator-max-microvolt = <992000>;
++						regulator-always-on;
++						regulator-boot-on;
++					};
++
++					ldo11: ldo11 {
++						regulator-name = "pmd9655_ldo11";
++						regulator-min-microvolt = <1104000>;
++						regulator-max-microvolt = <3300000>;
++					};
++				};
++			};
+ 		};
+ 
+ 		sdhc_1: sdhci@7824900 {
diff --git a/target/linux/ipq807x/patches-5.10/139-ipq8074-clk-apss-Added-APSS-clock-driver.patch b/target/linux/ipq807x/patches-5.10/139-ipq8074-clk-apss-Added-APSS-clock-driver.patch
new file mode 100644
index 0000000..287c4cf
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/139-ipq8074-clk-apss-Added-APSS-clock-driver.patch
@@ -0,0 +1,328 @@
+From 6961b02dd2765b71b201f065172998a16ff9c2eb Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Sun, 22 Mar 2020 20:22:29 +0530
+Subject: [PATCH 1/3] ipq8074: clk: apss: Added APSS clock driver
+
+apss-ipq8074 files are snapshot form eggplant branch,
+https://source.codeaurora.org/quic/qsdk/oss/kernel/linux-ipq-5.4/commit/?h=keggplant/eggplant&id=f2fb70e8315ef1c450171e59d681c6a156b1a4e8
+
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+Change-Id: I17ecad1f1731c88d8d91485d5d5f8a38b76f7104
+---
+ drivers/clk/qcom/Kconfig                     |   7 +
+ drivers/clk/qcom/Makefile                    |   1 +
+ drivers/clk/qcom/apss-ipq8074.c              | 210 +++++++++++++++++++
+ drivers/clk/qcom/clk-alpha-pll.c             |  12 ++
+ drivers/clk/qcom/clk-alpha-pll.h             |   3 +
+ include/dt-bindings/clock/qca,apss-ipq8074.h |  25 +++
+ 6 files changed, 258 insertions(+)
+ create mode 100644 drivers/clk/qcom/apss-ipq8074.c
+ create mode 100644 include/dt-bindings/clock/qca,apss-ipq8074.h
+
+--- a/drivers/clk/qcom/Kconfig
++++ b/drivers/clk/qcom/Kconfig
+@@ -155,6 +155,13 @@ config IPQ_GCC_8074
+ 	  i2c, USB, SD/eMMC, etc. Select this for the root clock
+ 	  of ipq8074.
+ 
++config IPQ_APSS_8074
++        tristate "IPQ8074 APSS Clock Controller"
++        select IPQ_GCC_8074
++        help
++          Support for APSS clock controller on ipq8074 devices.
++          Say Y if you want to use APSS clocks such as CPU.
++
+ config MSM_GCC_8660
+ 	tristate "MSM8660 Global Clock Controller"
+ 	help
+--- a/drivers/clk/qcom/Makefile
++++ b/drivers/clk/qcom/Makefile
+@@ -25,6 +25,7 @@ obj-$(CONFIG_IPQ_GCC_4019) += gcc-ipq401
+ obj-$(CONFIG_IPQ_GCC_6018) += gcc-ipq6018.o
+ obj-$(CONFIG_IPQ_GCC_806X) += gcc-ipq806x.o
+ obj-$(CONFIG_IPQ_GCC_8074) += gcc-ipq8074.o
++obj-$(CONFIG_IPQ_APSS_8074) += apss-ipq8074.o
+ obj-$(CONFIG_IPQ_LCC_806X) += lcc-ipq806x.o
+ obj-$(CONFIG_MDM_GCC_9615) += gcc-mdm9615.o
+ obj-$(CONFIG_MDM_LCC_9615) += lcc-mdm9615.o
+--- /dev/null
++++ b/drivers/clk/qcom/apss-ipq8074.c
+@@ -0,0 +1,210 @@
++/*
++ * Copyright (c) 2017,2020. The Linux Foundation. All rights reserved.
++ *
++ * Permission to use, copy, modify, and/or distribute this software for any
++ * purpose with or without fee is hereby granted, provided that the above
++ * copyright notice and this permission notice appear in all copies.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
++ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ */
++
++#include <linux/kernel.h>
++#include <linux/err.h>
++#include <linux/platform_device.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/clk-provider.h>
++#include <linux/regmap.h>
++
++#include <linux/reset-controller.h>
++#include <dt-bindings/clock/qca,apss-ipq8074.h>
++
++#include "common.h"
++#include "clk-regmap.h"
++#include "clk-pll.h"
++#include "clk-rcg.h"
++#include "clk-branch.h"
++#include "clk-alpha-pll.h"
++#include "clk-regmap-divider.h"
++#include "clk-regmap-mux.h"
++#include "reset.h"
++
++#define F(f, s, h, m, n) { (f), (s), (2 * (h) - 1), (m), (n) }
++
++enum {
++	P_XO,
++	P_GPLL0,
++	P_GPLL2,
++	P_GPLL4,
++	P_APSS_PLL_EARLY,
++	P_APSS_PLL
++};
++
++static struct clk_alpha_pll apss_pll_early = {
++	.offset = 0x5000,
++	.regs = clk_alpha_pll_regs[CLK_ALPHA_PLL_TYPE_APSS],
++	.clkr = {
++		.enable_reg = 0x5000,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data){
++			.name = "apss_pll_early",
++			.parent_names = (const char *[]){
++				"xo"
++			},
++			.num_parents = 1,
++			.ops = &clk_alpha_pll_huayra_ops,
++		},
++	},
++};
++
++static struct clk_alpha_pll_postdiv apss_pll = {
++	.offset = 0x5000,
++	.regs = clk_alpha_pll_regs[CLK_ALPHA_PLL_TYPE_APSS],
++	.width = 2,
++	.clkr.hw.init = &(struct clk_init_data){
++		.name = "apss_pll",
++		.parent_names = (const char *[]){ "apss_pll_early" },
++		.num_parents = 1,
++		.ops = &clk_alpha_pll_postdiv_ro_ops,
++	},
++};
++
++static const char * const parents_apcs_alias0_clk_src[] = {
++	"xo",
++	"gpll0",
++	"gpll2",
++	"gpll4",
++	"apss_pll",
++	"apss_pll_early",
++};
++
++static const struct parent_map parents_apcs_alias0_clk_src_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 4 },
++	{ P_GPLL2, 2 },
++	{ P_GPLL4, 1 },
++	{ P_APSS_PLL, 3 },
++	{ P_APSS_PLL_EARLY, 5 },
++};
++
++struct freq_tbl ftbl_apcs_alias0_clk_src[] = {
++	F(19200000, P_XO, 1, 0, 0),
++	F(403200000, P_APSS_PLL_EARLY, 1, 0, 0),
++	F(806400000, P_APSS_PLL_EARLY, 1, 0, 0),
++	F(1017600000, P_APSS_PLL_EARLY, 1, 0, 0),
++	F(1382400000, P_APSS_PLL_EARLY, 1, 0, 0),
++	F(1651200000, P_APSS_PLL_EARLY, 1, 0, 0),
++	F(1843200000, P_APSS_PLL_EARLY, 1, 0, 0),
++	F(1920000000, P_APSS_PLL_EARLY, 1, 0, 0),
++	F(2208000000UL, P_APSS_PLL_EARLY, 1, 0, 0),
++	{ }
++};
++
++struct clk_rcg2 apcs_alias0_clk_src = {
++	.cmd_rcgr = 0x0050,
++	.freq_tbl = ftbl_apcs_alias0_clk_src,
++	.hid_width = 5,
++	.parent_map = parents_apcs_alias0_clk_src_map,
++	.clkr.hw.init = &(struct clk_init_data){
++		.name = "apcs_alias0_clk_src",
++		.parent_names = parents_apcs_alias0_clk_src,
++		.num_parents = 6,
++		.ops = &clk_rcg2_ops,
++		.flags = CLK_SET_RATE_PARENT,
++	},
++};
++
++static struct clk_branch apcs_alias0_core_clk = {
++	.halt_reg = 0x0058,
++	.halt_bit = 31,
++	.clkr = {
++		.enable_reg = 0x0058,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data){
++			.name = "apcs_alias0_core_clk",
++			.parent_names = (const char *[]){
++				"apcs_alias0_clk_src"
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT |
++				CLK_IS_CRITICAL,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_regmap *apss_ipq807x_clks[] = {
++	[APSS_PLL_EARLY] = &apss_pll_early.clkr,
++	[APSS_PLL] = &apss_pll.clkr,
++	[APCS_ALIAS0_CLK_SRC] = &apcs_alias0_clk_src.clkr,
++	[APCS_ALIAS0_CORE_CLK] = &apcs_alias0_core_clk.clkr,
++};
++
++static const struct of_device_id apss_ipq807x_match_table[] = {
++	{ .compatible = "qcom,apss-ipq807x" },
++	{ }
++};
++MODULE_DEVICE_TABLE(of, apss_ipq807x_match_table);
++
++static const struct regmap_config apss_ipq807x_regmap_config = {
++	.reg_bits       = 32,
++	.reg_stride     = 4,
++	.val_bits       = 32,
++	.max_register   = 0x5ffc,
++	.fast_io	= true,
++};
++
++static const struct qcom_cc_desc apss_ipq807x_desc = {
++	.config = &apss_ipq807x_regmap_config,
++	.clks = apss_ipq807x_clks,
++	.num_clks = ARRAY_SIZE(apss_ipq807x_clks),
++};
++
++static int apss_ipq807x_probe(struct platform_device *pdev)
++{
++	int ret;
++
++	ret = qcom_cc_probe(pdev, &apss_ipq807x_desc);
++
++	dev_dbg(&pdev->dev, "Registered ipq807x apss clock provider\n");
++
++	return ret;
++}
++
++static int apss_ipq807x_remove(struct platform_device *pdev)
++{
++	return 0;
++}
++
++static struct platform_driver apss_ipq807x_driver = {
++	.probe = apss_ipq807x_probe,
++	.remove = apss_ipq807x_remove,
++	.driver = {
++		.name   = "qcom,apss-ipq807x",
++		.owner  = THIS_MODULE,
++		.of_match_table = apss_ipq807x_match_table,
++	},
++};
++
++static int __init apss_ipq807x_init(void)
++{
++	return platform_driver_register(&apss_ipq807x_driver);
++}
++core_initcall(apss_ipq807x_init);
++
++static void __exit apss_ipq807x_exit(void)
++{
++	platform_driver_unregister(&apss_ipq807x_driver);
++}
++module_exit(apss_ipq807x_exit);
++
++MODULE_DESCRIPTION("QCA APSS IPQ807x Driver");
++MODULE_LICENSE("Dual BSD/GPLv2");
++MODULE_ALIAS("platform:apss-ipq807x");
+--- a/drivers/clk/qcom/clk-alpha-pll.c
++++ b/drivers/clk/qcom/clk-alpha-pll.c
+@@ -116,6 +116,18 @@ const u8 clk_alpha_pll_regs[][PLL_OFF_MA
+ 		[PLL_OFF_OPMODE] = 0x38,
+ 		[PLL_OFF_ALPHA_VAL] = 0x40,
+ 	},
++	[CLK_ALPHA_PLL_TYPE_APSS] = {
++		[PLL_OFF_L_VAL] = 0x08,
++		[PLL_OFF_ALPHA_VAL] = 0x10,
++		[PLL_OFF_ALPHA_VAL_U] = 0xff,
++		[PLL_OFF_USER_CTL] = 0x18,
++		[PLL_OFF_USER_CTL_U] = 0xff,
++		[PLL_OFF_CONFIG_CTL] = 0x20,
++		[PLL_OFF_CONFIG_CTL_U] = 0x24,
++		[PLL_OFF_TEST_CTL] = 0x30,
++		[PLL_OFF_TEST_CTL_U] = 0x34,
++		[PLL_OFF_STATUS] = 0x28,
++	}
+ };
+ EXPORT_SYMBOL_GPL(clk_alpha_pll_regs);
+ 
+--- a/drivers/clk/qcom/clk-alpha-pll.h
++++ b/drivers/clk/qcom/clk-alpha-pll.h
+@@ -15,6 +15,7 @@ enum {
+ 	CLK_ALPHA_PLL_TYPE_FABIA,
+ 	CLK_ALPHA_PLL_TYPE_TRION,
+ 	CLK_ALPHA_PLL_TYPE_LUCID = CLK_ALPHA_PLL_TYPE_TRION,
++	CLK_ALPHA_PLL_TYPE_APSS,
+ 	CLK_ALPHA_PLL_TYPE_MAX,
+ };
+ 
+@@ -69,6 +70,8 @@ struct clk_alpha_pll {
+ #define SUPPORTS_OFFLINE_REQ	BIT(0)
+ #define SUPPORTS_FSM_MODE	BIT(2)
+ #define SUPPORTS_DYNAMIC_UPDATE	BIT(3)
++
++
+ 	u8 flags;
+ 
+ 	struct clk_regmap clkr;
+--- /dev/null
++++ b/include/dt-bindings/clock/qca,apss-ipq8074.h
+@@ -0,0 +1,25 @@
++/*
++ * Copyright (c) 2017,2020. The Linux Foundation. All rights reserved.
++ *
++ * Permission to use, copy, modify, and/or distribute this software for any
++ * purpose with or without fee is hereby granted, provided that the above
++ * copyright notice and this permission notice appear in all copies.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
++ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ */
++
++#ifndef _DT_BINDINGS_CLOCK_QCA_APSS_IPQ8074_H
++#define _DT_BINDINGS_CLOCK_QCA_APSS_IPQ8074_H
++
++#define APSS_PLL_EARLY				0
++#define APSS_PLL				1
++#define APCS_ALIAS0_CLK_SRC			2
++#define APCS_ALIAS0_CORE_CLK			3
++
++#endif
diff --git a/target/linux/ipq807x/patches-5.10/140-clk-qcom-ipq8074-make-apss-clock-as-child-of-mailbox.patch b/target/linux/ipq807x/patches-5.10/140-clk-qcom-ipq8074-make-apss-clock-as-child-of-mailbox.patch
new file mode 100644
index 0000000..995e656
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/140-clk-qcom-ipq8074-make-apss-clock-as-child-of-mailbox.patch
@@ -0,0 +1,105 @@
+From b5c28ea3b9a963d425ae88ef53d266ff8ae95bc2 Mon Sep 17 00:00:00 2001
+From: Sivaprakash Murugesan <sivaprak@codeaurora.org>
+Date: Fri, 24 Apr 2020 23:05:50 +0530
+Subject: [PATCH 2/3] clk: qcom: ipq8074: make apss clock as child of mailbox
+
+both apcs mailbox and apss clock controller access the same register
+space, resource request will fail for one of the two drivers.
+
+to resolve this make apss clock controller as child of mailbox, the apss
+clock controller will use mailbox regmap for resource request and probe.
+
+Signed-off-by: Sivaprakash Murugesan <sivaprak@codeaurora.org>
+Change-Id: Ic26ee78b6f680fa0655a73d3176bae271725ab05
+---
+ drivers/clk/qcom/apss-ipq8074.c         | 14 ++++++--------
+ drivers/mailbox/qcom-apcs-ipc-mailbox.c | 18 +++++++++++++++---
+ 2 files changed, 21 insertions(+), 11 deletions(-)
+
+--- a/drivers/clk/qcom/apss-ipq8074.c
++++ b/drivers/clk/qcom/apss-ipq8074.c
+@@ -147,12 +147,6 @@ static struct clk_regmap *apss_ipq807x_c
+ 	[APCS_ALIAS0_CORE_CLK] = &apcs_alias0_core_clk.clkr,
+ };
+ 
+-static const struct of_device_id apss_ipq807x_match_table[] = {
+-	{ .compatible = "qcom,apss-ipq807x" },
+-	{ }
+-};
+-MODULE_DEVICE_TABLE(of, apss_ipq807x_match_table);
+-
+ static const struct regmap_config apss_ipq807x_regmap_config = {
+ 	.reg_bits       = 32,
+ 	.reg_stride     = 4,
+@@ -170,8 +164,13 @@ static const struct qcom_cc_desc apss_ip
+ static int apss_ipq807x_probe(struct platform_device *pdev)
+ {
+ 	int ret;
++	struct regmap *regmap;
++
++	regmap = dev_get_regmap(pdev->dev.parent, NULL);
++	if (IS_ERR(regmap))
++		return PTR_ERR(regmap);
+ 
+-	ret = qcom_cc_probe(pdev, &apss_ipq807x_desc);
++	ret = qcom_cc_really_probe(pdev, &apss_ipq807x_desc, regmap);
+ 
+ 	dev_dbg(&pdev->dev, "Registered ipq807x apss clock provider\n");
+ 
+@@ -189,7 +188,6 @@ static struct platform_driver apss_ipq80
+ 	.driver = {
+ 		.name   = "qcom,apss-ipq807x",
+ 		.owner  = THIS_MODULE,
+-		.of_match_table = apss_ipq807x_match_table,
+ 	},
+ };
+ 
+--- a/drivers/mailbox/qcom-apcs-ipc-mailbox.c
++++ b/drivers/mailbox/qcom-apcs-ipc-mailbox.c
+@@ -65,7 +65,7 @@ static const struct regmap_config apcs_r
+ 	.reg_bits = 32,
+ 	.reg_stride = 4,
+ 	.val_bits = 32,
+-	.max_register = 0xFFC,
++	.max_register = 0x5FFC,
+ 	.fast_io = true,
+ };
+ 
+@@ -82,6 +82,16 @@ static const struct mbox_chan_ops qcom_a
+ 	.send_data = qcom_apcs_ipc_send_data,
+ };
+ 
++static const struct of_device_id apcs_clk_match_table[] = {
++	{ .compatible = "qcom,msm8916-apcs-kpss-global",
++	  . data = "qcom-apcs-msm8916-clk", 		},
++	{ .compatible = "qcom,qcs404-apcs-apps-global",
++	  .data = "qcom-apcs-msm8916-clk",		},
++	{ .compatible = "qcom,ipq8074-apcs-apps-global",
++	  .data = "qcom,apss-ipq807x",			},
++	{}
++};
++
+ static int qcom_apcs_ipc_probe(struct platform_device *pdev)
+ {
+ 	struct qcom_apcs_ipc *apcs;
+@@ -91,6 +101,7 @@ static int qcom_apcs_ipc_probe(struct pl
+ 	void __iomem *base;
+ 	unsigned long i;
+ 	int ret;
++	const struct of_device_id *device_id;
+ 
+ 	apcs = devm_kzalloc(&pdev->dev, sizeof(*apcs), GFP_KERNEL);
+ 	if (!apcs)
+@@ -125,9 +136,10 @@ static int qcom_apcs_ipc_probe(struct pl
+ 		return ret;
+ 	}
+ 
+-	if (apcs_data->clk_name) {
++	device_id = of_match_device(apcs_clk_match_table, &pdev->dev);
++	if (device_id) {
+ 		apcs->clk = platform_device_register_data(&pdev->dev,
+-							  apcs_data->clk_name,
++							  device_id->data,
+ 							  PLATFORM_DEVID_AUTO,
+ 							  NULL, 0);
+ 		if (IS_ERR(apcs->clk))
diff --git a/target/linux/ipq807x/patches-5.10/141-arm64-dts-ipq8074-add-APPS-CPU-clock.patch b/target/linux/ipq807x/patches-5.10/141-arm64-dts-ipq8074-add-APPS-CPU-clock.patch
new file mode 100644
index 0000000..ab556b7
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/141-arm64-dts-ipq8074-add-APPS-CPU-clock.patch
@@ -0,0 +1,70 @@
+From 99841b41e13b4a0512de1e06191cdcaf7ee0e1d1 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Thu, 13 May 2021 12:42:05 +0200
+Subject: [PATCH 3/3] arm64: dts: ipq8074: add APPS CPU clock
+
+In preparation for frequency scaling add the APPS
+clock support.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 12 +++++++++++-
+ 1 file changed, 11 insertions(+), 1 deletion(-)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -5,6 +5,7 @@
+ 
+ #include <dt-bindings/interrupt-controller/arm-gic.h>
+ #include <dt-bindings/clock/qcom,gcc-ipq8074.h>
++#include <dt-bindings/clock/qca,apss-ipq8074.h>
+ #include <dt-bindings/spmi/spmi.h>
+ 
+ / {
+@@ -33,6 +34,8 @@
+ 			device_type = "cpu";
+ 			compatible = "arm,cortex-a53";
+ 			reg = <0x0>;
++			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
++			clock-names = "cpu";
+ 			next-level-cache = <&L2_0>;
+ 			enable-method = "psci";
+ 		};
+@@ -42,6 +45,8 @@
+ 			compatible = "arm,cortex-a53";
+ 			enable-method = "psci";
+ 			reg = <0x1>;
++			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
++			clock-names = "cpu";
+ 			next-level-cache = <&L2_0>;
+ 		};
+ 
+@@ -50,6 +55,8 @@
+ 			compatible = "arm,cortex-a53";
+ 			enable-method = "psci";
+ 			reg = <0x2>;
++			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
++			clock-names = "cpu";
+ 			next-level-cache = <&L2_0>;
+ 		};
+ 
+@@ -58,6 +65,8 @@
+ 			compatible = "arm,cortex-a53";
+ 			enable-method = "psci";
+ 			reg = <0x3>;
++			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
++			clock-names = "cpu";
+ 			next-level-cache = <&L2_0>;
+ 		};
+ 
+@@ -909,8 +918,9 @@
+ 
+ 		apcs_glb: mailbox@b111000 {
+ 			compatible = "qcom,ipq8074-apcs-apps-global";
+-			reg = <0x0b111000 0x1000>;
++			reg = <0x0b111000 0x6000>;
+ 
++			#clock-cells = <1>;
+ 			#mbox-cells = <1>;
+ 		};
+ 
diff --git a/target/linux/ipq807x/patches-5.10/142-arm64-dts-ipq8074-add-label-to-cpus.patch b/target/linux/ipq807x/patches-5.10/142-arm64-dts-ipq8074-add-label-to-cpus.patch
new file mode 100644
index 0000000..687cb55
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/142-arm64-dts-ipq8074-add-label-to-cpus.patch
@@ -0,0 +1,26 @@
+From fb5a1fff750f99dbf7cabda0de9fbf7463a07586 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Thu, 13 May 2021 13:13:46 +0200
+Subject: [PATCH] arm64: dts: ipq8074: add label to cpus
+
+Add label to cpus node as that makes it
+easy to add OPP table in SoC model specific
+DTSI as IPQ8074 family has differing clocks
+and voltages based on model.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -26,7 +26,7 @@
+ 		};
+ 	};
+ 
+-	cpus {
++	cpus: cpus {
+ 		#address-cells = <0x1>;
+ 		#size-cells = <0x0>;
+ 
diff --git a/target/linux/ipq807x/patches-5.10/143-arm64-dts-ipq8074-Add-WLAN-node.patch b/target/linux/ipq807x/patches-5.10/143-arm64-dts-ipq8074-Add-WLAN-node.patch
new file mode 100644
index 0000000..e270ec4
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/143-arm64-dts-ipq8074-Add-WLAN-node.patch
@@ -0,0 +1,133 @@
+From 0fb054684bdf40f17ab59226dae21ddfe0d79466 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Thu, 13 May 2021 15:15:46 +0200
+Subject: [PATCH] arm64: dts: ipq8074: Add WLAN node
+
+IPQ8074 is supported by ath11k, so add the required
+DT node.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 111 ++++++++++++++++++++++++++
+ 1 file changed, 111 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -974,6 +974,117 @@
+ 			};
+ 		};
+ 
++		wifi: wifi@c0000000 {
++			compatible = "qcom,ipq8074-wifi";
++			reg = <0xc000000 0x2000000>;
++
++			interrupts = <GIC_SPI 320 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 319 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 318 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 316 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 315 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 314 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 311 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 310 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 411 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 410 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 40 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 39 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 302 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 301 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 37 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 36 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 296 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 295 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 294 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 293 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 292 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 291 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 290 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 289 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 288 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 239 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 236 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 235 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 234 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 233 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 232 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 231 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 230 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 229 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 228 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 224 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 223 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 203 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 183 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 180 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 179 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 178 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 177 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 176 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 163 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 162 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 160 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 159 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 158 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 157 IRQ_TYPE_EDGE_RISING>,
++				     <GIC_SPI 156 IRQ_TYPE_EDGE_RISING>;
++
++			interrupt-names = "misc-pulse1",
++					  "misc-latch",
++					  "sw-exception",
++					  "ce0",
++					  "ce1",
++					  "ce2",
++					  "ce3",
++					  "ce4",
++					  "ce5",
++					  "ce6",
++					  "ce7",
++					  "ce8",
++					  "ce9",
++					  "ce10",
++					  "ce11",
++					  "host2wbm-desc-feed",
++					  "host2reo-re-injection",
++					  "host2reo-command",
++					  "host2rxdma-monitor-ring3",
++					  "host2rxdma-monitor-ring2",
++					  "host2rxdma-monitor-ring1",
++					  "reo2ost-exception",
++					  "wbm2host-rx-release",
++					  "reo2host-status",
++					  "reo2host-destination-ring4",
++					  "reo2host-destination-ring3",
++					  "reo2host-destination-ring2",
++					  "reo2host-destination-ring1",
++					  "rxdma2host-monitor-destination-mac3",
++					  "rxdma2host-monitor-destination-mac2",
++					  "rxdma2host-monitor-destination-mac1",
++					  "ppdu-end-interrupts-mac3",
++					  "ppdu-end-interrupts-mac2",
++					  "ppdu-end-interrupts-mac1",
++					  "rxdma2host-monitor-status-ring-mac3",
++					  "rxdma2host-monitor-status-ring-mac2",
++					  "rxdma2host-monitor-status-ring-mac1",
++					  "host2rxdma-host-buf-ring-mac3",
++					  "host2rxdma-host-buf-ring-mac2",
++					  "host2rxdma-host-buf-ring-mac1",
++					  "rxdma2host-destination-ring-mac3",
++					  "rxdma2host-destination-ring-mac2",
++					  "rxdma2host-destination-ring-mac1",
++					  "host2tcl-input-ring4",
++					  "host2tcl-input-ring3",
++					  "host2tcl-input-ring2",
++					  "host2tcl-input-ring1",
++					  "wbm2host-tx-completions-ring3",
++					  "wbm2host-tx-completions-ring2",
++					  "wbm2host-tx-completions-ring1",
++					  "tcl2host-status-ring";
++			qcom,rproc = <&q6v5_wcss>;
++			status = "disabled";
++		};
++
+ 		ess_switch: ess-switch@3a000000 {
+ 			compatible = "qcom,ess-switch-ipq807x";
+ 			reg = <0x3a000000 0x1000000>;
diff --git a/target/linux/ipq807x/patches-5.10/144-arm64-dts-ipq8074-add-NSS-reserved-memory-node.patch b/target/linux/ipq807x/patches-5.10/144-arm64-dts-ipq8074-add-NSS-reserved-memory-node.patch
new file mode 100644
index 0000000..ce2af3e
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/144-arm64-dts-ipq8074-add-NSS-reserved-memory-node.patch
@@ -0,0 +1,28 @@
+From 22865119dada2a40a5e5e8c5f22b5bec08651021 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Fri, 14 May 2021 19:43:41 +0200
+Subject: [PATCH] arm64: dts: ipq8074: add NSS reserved memory node
+
+NSS FW has its own dedicated memory it needs to get loaded to.
+Since it simply uses ioremap() that memory must be reserved
+so the kernel will allow using ioremap() on it.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -91,6 +91,11 @@
+ 		#size-cells = <2>;
+ 		ranges;
+ 
++		nss@40000000 {
++			no-map;
++			reg = <0x0 0x40000000 0x0 0x01000000>;
++		};
++
+ 		smem_region: memory@4ab00000 {
+ 			no-map;
+ 			reg = <0x0 0x4ab00000 0x0 0x00100000>;
diff --git a/target/linux/ipq807x/patches-5.10/145-clk-qcom-ipq8074-disable-SW_COLLAPSE-for-USB-GDSCR-s.patch b/target/linux/ipq807x/patches-5.10/145-clk-qcom-ipq8074-disable-SW_COLLAPSE-for-USB-GDSCR-s.patch
new file mode 100644
index 0000000..47abf9e
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/145-clk-qcom-ipq8074-disable-SW_COLLAPSE-for-USB-GDSCR-s.patch
@@ -0,0 +1,29 @@
+From a801cc475f0d1fdf29d7b6b56d64df090bf83f8d Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Fri, 3 Apr 2020 12:57:37 +0530
+Subject: [PATCH] clk: qcom: ipq8074: disable SW_COLLAPSE for USB GDSCR's
+
+Change-Id: Id347be781e2bb449bd7cdf05e3535e8ca3c3ffd6
+Signed-off-by: Abhishek Sahu <absahu@codeaurora.org>
+(cherry picked from commit 5e100df9c29ed7e5ad12583aa39053f4a9761efe)
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+
+Change-Id: I17beca334be79d738a35587860847aa0b1f96fa9
+---
+ drivers/clk/qcom/gcc-ipq8074.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -5063,6 +5063,11 @@ static int gcc_ipq8074_probe(struct plat
+ 	if (IS_ERR(regmap))
+ 		return PTR_ERR(regmap);
+ 
++	/* Disable SW_COLLAPSE for USB0 GDSCR */
++	regmap_update_bits(regmap, 0x3e078, BIT(0), 0x0);
++	/* Disable SW_COLLAPSE for USB1 GDSCR */
++	regmap_update_bits(regmap, 0x3f078, BIT(0), 0x0);
++
+ 	clk_alpha_pll_configure(&ubi32_pll_main, regmap, &ubi32_pll_config);
+ 	clk_alpha_pll_configure(&nss_crypto_pll_main, regmap,
+ 				&nss_crypto_pll_config);
diff --git a/target/linux/ipq807x/patches-5.10/146-clk-qcom-ipq8074-SW-workaround-for-UBI-PLL-lock.patch b/target/linux/ipq807x/patches-5.10/146-clk-qcom-ipq8074-SW-workaround-for-UBI-PLL-lock.patch
new file mode 100644
index 0000000..c90462e
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/146-clk-qcom-ipq8074-SW-workaround-for-UBI-PLL-lock.patch
@@ -0,0 +1,46 @@
+From 5f707d3ff1b22c089253e39906b5edeeb5f10fdc Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Fri, 3 Apr 2020 15:31:59 +0530
+Subject: [PATCH] clk: qcom: ipq8074: SW workaround for UBI PLL lock
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some chips Huyara PLL is unable to lock in 5 us and
+generating UBI PLL lock error.
+
+ WARNING: CPU: 1 PID: 625 at drivers/clk/qcom/clk-alpha-pll.c:114
+ wait_for_pll+0xbc/0xe0()
+ ubi32_pll_main failed to enable!
+ CPU: 1 PID: 625 Comm: kmodloader Not tainted 4.4.60 #1
+ Hardware name: Generic DT based system
+ (unwind_backtrace) from [<8021b550>] (show_stack+0x10/0x14)
+ (show_stack) from [<803f6b24>] (dump_stack+0x80/0xa0)
+ (dump_stack) from [<80228ff0>] (warn_slowpath_common+0x84/0xb0)
+ (warn_slowpath_common) from [<80229048>] (warn_slowpath_fmt+0x2c/0x3c)
+ (warn_slowpath_fmt) from [<8054d53c>] (wait_for_pll+0xbc/0xe0)
+ (wait_for_pll) from [<8054d6cc>] (clk_alpha_pll_enable+0xe0/0x128)
+ (clk_alpha_pll_enable) from [<80547b68>] (clk_core_enable+0x68/0x98)
+ (clk_core_enable) from [<80547b48>] (clk_core_enable+0x48/0x98)
+
+This is BUG in Huayra PLL HW for which SW workaround
+is to set bit 26 of TEST_CTL register.
+
+Change-Id: Ib5473f4011e3410515f382b2445bee2d66dd654a
+Signed-off-by: Abhishek Sahu <absahu@codeaurora.org>
+---
+ drivers/clk/qcom/gcc-ipq8074.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -5068,6 +5068,9 @@ static int gcc_ipq8074_probe(struct plat
+ 	/* Disable SW_COLLAPSE for USB1 GDSCR */
+ 	regmap_update_bits(regmap, 0x3f078, BIT(0), 0x0);
+ 
++	/* SW Workaround for UBI Huayra PLL */
++	regmap_update_bits(regmap, 0x2501c, BIT(26), BIT(26));
++
+ 	clk_alpha_pll_configure(&ubi32_pll_main, regmap, &ubi32_pll_config);
+ 	clk_alpha_pll_configure(&nss_crypto_pll_main, regmap,
+ 				&nss_crypto_pll_config);
diff --git a/target/linux/ipq807x/patches-5.10/147-clk-ipq8074-defer-from-disabling-gcc_sleep_clk_src.patch b/target/linux/ipq807x/patches-5.10/147-clk-ipq8074-defer-from-disabling-gcc_sleep_clk_src.patch
new file mode 100644
index 0000000..8be26fb
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/147-clk-ipq8074-defer-from-disabling-gcc_sleep_clk_src.patch
@@ -0,0 +1,31 @@
+From db9c60394765843f6a77833bc40c27fac8852e97 Mon Sep 17 00:00:00 2001
+From: Balaji Prakash J <bjagadee@codeaurora.org>
+Date: Mon, 20 Apr 2020 20:07:51 +0530
+Subject: [PATCH] clk: ipq8074: defer from disabling gcc_sleep_clk_src
+
+Added CLK_IS_CRITICAL flag in order to defer from
+disabling the sleep clock source.
+
+Once the usb sleep clocks are disabled, clock framework
+is trying to disable the sleep clock source also and
+the below warning is observed.
+
+[   28.235750] gcc_sleep_clk_src status stuck at 'on'
+[   28.235794] WARNING: CPU: 0 PID: 29 at drivers/clk/qcom/clk-branch.c:92 clk_branch_toggle+0x160/0x178
+
+Signed-off-by: Balaji Prakash J <bjagadee@codeaurora.org>
+Change-Id: I61fab902375716272ad9c426ce71581058f7bd35
+---
+ drivers/clk/qcom/gcc-ipq8074.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -683,6 +683,7 @@ static struct clk_branch gcc_sleep_clk_s
+ 			},
+ 			.num_parents = 1,
+ 			.ops = &clk_branch2_ops,
++			.flags = CLK_IS_CRITICAL,
+ 		},
+ 	},
+ };
diff --git a/target/linux/ipq807x/patches-5.10/148-clk-ipq8074-fix-gcc_blsp1_ahb_clk-properties.patch b/target/linux/ipq807x/patches-5.10/148-clk-ipq8074-fix-gcc_blsp1_ahb_clk-properties.patch
new file mode 100644
index 0000000..2c8887e
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/148-clk-ipq8074-fix-gcc_blsp1_ahb_clk-properties.patch
@@ -0,0 +1,41 @@
+From 52315bec6ed633b6a71f28b746029602f8bd70b9 Mon Sep 17 00:00:00 2001
+From: Balaji Prakash J <bjagadee@codeaurora.org>
+Date: Wed, 22 Apr 2020 20:35:30 +0530
+Subject: [PATCH] clk: ipq8074: fix gcc_blsp1_ahb_clk properties
+
+All the voting enabled clocks does not support the enable
+from CBCR register. So, updated gcc_blsp1_ahb_clk enable
+register and mask to enable bit in APCS_CLOCK_BRANCH_ENA_VOTE.
+
+Also, the voting controlled clocks are shared among multiple
+components like APSS, RPM, NSS, TZ, etc. So, turning the
+voting off from APSS does not make the clock off if it has
+been voted from another component. Added the flag
+BRANCH_HALT_VOTED in order to skip checking the clock
+disable status.
+
+This change is referred from the below commits,
+1. 246b4fb3af9bd65d8af794aac2f0e7b1ed9cc2dd
+2. c8374157d5ae91d3b3e0d513d62808a798b32d3a
+
+Signed-off-by: Balaji Prakash J <bjagadee@codeaurora.org>
+Change-Id: I505cb560b31ad27a02c165fbe13bb33a2fc7d230
+---
+ drivers/clk/qcom/gcc-ipq8074.c | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -2118,9 +2118,10 @@ struct clk_rcg2 adss_pwm_clk_src = {
+ 
+ static struct clk_branch gcc_blsp1_ahb_clk = {
+ 	.halt_reg = 0x01008,
++	.halt_check = BRANCH_HALT_VOTED,
+ 	.clkr = {
+-		.enable_reg = 0x01008,
+-		.enable_mask = BIT(0),
++		.enable_reg = 0x0b004,
++		.enable_mask = BIT(10),
+ 		.hw.init = &(struct clk_init_data){
+ 			.name = "gcc_blsp1_ahb_clk",
+ 			.parent_names = (const char *[]){
diff --git a/target/linux/ipq807x/patches-5.10/149-remoteproc-wcss-disable-auto-boot-for-IPQ8074.patch b/target/linux/ipq807x/patches-5.10/149-remoteproc-wcss-disable-auto-boot-for-IPQ8074.patch
new file mode 100644
index 0000000..f484b97
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/149-remoteproc-wcss-disable-auto-boot-for-IPQ8074.patch
@@ -0,0 +1,47 @@
+From 256eda666b4687c5242b9f075caf4e09ad642daa Mon Sep 17 00:00:00 2001
+From: Sivaprakash Murugesan <sivaprak@codeaurora.org>
+Date: Fri, 17 Apr 2020 16:37:10 +0530
+Subject: [PATCH] remoteproc: wcss: disable auto boot for IPQ8074
+
+auto boot is disabled for IPQ8074 the wifi driver brings up the wcss.
+
+Signed-off-by: Sivaprakash Murugesan <sivaprak@codeaurora.org>
+Change-Id: Ia82edb7ee52f2bd010c099f151179d69a953ac88
+---
+ drivers/remoteproc/qcom_q6v5_wcss.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/remoteproc/qcom_q6v5_wcss.c
++++ b/drivers/remoteproc/qcom_q6v5_wcss.c
+@@ -161,6 +161,7 @@ struct wcss_data {
+ 	const struct rproc_ops *ops;
+ 	bool requires_force_stop;
+ 	bool need_mem_protection;
++	bool need_auto_boot;
+ };
+ 
+ static int q6v5_wcss_reset(struct q6v5_wcss *wcss)
+@@ -1147,6 +1148,7 @@ static int q6v5_wcss_probe(struct platfo
+ 						      desc->sysmon_name,
+ 						      desc->ssctl_id);
+ 
++	rproc->auto_boot = desc->need_auto_boot;
+ 	ret = rproc_add(rproc);
+ 	if (ret)
+ 		goto free_rproc;
+@@ -1183,6 +1185,7 @@ static const struct wcss_data wcss_ipq80
+ 	.ops = &q6v5_wcss_ipq8074_ops,
+ 	.requires_force_stop = true,
+ 	.need_mem_protection = true,
++	.need_auto_boot = false,
+ };
+ 
+ static const struct wcss_data wcss_qcs404_res_init = {
+@@ -1199,6 +1202,7 @@ static const struct wcss_data wcss_qcs40
+ 	.ssctl_id = 0x12,
+ 	.ops = &q6v5_wcss_qcs404_ops,
+ 	.requires_force_stop = false,
++	.need_auto_boot = true,
+ };
+ 
+ static const struct of_device_id q6v5_wcss_of_match[] = {
diff --git a/target/linux/ipq807x/patches-5.10/150-arm64-dts-ipq8074-add-missing-reserved-memory-nodes.patch b/target/linux/ipq807x/patches-5.10/150-arm64-dts-ipq8074-add-missing-reserved-memory-nodes.patch
new file mode 100644
index 0000000..bc05359
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/150-arm64-dts-ipq8074-add-missing-reserved-memory-nodes.patch
@@ -0,0 +1,65 @@
+From 158bd87b3db04bdd1effe4a92424f9572224a6c3 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Sat, 15 May 2021 00:09:21 +0200
+Subject: [PATCH] arm64: dts: ipq8074: add missing reserved memory nodes
+
+Downstream kernel has more reserved memory nodes.
+Without these ath11k will cause a board reset.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 36 +++++++++++++++++++++++++--
+ 1 file changed, 34 insertions(+), 2 deletions(-)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -96,15 +96,47 @@
+ 			reg = <0x0 0x40000000 0x0 0x01000000>;
+ 		};
+ 
+-		smem_region: memory@4ab00000 {
++		tzapp: tzapp@4a400000 {
++			no-map;
++			reg = <0x0 0x4a400000 0x0 0x00200000>;
++		};
++
++
++		uboot@4a600000 {
++			no-map;
++			reg = <0x0 0x4a600000 0x0 0x00400000>;
++		};
++
++		sbl@4aa00000 {
++			no-map;
++			reg = <0x0 0x4aa00000 0x0 0x00100000>;
++		};
++
++		smem_region: smem@4ab00000 {
+ 			no-map;
+ 			reg = <0x0 0x4ab00000 0x0 0x00100000>;
+ 		};
+ 
+-		q6_region: memory@4b000000 {
++		tz@4ac00000 {
++			no-map;
++			reg = <0x0 0x4ac00000 0x0 0x00400000>;
++		};
++
++		q6_region: wcnss@4b000000 {
+ 			no-map;
+ 			reg = <0x0 0x4b000000 0x0 0x05f00000>;
+ 		};
++
++		q6_etr_region: q6_etr_dump@50f00000 {
++			no-map;
++			reg = <0x0 0x50f00000 0x0 0x00100000>;
++		};
++
++		m3_dump@51000000 {
++			no-map;
++			reg = <0x0 0x51000000 0x0 0x100000>;
++		};
++
+ 	};
+ 
+ 	firmware {
diff --git a/target/linux/ipq807x/patches-5.10/151-arm64-dts-ipq8074-add-q6_etr-memory-region-to-remote.patch b/target/linux/ipq807x/patches-5.10/151-arm64-dts-ipq8074-add-q6_etr-memory-region-to-remote.patch
new file mode 100644
index 0000000..4406035
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/151-arm64-dts-ipq8074-add-q6_etr-memory-region-to-remote.patch
@@ -0,0 +1,24 @@
+From 86aa6afcf280a61150a3e6c796f629d09db88d55 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Sat, 15 May 2021 00:18:32 +0200
+Subject: [PATCH] arm64: dts: ipq8074: add q6_etr memory region to remoteproc
+
+Q6v5 remoteprocessor also has a q6_etr memor region
+reserved for it, so add it to the node.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -998,7 +998,7 @@
+ 			qcom,smem-state-names = "shutdown",
+ 						"stop";
+ 
+-			memory-region = <&q6_region>;
++			memory-region = <&q6_region>, <&q6_etr_region>;
+ 
+ 			glink-edge {
+ 				interrupts = <GIC_SPI 321 IRQ_TYPE_EDGE_RISING>;
diff --git a/target/linux/ipq807x/patches-5.10/152-thermal-qcom-tsens-Add-IPQ8074-support.patch b/target/linux/ipq807x/patches-5.10/152-thermal-qcom-tsens-Add-IPQ8074-support.patch
new file mode 100644
index 0000000..9671ad3
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/152-thermal-qcom-tsens-Add-IPQ8074-support.patch
@@ -0,0 +1,99 @@
+From 98130cb1cb992593b050baa9c4d8484d6fd6e8f6 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Fri, 20 Nov 2020 13:52:43 +0100
+Subject: [PATCH] thermal: qcom: tsens: Add IPQ8074 support
+
+Qualcomm IPQ807x SoC-s use tsens v2.3.0 IP, but they
+only have one interrupt and not a dedicated critical interrupt.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ drivers/thermal/qcom/tsens-v2.c | 14 ++++++++++++++
+ drivers/thermal/qcom/tsens.c    | 27 ++++++++++++++++++---------
+ drivers/thermal/qcom/tsens.h    |  2 +-
+ 3 files changed, 33 insertions(+), 10 deletions(-)
+
+--- a/drivers/thermal/qcom/tsens-v2.c
++++ b/drivers/thermal/qcom/tsens-v2.c
+@@ -36,6 +36,14 @@ static struct tsens_features tsens_v2_fe
+ 	.max_sensors	= 16,
+ };
+ 
++static struct tsens_features tsens_ipq8074_feat = {
++	.ver_major	= VER_2_X,
++	.crit_int	= 0,
++	.adc		= 0,
++	.srot_split	= 1,
++	.max_sensors	= 16,
++};
++
+ static const struct reg_field tsens_v2_regfields[MAX_REGFIELDS] = {
+ 	/* ----- SROT ------ */
+ 	/* VERSION */
+@@ -101,6 +109,12 @@ struct tsens_plat_data data_tsens_v2 = {
+ 	.fields	= tsens_v2_regfields,
+ };
+ 
++struct tsens_plat_data data_tsens_ipq8074 = {
++	.ops		= &ops_generic_v2,
++	.feat		= &tsens_ipq8074_feat,
++	.fields	= tsens_v2_regfields,
++};
++
+ /* Kept around for backward compatibility with old msm8996.dtsi */
+ struct tsens_plat_data data_8996 = {
+ 	.num_sensors	= 13,
+--- a/drivers/thermal/qcom/tsens.c
++++ b/drivers/thermal/qcom/tsens.c
+@@ -323,16 +323,22 @@ static int tsens_read_irq_state(struct t
+ 		ret = regmap_field_read(priv->rf[LOW_INT_MASK_0 + hw_id], &d->low_irq_mask);
+ 		if (ret)
+ 			return ret;
+-		ret = regmap_field_read(priv->rf[CRIT_INT_CLEAR_0 + hw_id],
+-					&d->crit_irq_clear);
+-		if (ret)
+-			return ret;
+-		ret = regmap_field_read(priv->rf[CRIT_INT_MASK_0 + hw_id],
+-					&d->crit_irq_mask);
+-		if (ret)
+-			return ret;
++		if (priv->feat->crit_int) {
++			ret = regmap_field_read(priv->rf[CRIT_INT_CLEAR_0 + hw_id],
++						&d->crit_irq_clear);
++			if (ret)
++				return ret;
++			ret = regmap_field_read(priv->rf[CRIT_INT_MASK_0 + hw_id],
++						&d->crit_irq_mask);
++			if (ret)
++				return ret;
+ 
+-		d->crit_thresh = tsens_hw_to_mC(s, CRIT_THRESH_0 + hw_id);
++			d->crit_thresh = tsens_hw_to_mC(s, CRIT_THRESH_0 + hw_id);
++		} else {
++			d->crit_irq_clear = 0;
++			d->crit_irq_mask = 0;
++			d->crit_thresh = 0;
++		}
+ 	} else {
+ 		/* No mask register on older TSENS */
+ 		d->up_irq_mask = 0;
+@@ -917,6 +923,9 @@ static const struct of_device_id tsens_t
+ 	}, {
+ 		.compatible = "qcom,tsens-v2",
+ 		.data = &data_tsens_v2,
++	}, {
++		.compatible = "qcom,ipq8074-tsens",
++		.data = &data_tsens_ipq8074,
+ 	},
+ 	{}
+ };
+--- a/drivers/thermal/qcom/tsens.h
++++ b/drivers/thermal/qcom/tsens.h
+@@ -591,6 +591,6 @@ extern struct tsens_plat_data data_8916,
+ extern struct tsens_plat_data data_tsens_v1, data_8976;
+ 
+ /* TSENS v2 targets */
+-extern struct tsens_plat_data data_8996, data_tsens_v2;
++extern struct tsens_plat_data data_8996, data_tsens_v2, data_tsens_ipq8074;
+ 
+ #endif /* __QCOM_TSENS_H__ */
diff --git a/target/linux/ipq807x/patches-5.10/153-drivers-thermal-tsens-fix-wrong-check-for-tzd-in-irq.patch b/target/linux/ipq807x/patches-5.10/153-drivers-thermal-tsens-fix-wrong-check-for-tzd-in-irq.patch
new file mode 100644
index 0000000..c30371b
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/153-drivers-thermal-tsens-fix-wrong-check-for-tzd-in-irq.patch
@@ -0,0 +1,37 @@
+From 10f0582cd0f7c1f3387229f5d341a5ef10a53556 Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Wed, 19 May 2021 00:46:26 +0200
+Subject: [PATCH 1/2] drivers: thermal: tsens: fix wrong check for tzd in irq
+ handlers
+
+Some device can have some thermal sensor disabled from the factory. The
+current 2 irq handler functions check all the sensor by default and the
+check if the sensor was actually registered is wrong. The tzd is
+actually never set if the registration fail hence the IS_ERR check is
+wrong.
+
+Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
+---
+ drivers/thermal/qcom/tsens.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/thermal/qcom/tsens.c
++++ b/drivers/thermal/qcom/tsens.c
+@@ -421,7 +421,7 @@ static irqreturn_t tsens_critical_irq_th
+ 		const struct tsens_sensor *s = &priv->sensor[i];
+ 		u32 hw_id = s->hw_id;
+ 
+-		if (IS_ERR(s->tzd))
++		if (!s->tzd)
+ 			continue;
+ 		if (!tsens_threshold_violated(priv, hw_id, &d))
+ 			continue;
+@@ -471,7 +471,7 @@ static irqreturn_t tsens_irq_thread(int
+ 		const struct tsens_sensor *s = &priv->sensor[i];
+ 		u32 hw_id = s->hw_id;
+ 
+-		if (IS_ERR(s->tzd))
++		if (!s->tzd)
+ 			continue;
+ 		if (!tsens_threshold_violated(priv, hw_id, &d))
+ 			continue;
diff --git a/target/linux/ipq807x/patches-5.10/154-drivers-thermal-tsens-add-timeout-to-get_tem_tsens_v.patch b/target/linux/ipq807x/patches-5.10/154-drivers-thermal-tsens-add-timeout-to-get_tem_tsens_v.patch
new file mode 100644
index 0000000..73eaef8
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/154-drivers-thermal-tsens-add-timeout-to-get_tem_tsens_v.patch
@@ -0,0 +1,55 @@
+From 47b165aa6ed3b85b793c5bfb27050c93a194c0cc Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Wed, 19 May 2021 00:52:21 +0200
+Subject: [PATCH 2/2] drivers: thermal: tsens: add timeout to
+ get_tem_tsens_valid
+
+The function can loop and lock the system if for whatever reason the bit
+for the target sensor is NEVER valid. This is the case if a sensor is
+disabled by the factory and the valid bit is never reported as actually
+valid. Add a timeout check and exit if a timeout occurs. As this is
+a very rare condition, handle the timeout only if the first read fails.
+
+Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
+---
+ drivers/thermal/qcom/tsens.c | 23 ++++++++++++++++-------
+ 1 file changed, 16 insertions(+), 7 deletions(-)
+
+--- a/drivers/thermal/qcom/tsens.c
++++ b/drivers/thermal/qcom/tsens.c
+@@ -587,19 +587,28 @@ int get_temp_tsens_valid(const struct ts
+ 	int hw_id = s->hw_id;
+ 	u32 temp_idx = LAST_TEMP_0 + hw_id;
+ 	u32 valid_idx = VALID_0 + hw_id;
++	unsigned long timeout;
+ 	u32 valid;
+ 	int ret;
+ 
+ 	ret = regmap_field_read(priv->rf[valid_idx], &valid);
+ 	if (ret)
+ 		return ret;
+-	while (!valid) {
+-		/* Valid bit is 0 for 6 AHB clock cycles.
+-		 * At 19.2MHz, 1 AHB clock is ~60ns.
+-		 * We should enter this loop very, very rarely.
+-		 */
+-		ndelay(400);
+-		ret = regmap_field_read(priv->rf[valid_idx], &valid);
++
++	if (!valid) {
++		timeout = jiffies + msecs_to_jiffies(20);
++
++		do {
++			/* Valid bit is 0 for 6 AHB clock cycles.
++			 * At 19.2MHz, 1 AHB clock is ~60ns.
++			 * We should enter this loop very, very rarely.
++			 */
++			ndelay(400);
++			ret = regmap_field_read(priv->rf[valid_idx], &valid);
++			if (valid || ret)
++				break;
++		} while (!(ret = time_after_eq(jiffies, timeout)));
++
+ 		if (ret)
+ 			return ret;
+ 	}
diff --git a/target/linux/ipq807x/patches-5.10/155-arm64-dts-ipq8074-add-thermal-nodes.patch b/target/linux/ipq807x/patches-5.10/155-arm64-dts-ipq8074-add-thermal-nodes.patch
new file mode 100644
index 0000000..5170a07
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/155-arm64-dts-ipq8074-add-thermal-nodes.patch
@@ -0,0 +1,167 @@
+From de1ca571d14bab031cc57bab5311db05f33ceec3 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Wed, 19 May 2021 00:14:50 +0200
+Subject: [PATCH] arm64: dts: ipq8074: add thermal nodes
+
+IPQ8074 has a tsens v2.3.0 peripheral which monitors
+temperatures around the various subsystems on the
+die.
+
+So, lets add the required nodes for tsens and thermal
+zones to enable passive cooling of the device.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 101 ++++++++++++++++++++++++++
+ 1 file changed, 101 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -6,6 +6,7 @@
+ #include <dt-bindings/interrupt-controller/arm-gic.h>
+ #include <dt-bindings/clock/qcom,gcc-ipq8074.h>
+ #include <dt-bindings/clock/qca,apss-ipq8074.h>
++#include <dt-bindings/thermal/thermal.h>
+ #include <dt-bindings/spmi/spmi.h>
+ 
+ / {
+@@ -38,6 +39,7 @@
+ 			clock-names = "cpu";
+ 			next-level-cache = <&L2_0>;
+ 			enable-method = "psci";
++			#cooling-cells = <2>;
+ 		};
+ 
+ 		CPU1: cpu@1 {
+@@ -48,6 +50,7 @@
+ 			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
+ 			clock-names = "cpu";
+ 			next-level-cache = <&L2_0>;
++			#cooling-cells = <2>;
+ 		};
+ 
+ 		CPU2: cpu@2 {
+@@ -58,6 +61,7 @@
+ 			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
+ 			clock-names = "cpu";
+ 			next-level-cache = <&L2_0>;
++			#cooling-cells = <2>;
+ 		};
+ 
+ 		CPU3: cpu@3 {
+@@ -68,6 +72,7 @@
+ 			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
+ 			clock-names = "cpu";
+ 			next-level-cache = <&L2_0>;
++			#cooling-cells = <2>;
+ 		};
+ 
+ 		L2_0: l2-cache {
+@@ -365,6 +370,16 @@
+ 			status = "disabled";
+ 		};
+ 
++		tsens: thermal-sensor@4a9000 {
++			compatible = "qcom,ipq8074-tsens";
++			reg = <0x4a9000 0x1000>, /* TM */
++			      <0x4a8000 0x1000>; /* SROT */
++			interrupts = <GIC_SPI 184 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-names = "uplow";
++			#qcom,sensors = <16>;
++			#thermal-sensor-cells = <1>;
++		};
++
+ 		cryptobam: dma@704000 {
+ 			compatible = "qcom,bam-v1.7.0";
+ 			reg = <0x00704000 0x20000>;
+@@ -1284,4 +1299,90 @@
+ 			#clock-cells = <0>;
+ 		};
+ 	};
++
++	thermal-zones {
++		nss-top-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 4>;
++		};
++
++		nss0-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 5>;
++		};
++
++		nss1-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 6>;
++		};
++
++		wcss-phya0-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 7>;
++		};
++
++		wcss-phya1-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 8>;
++		};
++
++		cpu0_thermal: cpu0-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 9>;
++		};
++
++		cpu1_thermal: cpu1-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 10>;
++		};
++
++		cpu2_thermal: cpu2-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 11>;
++		};
++
++		cpu3_thermal: cpu3-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 12>;
++		};
++
++		cluster_thermal: cluster-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 13>;
++		};
++
++		wcss-phyb0-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 14>;
++		};
++
++		wcss-phyb1-thermal {
++			polling-delay-passive = <250>;
++			polling-delay = <1000>;
++
++			thermal-sensors = <&tsens 15>;
++		};
++	};
+ };
diff --git a/target/linux/ipq807x/patches-5.10/156-arm64-dts-ipq8074-disable-USB-phy-by-default.patch b/target/linux/ipq807x/patches-5.10/156-arm64-dts-ipq8074-disable-USB-phy-by-default.patch
new file mode 100644
index 0000000..8090e0c
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/156-arm64-dts-ipq8074-disable-USB-phy-by-default.patch
@@ -0,0 +1,27 @@
+From c58dea2220d978756a0f7e815bc13dbfa8c33ebc Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Wed, 26 May 2021 16:49:02 +0200
+Subject: [PATCH] arm64: dts: ipq8074: disable USB phy by default
+
+One of the QUSB USB PHY-s has been left enabled by
+default, this is probably just a mistake as other
+USB PHY-s are disabled by default.
+
+It makes no sense to have it enabled by default as
+not all board implement USB ports, so disable it.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -286,6 +286,7 @@
+ 			clock-names = "cfg_ahb", "ref";
+ 
+ 			resets = <&gcc GCC_QUSB2_0_PHY_BCR>;
++			status = "disabled";
+ 		};
+ 
+ 		qmp_pcie_phy0: phy@84000 {
diff --git a/target/linux/ipq807x/patches-5.10/157-arm64-dts-ipq8074-Add-QUP6-I2C-node.patch b/target/linux/ipq807x/patches-5.10/157-arm64-dts-ipq8074-Add-QUP6-I2C-node.patch
new file mode 100644
index 0000000..45b5f33
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/157-arm64-dts-ipq8074-Add-QUP6-I2C-node.patch
@@ -0,0 +1,41 @@
+From 9b2aee0e0fd786c6836d1472cd935186b746bc5e Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Sun, 13 Jun 2021 12:10:42 +0200
+Subject: [PATCH] arm64: dts: ipq8074: Add QUP6 I2C node
+
+Add node to support the QUP6 I2C controller inside
+of IPQ8074.
+It is exactly the same as QUP2 and QUP3 controllers.
+
+Some routers like Xiaomi AX9000 and Netgear RBK850
+use this bus.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 15 +++++++++++++++
+ 1 file changed, 15 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -634,6 +634,21 @@
+ 			status = "disabled";
+ 		};
+ 
++		blsp1_i2c6: i2c@78ba000 {
++			compatible = "qcom,i2c-qup-v2.2.1";
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <0x078ba000 0x600>;
++			interrupts = <GIC_SPI 300 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_AHB_CLK>,
++				 <&gcc GCC_BLSP1_QUP6_I2C_APPS_CLK>;
++			clock-names = "iface", "core";
++			clock-frequency = <100000>;
++			dmas = <&blsp_dma 23>, <&blsp_dma 22>;
++			dma-names = "rx", "tx";
++			status = "disabled";
++		};
++
+ 		qpic_bam: dma@7984000 {
+ 			compatible = "qcom,bam-v1.7.0";
+ 			reg = <0x07984000 0x1a000>;
diff --git a/target/linux/ipq807x/patches-5.10/158-hwmon-Add-SMSC-EMC2301-2-3-5-fan-controller-driver.patch b/target/linux/ipq807x/patches-5.10/158-hwmon-Add-SMSC-EMC2301-2-3-5-fan-controller-driver.patch
new file mode 100644
index 0000000..8af6685
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/158-hwmon-Add-SMSC-EMC2301-2-3-5-fan-controller-driver.patch
@@ -0,0 +1,51 @@
+From a58b73b20db06f91025c5c847fcf2b53e341a6ff Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Mon, 14 Jun 2021 19:01:14 +0200
+Subject: [PATCH] hwmon: Add SMSC EMC2301/2/3/5 fan controller driver
+
+Add support for SMSC EMC2305, EMC2303, EMC2302, EMC2301 fan controller
+chips.
+The driver primary supports the EMC2305 chip which provides RPM-based
+PWM control and monitoring for up to 5 fans.
+
+According to the SMSC data sheets the EMC2303, EMC2302 and EMC2301 chips
+have basically the same functionality and register layout, but support
+less fans and (in case of EMC2302 and EMC2301) less possible I2C addresses.
+The driver supports them, too.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ drivers/hwmon/Kconfig  | 11 +++++++++++
+ drivers/hwmon/Makefile |  1 +
+ 2 files changed, 12 insertions(+)
+
+--- a/drivers/hwmon/Kconfig
++++ b/drivers/hwmon/Kconfig
+@@ -1601,6 +1601,17 @@ config SENSORS_EMC2103
+ 	  This driver can also be built as a module. If so, the module
+ 	  will be called emc2103.
+ 
++config SENSORS_EMC2305
++	tristate "SMSC EMC2305"
++	depends on I2C
++	select REGMAP_I2C
++	help
++	  If you say yes here you get support for the fan monitoring
++	  and control features of the SMSC EMC2301/2/3/5 chips.
++
++	  This driver can also be built as a module. If so, the module
++	  will be called emc2305.
++
+ config SENSORS_EMC6W201
+ 	tristate "SMSC EMC6W201"
+ 	depends on I2C
+--- a/drivers/hwmon/Makefile
++++ b/drivers/hwmon/Makefile
+@@ -66,6 +66,7 @@ obj-$(CONFIG_SENSORS_DS620)	+= ds620.o
+ obj-$(CONFIG_SENSORS_DS1621)	+= ds1621.o
+ obj-$(CONFIG_SENSORS_EMC1403)	+= emc1403.o
+ obj-$(CONFIG_SENSORS_EMC2103)	+= emc2103.o
++obj-$(CONFIG_SENSORS_EMC2305)	+= emc2305.o
+ obj-$(CONFIG_SENSORS_EMC6W201)	+= emc6w201.o
+ obj-$(CONFIG_SENSORS_F71805F)	+= f71805f.o
+ obj-$(CONFIG_SENSORS_F71882FG)	+= f71882fg.o
diff --git a/target/linux/ipq807x/patches-5.10/159-PCI-qcom-Do-PHY-power-on-before-PCIe-init.patch b/target/linux/ipq807x/patches-5.10/159-PCI-qcom-Do-PHY-power-on-before-PCIe-init.patch
new file mode 100644
index 0000000..cb903f0
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/159-PCI-qcom-Do-PHY-power-on-before-PCIe-init.patch
@@ -0,0 +1,60 @@
+From 7d94f8748116ebb9e81629d7c8dd5fe5f63648aa Mon Sep 17 00:00:00 2001
+From: Sivaprakash Murugesan <sivaprak@codeaurora.org>
+Date: Sat, 26 Jun 2021 00:42:33 +0200
+Subject: [PATCH] PCI: qcom: Do PHY power on before PCIe init
+
+Commit cc1e06f033af ("phy: qcom: qmp: Use power_on/off ops for PCIe")
+changed phy ops from init/deinit to power on/off, due to this phy enable
+is getting called after PCIe init.
+
+On some platforms like ipq8074 phy should be inited before accessing the
+PCIe register space, otherwise the system would hang.
+
+So move phy_power_on API before PCIe init.
+
+Fixes: commit cc1e06f033af ("phy: qcom: qmp: Use power_on/off ops for PCIe")
+Co-developed-by: Selvam Sathappan Periakaruppan <speriaka@codeaurora.org>
+Signed-off-by: Selvam Sathappan Periakaruppan <speriaka@codeaurora.org>
+Signed-off-by: Sivaprakash Murugesan <sivaprak@codeaurora.org>
+---
+ drivers/pci/controller/dwc/pcie-qcom.c | 12 ++++++------
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+--- a/drivers/pci/controller/dwc/pcie-qcom.c
++++ b/drivers/pci/controller/dwc/pcie-qcom.c
+@@ -1411,18 +1411,18 @@ static int qcom_pcie_host_init(struct pc
+ 
+ 	qcom_ep_reset_assert(pcie);
+ 
+-	ret = pcie->ops->init(pcie);
++	ret = phy_power_on(pcie->phy);
+ 	if (ret)
+ 		return ret;
+ 
+-	ret = phy_power_on(pcie->phy);
++	ret = pcie->ops->init(pcie);
+ 	if (ret)
+-		goto err_deinit;
++		goto err_disable_phy;
+ 
+ 	if (pcie->ops->post_init) {
+ 		ret = pcie->ops->post_init(pcie);
+ 		if (ret)
+-			goto err_disable_phy;
++			goto err_deinit;
+ 	}
+ 
+ 	dw_pcie_setup_rc(pp);
+@@ -1430,10 +1430,10 @@ static int qcom_pcie_host_init(struct pc
+ 
+ 	return 0;
+ 
+-err_disable_phy:
+-	phy_power_off(pcie->phy);
+ err_deinit:
+ 	pcie->ops->deinit(pcie);
++err_disable_phy:
++	phy_power_off(pcie->phy);
+ 
+ 	return ret;
+ }
diff --git a/target/linux/ipq807x/patches-5.10/160-PCI-qcom-Make-sure-PCI-is-reset-and-clocks-are-enabl.patch b/target/linux/ipq807x/patches-5.10/160-PCI-qcom-Make-sure-PCI-is-reset-and-clocks-are-enabl.patch
new file mode 100644
index 0000000..654327b
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/160-PCI-qcom-Make-sure-PCI-is-reset-and-clocks-are-enabl.patch
@@ -0,0 +1,39 @@
+From 26becdb00a29d53a23fd06e67e9750d167fe982d Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Sat, 26 Jun 2021 00:51:32 +0200
+Subject: [PATCH] PCI: qcom: Make sure PCI is reset and clocks are enabled
+ before init for IP 2.3.3
+
+IPQ8074 which uses IP 2.3.3 requires that the PHY is
+powered on, resets are asserted as bootloader can
+leave them in a weird state and clocks are enabled
+before accessing the register space.
+
+Otherwise the system would simply hang on a DBI read.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ drivers/pci/controller/dwc/pcie-qcom.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+--- a/drivers/pci/controller/dwc/pcie-qcom.c
++++ b/drivers/pci/controller/dwc/pcie-qcom.c
+@@ -1035,7 +1035,7 @@ static int qcom_pcie_init_2_3_3(struct q
+ 	struct qcom_pcie_resources_2_3_3 *res = &pcie->res.v2_3_3;
+ 	struct dw_pcie *pci = pcie->pci;
+ 	struct device *dev = pci->dev;
+-	u16 offset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);
++	u16 offset;
+ 	int i, ret;
+ 	u32 val;
+ 
+@@ -1111,6 +1111,9 @@ static int qcom_pcie_init_2_3_3(struct q
+ 
+ 	writel(PCI_COMMAND_MASTER, pci->dbi_base + PCI_COMMAND);
+ 	writel(DBI_RO_WR_EN, pci->dbi_base + PCIE20_MISC_CONTROL_1_REG);
++
++	offset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);
++
+ 	writel(PCIE_CAP_LINK1_VAL, pci->dbi_base + offset + PCI_EXP_SLTCAP);
+ 
+ 	val = readl(pci->dbi_base + offset + PCI_EXP_LNKCAP);
diff --git a/target/linux/ipq807x/patches-5.10/600-qca-nss-ecm-support-CORE.patch b/target/linux/ipq807x/patches-5.10/600-qca-nss-ecm-support-CORE.patch
new file mode 100644
index 0000000..0df2d4e
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/600-qca-nss-ecm-support-CORE.patch
@@ -0,0 +1,722 @@
+--- a/net/netfilter/nf_conntrack_proto_tcp.c
++++ b/net/netfilter/nf_conntrack_proto_tcp.c
+@@ -32,20 +32,14 @@
+ #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+ 
+ /* Do not check the TCP window for incoming packets  */
+-static int nf_ct_tcp_no_window_check __read_mostly = 1;
+-
+-#ifdef CONFIG_SHORTCUT_FE
++int nf_ct_tcp_no_window_check __read_mostly = 1;
+ EXPORT_SYMBOL_GPL(nf_ct_tcp_no_window_check);
+-#endif
+ 
+ /* "Be conservative in what you do,
+     be liberal in what you accept from others."
+     If it's non-zero, we mark only out of window RST segments as INVALID. */
+-static int nf_ct_tcp_be_liberal __read_mostly = 0;
+-
+-#ifdef CONFIG_SHORTCUT_FE
++int nf_ct_tcp_be_liberal __read_mostly = 0;
+ EXPORT_SYMBOL_GPL(nf_ct_tcp_be_liberal);
+-#endif
+ 
+ /* If it is set to zero, we disable picking up already established
+    connections. */
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -63,6 +63,7 @@ extern void brioctl_set(int (*ioctl_hook
+ 
+ extern void br_dev_update_stats(struct net_device *dev,
+ 				struct rtnl_link_stats64 *nlstats);
++extern bool br_is_hairpin_enabled(struct net_device *dev);
+ 
+ #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
+ int br_multicast_list_adjacent(struct net_device *dev,
+@@ -158,4 +159,41 @@ br_port_flag_is_set(const struct net_dev
+ }
+ #endif
+ 
++/* QCA NSS ECM support - Start */
++extern struct net_device *br_port_dev_get(struct net_device *dev,
++					  unsigned char *addr,
++					  struct sk_buff *skb,
++					  unsigned int cookie);
++extern void br_refresh_fdb_entry(struct net_device *dev, const char *addr);
++extern struct net_bridge_fdb_entry *br_fdb_has_entry(struct net_device *dev,
++						     const char *addr,
++						     __u16 vid);
++extern void br_fdb_update_register_notify(struct notifier_block *nb);
++extern void br_fdb_update_unregister_notify(struct notifier_block *nb);
++
++typedef struct net_bridge_port *br_port_dev_get_hook_t(struct net_device *dev,
++						       struct sk_buff *skb,
++						       unsigned char *addr,
++						       unsigned int cookie);
++extern br_port_dev_get_hook_t __rcu *br_port_dev_get_hook;
++
++#define BR_FDB_EVENT_ADD     0x01
++#define BR_FDB_EVENT_DEL     0x02
++
++struct br_fdb_event {
++	struct net_device *dev;
++	unsigned char      addr[6];
++	unsigned char      is_local;
++	struct net_bridge *br;
++	struct net_device *orig_dev;
++};
++extern void br_fdb_register_notify(struct notifier_block *nb);
++extern void br_fdb_unregister_notify(struct notifier_block *nb);
++
++typedef struct net_bridge_port *br_get_dst_hook_t(
++		const struct net_bridge_port *src,
++		struct sk_buff **skb);
++extern br_get_dst_hook_t __rcu *br_get_dst_hook;
++/* QCA NSS ECM support - End */
++
+ #endif
+--- a/include/linux/if_vlan.h
++++ b/include/linux/if_vlan.h
+@@ -222,7 +222,28 @@ extern void vlan_vids_del_by_dev(struct
+ 
+ extern bool vlan_uses_dev(const struct net_device *dev);
+ 
++/* QCA NSS ECM support - Start */
++extern void __vlan_dev_update_accel_stats(struct net_device *dev,
++                                    struct rtnl_link_stats64 *stats);
++extern u16 vlan_dev_get_egress_prio(struct net_device *dev, u32 skb_prio);
++extern struct net_device *vlan_dev_next_dev(const struct net_device *dev);
++/* QCA NSS ECM support - End */
++
+ #else
++/* QCA NSS ECM support - Start */
++static inline void __vlan_dev_update_accel_stats(struct net_device *dev,
++					   struct rtnl_link_stats64 *stats)
++{
++
++}
++
++static inline u16 vlan_dev_get_egress_prio(struct net_device *dev,
++						u32 skb_prio)
++{
++	return 0;
++}
++/* QCA NSS ECM support - End */
++
+ static inline struct net_device *
+ __vlan_find_dev_deep_rcu(struct net_device *real_dev,
+ 		     __be16 vlan_proto, u16 vlan_id)
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -2745,6 +2745,10 @@ enum netdev_cmd {
+ 	NETDEV_CVLAN_FILTER_DROP_INFO,
+ 	NETDEV_SVLAN_FILTER_PUSH_INFO,
+ 	NETDEV_SVLAN_FILTER_DROP_INFO,
++	/* QCA NSS ECM Support - Start */
++	NETDEV_BR_JOIN,
++	NETDEV_BR_LEAVE,
++	/* QCA NSS ECM Support - End */
+ };
+ const char *netdev_cmd_to_name(enum netdev_cmd cmd);
+ 
+--- a/include/net/ip6_route.h
++++ b/include/net/ip6_route.h
+@@ -210,6 +210,11 @@ void rt6_multipath_rebalance(struct fib6
+ void rt6_uncached_list_add(struct rt6_info *rt);
+ void rt6_uncached_list_del(struct rt6_info *rt);
+ 
++/* QCA NSS ECM support - Start */
++int rt6_register_notifier(struct notifier_block *nb);
++int rt6_unregister_notifier(struct notifier_block *nb);
++/* QCA NSS ECM support - End */
++
+ static inline const struct rt6_info *skb_rt6_info(const struct sk_buff *skb)
+ {
+ 	const struct dst_entry *dst = skb_dst(skb);
+--- a/include/net/neighbour.h
++++ b/include/net/neighbour.h
+@@ -568,4 +568,15 @@ static inline void neigh_update_is_route
+ 		*notify = 1;
+ 	}
+ }
++
++/* QCA NSS ECM support - Start */
++struct neigh_mac_update {
++	unsigned char old_mac[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))];
++	unsigned char update_mac[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))];
++};
++
++extern void neigh_mac_update_register_notify(struct notifier_block *nb);
++extern void neigh_mac_update_unregister_notify(struct notifier_block *nb);
++/* QCA NSS ECM support - End */
++
+ #endif
+--- a/include/net/route.h
++++ b/include/net/route.h
+@@ -234,6 +234,11 @@ struct rtable *rt_dst_alloc(struct net_d
+ 			     bool nopolicy, bool noxfrm);
+ struct rtable *rt_dst_clone(struct net_device *dev, struct rtable *rt);
+ 
++/* QCA NSS ECM support - Start */
++int ip_rt_register_notifier(struct notifier_block *nb);
++int ip_rt_unregister_notifier(struct notifier_block *nb);
++/* QCA NSS ECM support - End */
++
+ struct in_ifaddr;
+ void fib_add_ifaddr(struct in_ifaddr *);
+ void fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);
+--- a/net/8021q/vlan_core.c
++++ b/net/8021q/vlan_core.c
+@@ -550,4 +550,52 @@ static int __init vlan_offload_init(void
+ 	return 0;
+ }
+ 
++/* QCA NSS ECM support - Start */
++/* Update the VLAN device with statistics from network offload engines */
++void __vlan_dev_update_accel_stats(struct net_device *dev,
++				   struct rtnl_link_stats64 *nlstats)
++{
++	struct vlan_pcpu_stats *stats;
++
++	if (!is_vlan_dev(dev))
++		return;
++
++	stats = per_cpu_ptr(vlan_dev_priv(dev)->vlan_pcpu_stats, 0);
++
++	u64_stats_update_begin(&stats->syncp);
++	stats->rx_packets += nlstats->rx_packets;
++	stats->rx_bytes += nlstats->rx_bytes;
++	stats->tx_packets += nlstats->tx_packets;
++	stats->tx_bytes += nlstats->tx_bytes;
++	u64_stats_update_end(&stats->syncp);
++}
++EXPORT_SYMBOL(__vlan_dev_update_accel_stats);
++
++/* Lookup the 802.1p egress_map table and return the 802.1p value */
++u16 vlan_dev_get_egress_prio(struct net_device *dev, u32 skb_prio)
++{
++	struct vlan_priority_tci_mapping *mp;
++
++	mp = vlan_dev_priv(dev)->egress_priority_map[(skb_prio & 0xf)];
++	while (mp) {
++		if (mp->priority == skb_prio) {
++			/* This should already be shifted
++			 * to mask correctly with the
++			 * VLAN's TCI
++			 */
++			return mp->vlan_qos;
++		}
++		mp = mp->next;
++	}
++	return 0;
++}
++EXPORT_SYMBOL(vlan_dev_get_egress_prio);
++
++struct net_device *vlan_dev_next_dev(const struct net_device *dev)
++{
++	return vlan_dev_priv(dev)->real_dev;
++}
++EXPORT_SYMBOL(vlan_dev_next_dev);
++/* QCA NSS ECM support - End */
++
+ fs_initcall(vlan_offload_init);
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -37,6 +37,35 @@ static int fdb_insert(struct net_bridge
+ static void fdb_notify(struct net_bridge *br,
+ 		       const struct net_bridge_fdb_entry *, int, bool);
+ 
++/* QCA NSS ECM support - Start */
++ATOMIC_NOTIFIER_HEAD(br_fdb_notifier_list);
++ATOMIC_NOTIFIER_HEAD(br_fdb_update_notifier_list);
++
++void br_fdb_register_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_register(&br_fdb_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_register_notify);
++
++void br_fdb_unregister_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_unregister(&br_fdb_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_unregister_notify);
++
++void br_fdb_update_register_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_register(&br_fdb_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_update_register_notify);
++
++void br_fdb_update_unregister_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_unregister(&br_fdb_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_update_unregister_notify);
++/* QCA NSS ECM support - End */
++
+ int __init br_fdb_init(void)
+ {
+ 	br_fdb_cache = kmem_cache_create("bridge_fdb_cache",
+@@ -342,6 +371,7 @@ void br_fdb_cleanup(struct work_struct *
+ 	unsigned long delay = hold_time(br);
+ 	unsigned long work_delay = delay;
+ 	unsigned long now = jiffies;
++	u8 mac_addr[6]; /* QCA NSS ECM support */
+ 
+ 	/* this part is tricky, in order to avoid blocking learning and
+ 	 * consequently forwarding, we rely on rcu to delete objects with
+@@ -368,8 +398,15 @@ void br_fdb_cleanup(struct work_struct *
+ 			work_delay = min(work_delay, this_timer - now);
+ 		} else {
+ 			spin_lock_bh(&br->hash_lock);
+-			if (!hlist_unhashed(&f->fdb_node))
++			if (!hlist_unhashed(&f->fdb_node)) {
++				ether_addr_copy(mac_addr, f->key.addr.addr);
+ 				fdb_delete(br, f, true);
++				/* QCA NSS ECM support - Start */
++				atomic_notifier_call_chain(
++					&br_fdb_update_notifier_list, 0,
++					(void *)mac_addr);
++				/* QCA NSS ECM support - End */
++			}
+ 			spin_unlock_bh(&br->hash_lock);
+ 		}
+ 	}
+@@ -610,6 +647,12 @@ void br_fdb_update(struct net_bridge *br
+ 						      &fdb->flags)))
+ 					clear_bit(BR_FDB_ADDED_BY_EXT_LEARN,
+ 						  &fdb->flags);
++
++				/* QCA NSS ECM support - Start */
++				atomic_notifier_call_chain(
++					&br_fdb_update_notifier_list,
++					0, (void *)addr);
++				/* QCA NSS ECM support - End */
+ 			}
+ 
+ 			if (unlikely(test_bit(BR_FDB_ADDED_BY_USER, &flags)))
+@@ -734,6 +777,25 @@ static void fdb_notify(struct net_bridge
+ 	struct sk_buff *skb;
+ 	int err = -ENOBUFS;
+ 
++	/* QCA NSS ECM support - Start */
++	if (fdb->dst) {
++		int event;
++		struct br_fdb_event fdb_event;
++
++		if (type == RTM_NEWNEIGH)
++			event = BR_FDB_EVENT_ADD;
++		else
++			event = BR_FDB_EVENT_DEL;
++
++		fdb_event.dev = fdb->dst->dev;
++		ether_addr_copy(fdb_event.addr, fdb->key.addr.addr);
++		fdb_event.is_local = test_bit(BR_FDB_LOCAL, &fdb->flags);
++		atomic_notifier_call_chain(&br_fdb_notifier_list,
++					   event,
++					   (void *)&fdb_event);
++	}
++	/* QCA NSS ECM support - End */
++
+ 	if (swdev_notify)
+ 		br_switchdev_fdb_notify(br, fdb, type);
+ 
+@@ -1302,3 +1364,44 @@ void br_fdb_clear_offload(const struct n
+ 	spin_unlock_bh(&p->br->hash_lock);
+ }
+ EXPORT_SYMBOL_GPL(br_fdb_clear_offload);
++
++/* QCA NSS ECM support - Start */
++/* Refresh FDB entries for bridge packets being forwarded by offload engines */
++void br_refresh_fdb_entry(struct net_device *dev, const char *addr)
++{
++	struct net_bridge_port *p = br_port_get_rcu(dev);
++
++	if (!p || p->state == BR_STATE_DISABLED)
++		return;
++
++	if (!is_valid_ether_addr(addr)) {
++		pr_info("bridge: Attempt to refresh with invalid ether address %pM\n",
++			addr);
++		return;
++	}
++
++	rcu_read_lock();
++	br_fdb_update(p->br, p, addr, 0, true);
++	rcu_read_unlock();
++}
++EXPORT_SYMBOL_GPL(br_refresh_fdb_entry);
++
++/* Look up the MAC address in the device's bridge fdb table */
++struct net_bridge_fdb_entry *br_fdb_has_entry(struct net_device *dev,
++					      const char *addr, __u16 vid)
++{
++	struct net_bridge_port *p = br_port_get_rcu(dev);
++	struct net_bridge_fdb_entry *fdb;
++
++	if (!p || p->state == BR_STATE_DISABLED)
++		return NULL;
++
++	rcu_read_lock();
++	fdb = fdb_find_rcu(&p->br->fdb_hash_tbl, addr, vid);
++	rcu_read_unlock();
++
++	return fdb;
++}
++EXPORT_SYMBOL_GPL(br_fdb_has_entry);
++/* QCA NSS ECM support - End */
++
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -26,6 +26,12 @@
+ 
+ #include "br_private.h"
+ 
++/* QCA NSS ECM support - Start */
++/* Hook for external forwarding logic */
++br_port_dev_get_hook_t __rcu *br_port_dev_get_hook __read_mostly;
++EXPORT_SYMBOL_GPL(br_port_dev_get_hook);
++/* QCA NSS ECM support - End */
++
+ /*
+  * Determine initial path cost based on speed.
+  * using recommendations from 802.1d standard
+@@ -710,6 +716,8 @@ int br_add_if(struct net_bridge *br, str
+ 
+ 	kobject_uevent(&p->kobj, KOBJ_ADD);
+ 
++	call_netdevice_notifiers(NETDEV_BR_JOIN, dev); /* QCA NSS ECM support */
++
+ 	return 0;
+ 
+ err7:
+@@ -745,6 +753,8 @@ int br_del_if(struct net_bridge *br, str
+ 	if (!p || p->br != br)
+ 		return -EINVAL;
+ 
++	call_netdevice_notifiers(NETDEV_BR_LEAVE, dev); /* QCA NSS ECM support */
++
+ 	/* Since more than one interface can be attached to a bridge,
+ 	 * there still maybe an alternate path for netconsole to use;
+ 	 * therefore there is no reason for a NETDEV_RELEASE event.
+@@ -795,3 +805,74 @@ bool br_port_flag_is_set(const struct ne
+ 	return p->flags & flag;
+ }
+ EXPORT_SYMBOL_GPL(br_port_flag_is_set);
++
++/* API to know if hairpin feature is enabled/disabled on this bridge port */
++bool br_is_hairpin_enabled(struct net_device *dev)
++{
++	struct net_bridge_port *port = br_port_get_check_rcu(dev);
++
++	if (likely(port))
++		return port->flags & BR_HAIRPIN_MODE;
++	return false;
++}
++EXPORT_SYMBOL_GPL(br_is_hairpin_enabled);
++
++/* br_port_dev_get()
++ *      If a skb is provided, and the br_port_dev_get_hook_t hook exists,
++ *      use that to try and determine the egress port for that skb.
++ *      If not, or no egress port could be determined, use the given addr
++ *      to identify the port to which it is reachable,
++ *	returing a reference to the net device associated with that port.
++ *
++ * NOTE: Return NULL if given dev is not a bridge or the mac has no
++ * associated port.
++ */
++struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr,
++				   struct sk_buff *skb,
++				   unsigned int cookie)
++{
++	struct net_bridge_fdb_entry *fdbe;
++	struct net_bridge *br;
++	struct net_device *netdev = NULL;
++
++	/* Is this a bridge? */
++	if (!(dev->priv_flags & IFF_EBRIDGE))
++		return NULL;
++
++	rcu_read_lock();
++
++	/* If the hook exists and the skb isn't NULL, try and get the port */
++	if (skb) {
++		br_port_dev_get_hook_t *port_dev_get_hook;
++
++		port_dev_get_hook = rcu_dereference(br_port_dev_get_hook);
++		if (port_dev_get_hook) {
++			struct net_bridge_port *pdst =
++				__br_get(port_dev_get_hook, NULL, dev, skb,
++					 addr, cookie);
++			if (pdst) {
++				dev_hold(pdst->dev);
++				netdev = pdst->dev;
++				goto out;
++			}
++		}
++	}
++
++	/* Either there is no hook, or can't
++	 * determine the port to use - fall back to using FDB
++	 */
++
++	br = netdev_priv(dev);
++
++	/* Lookup the fdb entry and get reference to the port dev */
++	fdbe = br_fdb_find_rcu(br, addr, 0);
++	if (fdbe && fdbe->dst) {
++		netdev = fdbe->dst->dev; /* port device */
++		dev_hold(netdev);
++	}
++out:
++	rcu_read_unlock();
++	return netdev;
++}
++EXPORT_SYMBOL_GPL(br_port_dev_get);
++/* QCA NSS ECM support - End */
+--- a/net/bridge/br_private.h
++++ b/net/bridge/br_private.h
+@@ -1593,4 +1593,9 @@ void br_do_proxy_suppress_arp(struct sk_
+ void br_do_suppress_nd(struct sk_buff *skb, struct net_bridge *br,
+ 		       u16 vid, struct net_bridge_port *p, struct nd_msg *msg);
+ struct nd_msg *br_is_nd_neigh_msg(struct sk_buff *skb, struct nd_msg *m);
++
++/* QCA NSS ECM support - Start */
++#define __br_get(__hook, __default, __args ...) \
++		(__hook ? (__hook(__args)) : (__default))
++/* QCA NSS ECM support - End */
+ #endif
+--- a/net/core/neighbour.c
++++ b/net/core/neighbour.c
+@@ -1210,7 +1210,21 @@ static void neigh_update_hhs(struct neig
+ 	}
+ }
+ 
++/* QCA NSS ECM support - start */
++ATOMIC_NOTIFIER_HEAD(neigh_mac_update_notifier_list);
++ 
++void neigh_mac_update_register_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_register(&neigh_mac_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(neigh_mac_update_register_notify);
+ 
++void neigh_mac_update_unregister_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_unregister(&neigh_mac_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(neigh_mac_update_unregister_notify);
++/* QCA NSS ECM support - End */
+ 
+ /* Generic update routine.
+    -- lladdr is new lladdr or NULL, if it is not supplied.
+@@ -1241,6 +1255,7 @@ static int __neigh_update(struct neighbo
+ 	int notify = 0;
+ 	struct net_device *dev;
+ 	int update_isrouter = 0;
++	struct neigh_mac_update nmu; /* QCA NSS ECM support */
+ 
+ 	trace_neigh_update(neigh, lladdr, new, flags, nlmsg_pid);
+ 
+@@ -1255,6 +1270,8 @@ static int __neigh_update(struct neighbo
+ 		new = old;
+ 		goto out;
+ 	}
++	memset(&nmu, 0, sizeof(struct neigh_mac_update)); /* QCA NSS ECM support */
++
+ 	if (!(flags & NEIGH_UPDATE_F_ADMIN) &&
+ 	    (old & (NUD_NOARP | NUD_PERMANENT)))
+ 		goto out;
+@@ -1286,6 +1303,11 @@ static int __neigh_update(struct neighbo
+ 		   - compare new & old
+ 		   - if they are different, check override flag
+ 		 */
++		/* QCA NSS ECM update - Start */
++		memcpy(nmu.old_mac, neigh->ha, dev->addr_len);
++		memcpy(nmu.update_mac, lladdr, dev->addr_len);
++		/* QCA NSS ECM update - End */
++
+ 		if ((old & NUD_VALID) &&
+ 		    !memcmp(lladdr, neigh->ha, dev->addr_len))
+ 			lladdr = neigh->ha;
+@@ -1408,8 +1430,11 @@ out:
+ 	if (((new ^ old) & NUD_PERMANENT) || ext_learn_change)
+ 		neigh_update_gc_list(neigh);
+ 
+-	if (notify)
++	if (notify) {
+ 		neigh_update_notify(neigh, nlmsg_pid);
++		atomic_notifier_call_chain(&neigh_mac_update_notifier_list, 0,
++					   (struct neigh_mac_update *)&nmu); /* QCA NSS ECM support */
++	}
+ 
+ 	trace_neigh_update_done(neigh, err);
+ 
+--- a/net/ipv4/fib_trie.c
++++ b/net/ipv4/fib_trie.c
+@@ -1164,6 +1164,9 @@ static bool fib_valid_key_len(u32 key, u
+ static void fib_remove_alias(struct trie *t, struct key_vector *tp,
+ 			     struct key_vector *l, struct fib_alias *old);
+ 
++/* Define route change notification chain. */
++static BLOCKING_NOTIFIER_HEAD(iproute_chain);	/* QCA NSS ECM support */
++
+ /* Caller must hold RTNL. */
+ int fib_table_insert(struct net *net, struct fib_table *tb,
+ 		     struct fib_config *cfg, struct netlink_ext_ack *extack)
+@@ -1352,6 +1355,9 @@ int fib_table_insert(struct net *net, st
+ 	rtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, new_fa->tb_id,
+ 		  &cfg->fc_nlinfo, nlflags);
+ succeeded:
++	blocking_notifier_call_chain(&iproute_chain,
++				     RTM_NEWROUTE, fi);
++
+ 	return 0;
+ 
+ out_remove_new_fa:
+@@ -1722,6 +1728,9 @@ int fib_table_delete(struct net *net, st
+ 	if (fa_to_delete->fa_state & FA_S_ACCESSED)
+ 		rt_cache_flush(cfg->fc_nlinfo.nl_net);
+ 
++	blocking_notifier_call_chain(&iproute_chain,
++				     RTM_DELROUTE, fa_to_delete->fa_info);
++
+ 	fib_release_info(fa_to_delete->fa_info);
+ 	alias_free_mem_rcu(fa_to_delete);
+ 	return 0;
+@@ -2358,6 +2367,20 @@ void __init fib_trie_init(void)
+ 					   0, SLAB_PANIC, NULL);
+ }
+ 
++/* QCA NSS ECM support - Start */
++int ip_rt_register_notifier(struct notifier_block *nb)
++{
++	return blocking_notifier_chain_register(&iproute_chain, nb);
++}
++EXPORT_SYMBOL(ip_rt_register_notifier);
++
++int ip_rt_unregister_notifier(struct notifier_block *nb)
++{
++	return blocking_notifier_chain_unregister(&iproute_chain, nb);
++}
++EXPORT_SYMBOL(ip_rt_unregister_notifier);
++/* QCA NSS ECM support - End */
++
+ struct fib_table *fib_trie_table(u32 id, struct fib_table *alias)
+ {
+ 	struct fib_table *tb;
+--- a/include/net/addrconf.h
++++ b/include/net/addrconf.h
+@@ -501,4 +501,9 @@ int if6_proc_init(void);
+ void if6_proc_exit(void);
+ #endif
+ 
++/* QCA NSS ECM support - Start */
++struct net_device *ipv6_dev_find_and_hold(struct net *net, struct in6_addr *addr,
++				 int strict);
++/* QCA NSS ECM support - End */
++
+ #endif
+--- a/net/ipv6/addrconf.c
++++ b/net/ipv6/addrconf.c
+@@ -7233,3 +7233,35 @@ void addrconf_cleanup(void)
+ 
+ 	destroy_workqueue(addrconf_wq);
+ }
++
++/* QCA NSS ECM support - Start */
++/* ipv6_dev_find_and_hold()
++ *	Find (and hold) net device that has the given address.
++ *	Or NULL on failure.
++ */
++struct net_device *ipv6_dev_find_and_hold(struct net *net, struct in6_addr *addr,
++				 int strict)
++{
++	struct inet6_ifaddr *ifp;
++	struct net_device *dev;
++
++	ifp = ipv6_get_ifaddr(net, addr, NULL, strict);
++	if (!ifp)
++		return NULL;
++
++	if (!ifp->idev) {
++		in6_ifa_put(ifp);
++		return NULL;
++	}
++
++	dev = ifp->idev->dev;
++	if (dev)
++		dev_hold(dev);
++
++	in6_ifa_put(ifp);
++
++	return dev;
++}
++EXPORT_SYMBOL(ipv6_dev_find_and_hold);
++/* QCA NSS ECM support - End */
++
+--- a/net/ipv6/ndisc.c
++++ b/net/ipv6/ndisc.c
+@@ -649,6 +649,7 @@ void ndisc_send_ns(struct net_device *de
+ 
+ 	ndisc_send_skb(skb, daddr, saddr);
+ }
++EXPORT_SYMBOL(ndisc_send_ns);
+ 
+ void ndisc_send_rs(struct net_device *dev, const struct in6_addr *saddr,
+ 		   const struct in6_addr *daddr)
+--- a/net/ipv6/route.c
++++ b/net/ipv6/route.c
+@@ -3737,6 +3737,9 @@ out_free:
+ 	return ERR_PTR(err);
+ }
+ 
++/* Define route change notification chain. */
++ATOMIC_NOTIFIER_HEAD(ip6route_chain);	/* QCA NSS ECM support */
++
+ int ip6_route_add(struct fib6_config *cfg, gfp_t gfp_flags,
+ 		  struct netlink_ext_ack *extack)
+ {
+@@ -3748,6 +3751,10 @@ int ip6_route_add(struct fib6_config *cf
+ 		return PTR_ERR(rt);
+ 
+ 	err = __ip6_ins_rt(rt, &cfg->fc_nlinfo, extack);
++	if (!err)
++		atomic_notifier_call_chain(&ip6route_chain,
++					   RTM_NEWROUTE, rt);
++
+ 	fib6_info_release(rt);
+ 
+ 	return err;
+@@ -3769,6 +3776,9 @@ static int __ip6_del_rt(struct fib6_info
+ 	err = fib6_del(rt, info);
+ 	spin_unlock_bh(&table->tb6_lock);
+ 
++	if (!err)
++		atomic_notifier_call_chain(&ip6route_chain,
++					   RTM_DELROUTE, rt);
+ out:
+ 	fib6_info_release(rt);
+ 	return err;
+@@ -6120,6 +6130,20 @@ static int ip6_route_dev_notify(struct n
+ 	return NOTIFY_OK;
+ }
+ 
++/* QCA NSS ECM support - Start */
++int rt6_register_notifier(struct notifier_block *nb)
++{
++	return atomic_notifier_chain_register(&ip6route_chain, nb);
++}
++EXPORT_SYMBOL(rt6_register_notifier);
++
++int rt6_unregister_notifier(struct notifier_block *nb)
++{
++	return atomic_notifier_chain_unregister(&ip6route_chain, nb);
++}
++EXPORT_SYMBOL(rt6_unregister_notifier);
++/* QCA NSS ECM support - End */
++
+ /*
+  *	/proc
+  */
diff --git a/target/linux/ipq807x/patches-5.10/601-netfilter-export-udp_get_timeouts-function.patch b/target/linux/ipq807x/patches-5.10/601-netfilter-export-udp_get_timeouts-function.patch
new file mode 100644
index 0000000..7e43c85
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/601-netfilter-export-udp_get_timeouts-function.patch
@@ -0,0 +1,38 @@
+From e38488fd0a8a11b4bae4ccad9a7a8cfcf9eb5ab7 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Mon, 6 Apr 2020 11:08:09 -0700
+Subject: [PATCH] netfilter: export udp_get_timeouts function
+
+This function is required for acceleration support.
+
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Change-Id: Ibca4f402735764e7e6fb3ce2678e670753c6ef9c
+---
+ include/net/netfilter/nf_conntrack_timeout.h | 1 +
+ net/netfilter/nf_conntrack_proto_udp.c       | 3 ++-
+ 2 files changed, 3 insertions(+), 1 deletion(-)
+
+--- a/include/net/netfilter/nf_conntrack_timeout.h
++++ b/include/net/netfilter/nf_conntrack_timeout.h
+@@ -123,5 +123,6 @@ static inline void nf_ct_destroy_timeout
+ extern struct nf_ct_timeout *(*nf_ct_timeout_find_get_hook)(struct net *net, const char *name);
+ extern void (*nf_ct_timeout_put_hook)(struct nf_ct_timeout *timeout);
+ #endif
++extern unsigned int *udp_get_timeouts(struct net *net);
+ 
+ #endif /* _NF_CONNTRACK_TIMEOUT_H */
+--- a/net/netfilter/nf_conntrack_proto_udp.c
++++ b/net/netfilter/nf_conntrack_proto_udp.c
+@@ -29,10 +29,11 @@ static const unsigned int udp_timeouts[U
+ 	[UDP_CT_REPLIED]	= 120*HZ,
+ };
+ 
+-static unsigned int *udp_get_timeouts(struct net *net)
++unsigned int *udp_get_timeouts(struct net *net)
+ {
+ 	return nf_udp_pernet(net)->timeouts;
+ }
++EXPORT_SYMBOL(udp_get_timeouts);
+ 
+ static void udp_error_log(const struct sk_buff *skb,
+ 			  const struct nf_hook_state *state,
diff --git a/target/linux/ipq807x/patches-5.10/602-qca-add-pppoe-offload-support.patch b/target/linux/ipq807x/patches-5.10/602-qca-add-pppoe-offload-support.patch
new file mode 100644
index 0000000..b75327b
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/602-qca-add-pppoe-offload-support.patch
@@ -0,0 +1,588 @@
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -48,6 +48,7 @@
+ #include <net/slhc_vj.h>
+ #include <linux/atomic.h>
+ #include <linux/refcount.h>
++#include <linux/if_pppox.h>
+ 
+ #include <linux/nsproxy.h>
+ #include <net/net_namespace.h>
+@@ -250,6 +251,25 @@ struct ppp_net {
+ #define seq_before(a, b)	((s32)((a) - (b)) < 0)
+ #define seq_after(a, b)		((s32)((a) - (b)) > 0)
+ 
++
++/*
++ * Registration/Unregistration methods
++ * for PPP channel connect and disconnect event notifications.
++ */
++RAW_NOTIFIER_HEAD(ppp_channel_connection_notifier_list);
++
++void ppp_channel_connection_register_notify(struct notifier_block *nb)
++{
++	raw_notifier_chain_register(&ppp_channel_connection_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(ppp_channel_connection_register_notify);
++
++void ppp_channel_connection_unregister_notify(struct notifier_block *nb)
++{
++	raw_notifier_chain_unregister(&ppp_channel_connection_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(ppp_channel_connection_unregister_notify);
++
+ /* Prototypes. */
+ static int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,
+ 			struct file *file, unsigned int cmd, unsigned long arg);
+@@ -3283,7 +3303,10 @@ ppp_connect_channel(struct channel *pch,
+ 	struct ppp_net *pn;
+ 	int ret = -ENXIO;
+ 	int hdrlen;
++	int ppp_proto;
++	int version;
+ 
++	int notify = 0;
+ 	pn = ppp_pernet(pch->chan_net);
+ 
+ 	mutex_lock(&pn->all_ppp_mutex);
+@@ -3314,13 +3337,40 @@ ppp_connect_channel(struct channel *pch,
+ 	++ppp->n_channels;
+ 	pch->ppp = ppp;
+ 	refcount_inc(&ppp->file.refcnt);
++
++	/* Set the netdev priv flag if the prototype
++	 * is L2TP or PPTP. Return success in all cases
++	 */
++	if (!pch->chan)
++		goto out2;
++
++	ppp_proto = ppp_channel_get_protocol(pch->chan);
++	if (ppp_proto == PX_PROTO_PPTP) {
++		ppp->dev->priv_flags_ext |= IFF_EXT_PPP_PPTP;
++	} else if (ppp_proto == PX_PROTO_OL2TP) {
++		version = ppp_channel_get_proto_version(pch->chan);
++		if (version == 2)
++			ppp->dev->priv_flags_ext |= IFF_EXT_PPP_L2TPV2;
++		else if (version == 3)
++			ppp->dev->priv_flags_ext |= IFF_EXT_PPP_L2TPV3;
++	}
++	notify = 1;
++
++ out2:
+ 	ppp_unlock(ppp);
+ 	ret = 0;
+-
+  outl:
+ 	write_unlock_bh(&pch->upl);
+  out:
+ 	mutex_unlock(&pn->all_ppp_mutex);
++
++	if (notify && ppp && ppp->dev) {
++		dev_hold(ppp->dev);
++		raw_notifier_call_chain(&ppp_channel_connection_notifier_list,
++					   PPP_CHANNEL_CONNECT, ppp->dev);
++		dev_put(ppp->dev);
++	}
++
+ 	return ret;
+ }
+ 
+@@ -3338,6 +3388,13 @@ ppp_disconnect_channel(struct channel *p
+ 	pch->ppp = NULL;
+ 	write_unlock_bh(&pch->upl);
+ 	if (ppp) {
++		if (ppp->dev) {
++			dev_hold(ppp->dev);
++			raw_notifier_call_chain(&ppp_channel_connection_notifier_list,
++					   PPP_CHANNEL_DISCONNECT, ppp->dev);
++			dev_put(ppp->dev);
++		}
++
+ 		/* remove it from the ppp unit's list */
+ 		ppp_lock(ppp);
+ 		list_del(&pch->clist);
+@@ -3417,6 +3474,222 @@ static void *unit_find(struct idr *p, in
+ 	return idr_find(p, n);
+ }
+ 
++/* Updates the PPP interface statistics. */
++void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
++		      unsigned long rx_bytes, unsigned long tx_packets,
++		      unsigned long tx_bytes, unsigned long rx_errors,
++		      unsigned long tx_errors, unsigned long rx_dropped,
++		      unsigned long tx_dropped)
++{
++	struct ppp *ppp;
++
++	if (!dev)
++		return;
++
++	if (dev->type != ARPHRD_PPP)
++		return;
++
++	ppp = netdev_priv(dev);
++
++	ppp_xmit_lock(ppp);
++	ppp->stats64.tx_packets += tx_packets;
++	ppp->stats64.tx_bytes += tx_bytes;
++	ppp->dev->stats.tx_errors += tx_errors;
++	ppp->dev->stats.tx_dropped += tx_dropped;
++	if (tx_packets)
++		ppp->last_xmit = jiffies;
++	ppp_xmit_unlock(ppp);
++
++	ppp_recv_lock(ppp);
++	ppp->stats64.rx_packets += rx_packets;
++	ppp->stats64.rx_bytes += rx_bytes;
++	ppp->dev->stats.rx_errors += rx_errors;
++	ppp->dev->stats.rx_dropped += rx_dropped;
++	if (rx_packets)
++		ppp->last_recv = jiffies;
++	ppp_recv_unlock(ppp);
++}
++
++/* Returns >0 if the device is a multilink PPP netdevice, 0 if not or < 0 if
++ * the device is not PPP.
++ */
++int ppp_is_multilink(struct net_device *dev)
++{
++	struct ppp *ppp;
++	unsigned int flags;
++
++	if (!dev)
++		return -1;
++
++	if (dev->type != ARPHRD_PPP)
++		return -1;
++
++	ppp = netdev_priv(dev);
++	ppp_lock(ppp);
++	flags = ppp->flags;
++	ppp_unlock(ppp);
++
++	if (flags & SC_MULTILINK)
++		return 1;
++
++	return 0;
++}
++EXPORT_SYMBOL(ppp_is_multilink);
++
++/* ppp_channel_get_protocol()
++ *	Call this to obtain the underlying protocol of the PPP channel,
++ *	e.g. PX_PROTO_OE
++ *
++ * NOTE: Some channels do not use PX sockets so the protocol value may be very
++ * different for them.
++ * NOTE: -1 indicates failure.
++ * NOTE: Once you know the channel protocol you may then either cast 'chan' to
++ * its sub-class or use the channel protocol specific API's as provided by that
++ * channel sub type.
++ */
++int ppp_channel_get_protocol(struct ppp_channel *chan)
++{
++	if (!chan->ops->get_channel_protocol)
++		return -1;
++
++	return chan->ops->get_channel_protocol(chan);
++}
++EXPORT_SYMBOL(ppp_channel_get_protocol);
++
++/* ppp_channel_get_proto_version()
++ *	Call this to get channel protocol version
++ */
++int ppp_channel_get_proto_version(struct ppp_channel *chan)
++{
++	if (!chan->ops->get_channel_protocol_ver)
++		return -1;
++
++	return chan->ops->get_channel_protocol_ver(chan);
++}
++EXPORT_SYMBOL(ppp_channel_get_proto_version);
++
++/* ppp_channel_hold()
++ *	Call this to hold a channel.
++ *
++ * Returns true on success or false if the hold could not happen.
++ *
++ * NOTE: chan must be protected against destruction during this call -
++ * either by correct locking etc. or because you already have an implicit
++ * or explicit hold to the channel already and this is an additional hold.
++ */
++bool ppp_channel_hold(struct ppp_channel *chan)
++{
++	if (!chan->ops->hold)
++		return false;
++
++	chan->ops->hold(chan);
++	return true;
++}
++EXPORT_SYMBOL(ppp_channel_hold);
++
++/* ppp_channel_release()
++ *	Call this to release a hold you have upon a channel
++ */
++void ppp_channel_release(struct ppp_channel *chan)
++{
++	chan->ops->release(chan);
++}
++EXPORT_SYMBOL(ppp_channel_release);
++
++/* Check if ppp xmit lock is on hold */
++bool ppp_is_xmit_locked(struct net_device *dev)
++{
++	struct ppp *ppp;
++
++	if (!dev)
++		return false;
++
++	if (dev->type != ARPHRD_PPP)
++		return false;
++
++	ppp = netdev_priv(dev);
++	if (!ppp)
++		return false;
++
++	if (spin_is_locked(&(ppp)->wlock))
++		return true;
++
++	return false;
++}
++EXPORT_SYMBOL(ppp_is_xmit_locked);
++
++/* ppp_hold_channels()
++ *	Returns the PPP channels of the PPP device, storing each one into
++ *	channels[].
++ *
++ * channels[] has chan_sz elements.
++ * This function returns the number of channels stored, up to chan_sz.
++ * It will return < 0 if the device is not PPP.
++ *
++ * You MUST release the channels using ppp_release_channels().
++ */
++int ppp_hold_channels(struct net_device *dev, struct ppp_channel *channels[],
++		      unsigned int chan_sz)
++{
++	struct ppp *ppp;
++	int c;
++	struct channel *pch;
++
++	if (!dev)
++		return -1;
++
++	if (dev->type != ARPHRD_PPP)
++		return -1;
++
++	ppp = netdev_priv(dev);
++
++	c = 0;
++	ppp_lock(ppp);
++	list_for_each_entry(pch, &ppp->channels, clist) {
++		struct ppp_channel *chan;
++
++		if (!pch->chan) {
++			/* Channel is going / gone away */
++			continue;
++		}
++
++		if (c == chan_sz) {
++			/* No space to record channel */
++			ppp_unlock(ppp);
++			return c;
++		}
++
++		/* Hold the channel, if supported */
++		chan = pch->chan;
++		if (!chan->ops->hold)
++			continue;
++
++		chan->ops->hold(chan);
++
++		 /* Record the channel */
++		channels[c++] = chan;
++	}
++	ppp_unlock(ppp);
++	return c;
++}
++EXPORT_SYMBOL(ppp_hold_channels);
++
++/* ppp_release_channels()
++ *	Releases channels
++ */
++void ppp_release_channels(struct ppp_channel *channels[], unsigned int chan_sz)
++{
++	unsigned int c;
++
++	for (c = 0; c < chan_sz; ++c) {
++		struct ppp_channel *chan;
++
++		chan = channels[c];
++		chan->ops->release(chan);
++	}
++}
++EXPORT_SYMBOL(ppp_release_channels);
++
+ /* Module/initialization stuff */
+ 
+ module_init(ppp_init);
+@@ -3433,6 +3706,7 @@ EXPORT_SYMBOL(ppp_input_error);
+ EXPORT_SYMBOL(ppp_output_wakeup);
+ EXPORT_SYMBOL(ppp_register_compressor);
+ EXPORT_SYMBOL(ppp_unregister_compressor);
++EXPORT_SYMBOL(ppp_update_stats);
+ MODULE_LICENSE("GPL");
+ MODULE_ALIAS_CHARDEV(PPP_MAJOR, 0);
+ MODULE_ALIAS_RTNL_LINK("ppp");
+--- a/drivers/net/ppp/pppoe.c
++++ b/drivers/net/ppp/pppoe.c
+@@ -62,6 +62,7 @@
+ #include <linux/inetdevice.h>
+ #include <linux/etherdevice.h>
+ #include <linux/skbuff.h>
++#include <linux/if_arp.h>
+ #include <linux/init.h>
+ #include <linux/if_ether.h>
+ #include <linux/if_pppox.h>
+@@ -87,7 +88,7 @@
+ static int __pppoe_xmit(struct sock *sk, struct sk_buff *skb);
+ 
+ static const struct proto_ops pppoe_ops;
+-static const struct ppp_channel_ops pppoe_chan_ops;
++static const struct pppoe_channel_ops pppoe_chan_ops;
+ 
+ /* per-net private data for this module */
+ static unsigned int pppoe_net_id __read_mostly;
+@@ -692,7 +693,7 @@ static int pppoe_connect(struct socket *
+ 
+ 		po->chan.mtu = dev->mtu - sizeof(struct pppoe_hdr) - 2;
+ 		po->chan.private = sk;
+-		po->chan.ops = &pppoe_chan_ops;
++		po->chan.ops = (struct ppp_channel_ops *)&pppoe_chan_ops;
+ 
+ 		error = ppp_register_net_channel(dev_net(dev), &po->chan);
+ 		if (error) {
+@@ -994,9 +995,80 @@ static int pppoe_fill_forward_path(struc
+ 	return 0;
+ }
+ 
+-static const struct ppp_channel_ops pppoe_chan_ops = {
+-	.start_xmit = pppoe_xmit,
+-	.fill_forward_path = pppoe_fill_forward_path,
++/************************************************************************
++ *
++ * function called by generic PPP driver to hold channel
++ *
++ ***********************************************************************/
++static void pppoe_hold_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_hold(sk);
++}
++
++/************************************************************************
++ *
++ * function called by generic PPP driver to release channel
++ *
++ ***********************************************************************/
++static void pppoe_release_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_put(sk);
++}
++
++/************************************************************************
++ *
++ * function called to get the channel protocol type
++ *
++ ***********************************************************************/
++static int pppoe_get_channel_protocol(struct ppp_channel *chan)
++{
++	return PX_PROTO_OE;
++}
++
++/************************************************************************
++ *
++ * function called to get the PPPoE channel addressing
++ * NOTE: This function returns a HOLD to the netdevice
++ *
++ ***********************************************************************/
++static int pppoe_get_addressing(struct ppp_channel *chan,
++				 struct pppoe_opt *addressing)
++{
++	struct sock *sk = (struct sock *)chan->private;
++	struct pppox_sock *po = pppox_sk(sk);
++	int err = 0;
++
++	*addressing = po->proto.pppoe;
++	if (!addressing->dev)
++		return -ENODEV;
++
++	dev_hold(addressing->dev);
++	return err;
++}
++
++/* pppoe_channel_addressing_get()
++ *	Return PPPoE channel specific addressing information.
++ */
++int pppoe_channel_addressing_get(struct ppp_channel *chan,
++				  struct pppoe_opt *addressing)
++{
++	return pppoe_get_addressing(chan, addressing);
++}
++EXPORT_SYMBOL(pppoe_channel_addressing_get);
++
++static const struct pppoe_channel_ops pppoe_chan_ops = {
++	/* PPPoE specific channel ops */
++	.get_addressing = pppoe_get_addressing,
++	/* General ppp channel ops */
++	.ops.start_xmit = pppoe_xmit,
++	.ops.get_channel_protocol = pppoe_get_channel_protocol,
++	.ops.hold = pppoe_hold_chan,
++	.ops.release = pppoe_release_chan,
++	.ops.fill_forward_path = pppoe_fill_forward_path,
+ };
+ 
+ static int pppoe_recvmsg(struct socket *sock, struct msghdr *m,
+--- a/include/linux/if_pppox.h
++++ b/include/linux/if_pppox.h
+@@ -93,4 +93,17 @@ enum {
+     PPPOX_DEAD		= 16  /* dead, useless, please clean me up!*/
+ };
+ 
++/*
++ * PPPoE Channel specific operations
++ */
++struct pppoe_channel_ops {
++	/* Must be first - general to all PPP channels */
++	struct ppp_channel_ops ops;
++	int (*get_addressing)(struct ppp_channel *, struct pppoe_opt *);
++};
++
++/* Return PPPoE channel specific addressing information */
++extern int pppoe_channel_addressing_get(struct ppp_channel *chan,
++					 struct pppoe_opt *addressing);
++
+ #endif /* !(__LINUX_IF_PPPOX_H) */
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -1620,6 +1620,24 @@ enum netdev_priv_flags {
+ 	IFF_LIVE_RENAME_OK		= 1<<30,
+ };
+ 
++
++/**
++ * enum netdev_priv_flags_ext - &struct net_device priv_flags_ext
++ *
++ * These flags are used to check for device type and can be
++ * set and used by the drivers
++ *
++ */
++enum netdev_priv_flags_ext {
++	IFF_EXT_TUN_TAP			= 1<<0,
++	IFF_EXT_PPP_L2TPV2		= 1<<1,
++	IFF_EXT_PPP_L2TPV3		= 1<<2,
++	IFF_EXT_PPP_PPTP		= 1<<3,
++	IFF_EXT_GRE_V4_TAP		= 1<<4,
++	IFF_EXT_GRE_V6_TAP		= 1<<5,
++	IFF_EXT_IFB			= 1<<6,
++};
++
+ #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
+ #define IFF_EBRIDGE			IFF_EBRIDGE
+ #define IFF_BONDING			IFF_BONDING
+@@ -1994,6 +2012,7 @@ struct net_device {
+ 
+ 	unsigned int		flags;
+ 	unsigned int		priv_flags;
++	unsigned int		priv_flags_ext;
+ 
+ 	unsigned short		gflags;
+ 	unsigned short		padded;
+--- a/include/linux/ppp_channel.h
++++ b/include/linux/ppp_channel.h
+@@ -19,6 +19,10 @@
+ #include <linux/skbuff.h>
+ #include <linux/poll.h>
+ #include <net/net_namespace.h>
++#include <linux/notifier.h>
++
++#define PPP_CHANNEL_DISCONNECT	0
++#define PPP_CHANNEL_CONNECT	1
+ 
+ struct ppp_channel;
+ 
+@@ -28,9 +32,19 @@ struct ppp_channel_ops {
+ 	int	(*start_xmit)(struct ppp_channel *, struct sk_buff *);
+ 	/* Handle an ioctl call that has come in via /dev/ppp. */
+ 	int	(*ioctl)(struct ppp_channel *, unsigned int, unsigned long);
++	/* Get channel protocol type, one of PX_PROTO_XYZ or specific to
++	 * the channel subtype
++	 */
++	int (*get_channel_protocol)(struct ppp_channel *);
++	/* Get channel protocol version */
++	int (*get_channel_protocol_ver)(struct ppp_channel *);
++	/* Hold the channel from being destroyed */
++	void (*hold)(struct ppp_channel *);
++	/* Release hold on the channel */
++	void (*release)(struct ppp_channel *);
+ 	int	(*fill_forward_path)(struct net_device_path_ctx *,
+-				     struct net_device_path *,
+-				     const struct ppp_channel *);
++				struct net_device_path *,
++				const struct ppp_channel *);
+ };
+ 
+ struct ppp_channel {
+@@ -74,6 +88,51 @@ extern int ppp_unit_number(struct ppp_ch
+ /* Get the device name associated with a channel, or NULL if none */
+ extern char *ppp_dev_name(struct ppp_channel *);
+ 
++/* Call this to obtain the underlying protocol of the PPP channel,
++ * e.g. PX_PROTO_OE
++ */
++extern int ppp_channel_get_protocol(struct ppp_channel *);
++
++/* Call this get protocol version */
++extern int ppp_channel_get_proto_version(struct ppp_channel *);
++
++/* Call this to hold a channel */
++extern bool ppp_channel_hold(struct ppp_channel *);
++
++/* Call this to release a hold you have upon a channel */
++extern void ppp_channel_release(struct ppp_channel *);
++
++/* Release hold on PPP channels */
++extern void ppp_release_channels(struct ppp_channel *channels[],
++				 unsigned int chan_sz);
++
++/* Hold PPP channels for the PPP device */
++extern int ppp_hold_channels(struct net_device *dev,
++				struct ppp_channel *channels[],
++				unsigned int chan_sz);
++
++/* Test if ppp xmit lock is locked */
++extern bool ppp_is_xmit_locked(struct net_device *dev);
++
++/* Test if the ppp device is a multi-link ppp device */
++extern int ppp_is_multilink(struct net_device *dev);
++
++/* Register the PPP channel connect notifier */
++extern void ppp_channel_connection_register_notify(struct notifier_block *nb);
++
++/* Unregister the PPP channel connect notifier */
++extern void ppp_channel_connection_unregister_notify(struct notifier_block *nb);
++
++/* Update statistics of the PPP net_device by incrementing related
++ * statistics field value with corresponding parameter
++ */
++extern void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
++			     unsigned long rx_bytes, unsigned long tx_packets,
++			     unsigned long tx_bytes, unsigned long rx_errors,
++			     unsigned long tx_errors, unsigned long rx_dropped,
++			     unsigned long tx_dropped);
++
++
+ /*
+  * SMP locking notes:
+  * The channel code must ensure that when it calls ppp_unregister_channel,
diff --git a/target/linux/ipq807x/patches-5.10/603-net-core-Flag-to-identify-ingress-shaping-done-for-e.patch b/target/linux/ipq807x/patches-5.10/603-net-core-Flag-to-identify-ingress-shaping-done-for-e.patch
new file mode 100644
index 0000000..23b0e31
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/603-net-core-Flag-to-identify-ingress-shaping-done-for-e.patch
@@ -0,0 +1,74 @@
+From a0c69a23c66ec6f527c439714eb2cc5857a71492 Mon Sep 17 00:00:00 2001
+From: Himanshu Joshi <himajosh@codeaurora.org>
+Date: Tue, 3 Nov 2020 16:41:26 +0530
+Subject: [PATCH] net: core: Flag to identify ingress shaping done for
+ exceptioned packets.
+
+Signed-off-by: Himanshu Joshi <himajosh@codeaurora.org>
+Change-Id: Ib3cd341e5b2d4dcf552e02e38d3f34a4f00351cd
+---
+ include/linux/skbuff.h    |  2 ++
+ include/net/sch_generic.h | 34 ++++++++++++++++++++++++++++++++++
+ 2 files changed, 36 insertions(+)
+
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -646,6 +646,7 @@ typedef unsigned char *sk_buff_data_t;
+  *	@offload_fwd_mark: Packet was L2-forwarded in hardware
+  *	@offload_l3_fwd_mark: Packet was L3-forwarded in hardware
+  *	@tc_skip_classify: do not classify packet. set by IFB device
++ *	@tc_skip_classify_nss: do not classify packet. set by NSS IFB device
+  *	@tc_at_ingress: used within tc_classify to distinguish in/egress
+  *	@redirected: packet was redirected by packet classifier
+  *	@from_ingress: packet was redirected from the ingress path
+@@ -850,6 +851,7 @@ struct sk_buff {
+ #ifdef CONFIG_NET_CLS_ACT
+ 	__u8			tc_skip_classify:1;
+ 	__u8			tc_at_ingress:1;
++	__u8			tc_skip_classify_nss:1;
+ #endif
+ #ifdef CONFIG_NET_REDIRECT
+ 	__u8			redirected:1;
+--- a/include/net/sch_generic.h
++++ b/include/net/sch_generic.h
+@@ -750,6 +750,40 @@ static inline bool skb_skip_tc_classify(
+ 	return false;
+ }
+ 
++/*
++ * Set skb classify bit field.
++ */
++static inline void skb_set_tc_classify_nss(struct sk_buff *skb)
++{
++#ifdef CONFIG_NET_CLS_ACT
++	skb->tc_skip_classify_nss = 1;
++#endif
++}
++
++/*
++ * Clear skb classify bit field.
++ */
++static inline void skb_clear_tc_classify_nss(struct sk_buff *skb)
++{
++#ifdef CONFIG_NET_CLS_ACT
++	skb->tc_skip_classify_nss = 0;
++#endif
++}
++
++/*
++ * Skip skb processing if sent from ifb dev.
++ */
++static inline bool skb_skip_tc_classify_nss(struct sk_buff *skb)
++{
++#ifdef CONFIG_NET_CLS_ACT
++	if (skb->tc_skip_classify_nss) {
++		skb_clear_tc_classify_nss(skb);
++		return true;
++	}
++#endif
++	return false;
++}
++
+ /* Reset all TX qdiscs greater than index of a device.  */
+ static inline void qdisc_reset_all_tx_gt(struct net_device *dev, unsigned int i)
+ {
diff --git a/target/linux/ipq807x/patches-5.10/604-net-core-Replace-nss-keyword-with-offload.patch b/target/linux/ipq807x/patches-5.10/604-net-core-Replace-nss-keyword-with-offload.patch
new file mode 100644
index 0000000..ac7c814
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/604-net-core-Replace-nss-keyword-with-offload.patch
@@ -0,0 +1,76 @@
+From 7c55539fa1e4ea6be400a35127ddc52d6dcd86d4 Mon Sep 17 00:00:00 2001
+From: Himanshu Joshi <himajosh@codeaurora.org>
+Date: Thu, 26 Nov 2020 16:21:06 +0530
+Subject: [PATCH] net: core: Replace nss keyword with offload.
+
+Kernel code should not checked in with NSS keyword.
+This change fixes the naming issue for ifb module.
+
+Signed-off-by: Himanshu Joshi <himajosh@codeaurora.org>
+Change-Id: Iddb97d6ba0a443b830d1ac23728434a417bc8a92
+---
+ include/linux/skbuff.h    |  4 ++--
+ include/net/sch_generic.h | 14 +++++++-------
+ 2 files changed, 9 insertions(+), 9 deletions(-)
+
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -646,7 +646,7 @@ typedef unsigned char *sk_buff_data_t;
+  *	@offload_fwd_mark: Packet was L2-forwarded in hardware
+  *	@offload_l3_fwd_mark: Packet was L3-forwarded in hardware
+  *	@tc_skip_classify: do not classify packet. set by IFB device
+- *	@tc_skip_classify_nss: do not classify packet. set by NSS IFB device
++ *	@tc_skip_classify_offload: do not classify packet set by offload IFB device
+  *	@tc_at_ingress: used within tc_classify to distinguish in/egress
+  *	@redirected: packet was redirected by packet classifier
+  *	@from_ingress: packet was redirected from the ingress path
+@@ -851,7 +851,7 @@ struct sk_buff {
+ #ifdef CONFIG_NET_CLS_ACT
+ 	__u8			tc_skip_classify:1;
+ 	__u8			tc_at_ingress:1;
+-	__u8			tc_skip_classify_nss:1;
++	__u8			tc_skip_classify_offload:1;
+ #endif
+ #ifdef CONFIG_NET_REDIRECT
+ 	__u8			redirected:1;
+--- a/include/net/sch_generic.h
++++ b/include/net/sch_generic.h
+@@ -753,31 +753,31 @@ static inline bool skb_skip_tc_classify(
+ /*
+  * Set skb classify bit field.
+  */
+-static inline void skb_set_tc_classify_nss(struct sk_buff *skb)
++static inline void skb_set_tc_classify_offload(struct sk_buff *skb)
+ {
+ #ifdef CONFIG_NET_CLS_ACT
+-	skb->tc_skip_classify_nss = 1;
++	skb->tc_skip_classify_offload = 1;
+ #endif
+ }
+ 
+ /*
+  * Clear skb classify bit field.
+  */
+-static inline void skb_clear_tc_classify_nss(struct sk_buff *skb)
++static inline void skb_clear_tc_classify_offload(struct sk_buff *skb)
+ {
+ #ifdef CONFIG_NET_CLS_ACT
+-	skb->tc_skip_classify_nss = 0;
++	skb->tc_skip_classify_offload = 0;
+ #endif
+ }
+ 
+ /*
+  * Skip skb processing if sent from ifb dev.
+  */
+-static inline bool skb_skip_tc_classify_nss(struct sk_buff *skb)
++static inline bool skb_skip_tc_classify_offload(struct sk_buff *skb)
+ {
+ #ifdef CONFIG_NET_CLS_ACT
+-	if (skb->tc_skip_classify_nss) {
+-		skb_clear_tc_classify_nss(skb);
++	if (skb->tc_skip_classify_offload) {
++		skb_clear_tc_classify_offload(skb);
+ 		return true;
+ 	}
+ #endif
diff --git a/target/linux/ipq807x/patches-5.10/900-arm64-dts-add-OpenWrt-DTS-files.patch b/target/linux/ipq807x/patches-5.10/900-arm64-dts-add-OpenWrt-DTS-files.patch
new file mode 100644
index 0000000..bcc0c9d
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/900-arm64-dts-add-OpenWrt-DTS-files.patch
@@ -0,0 +1,24 @@
+From 8aec79b6d4d59616eb6ce4fbfb94658b3e79d9ce Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Tue, 11 May 2021 13:29:33 +0200
+Subject: [PATCH] arm64: dts: add OpenWrt DTS files
+
+Lets add custom OpenWrt DTS files to Makefile.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/boot/dts/qcom/Makefile | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/arm64/boot/dts/qcom/Makefile
++++ b/arch/arm64/boot/dts/qcom/Makefile
+@@ -3,6 +3,9 @@ dtb-$(CONFIG_ARCH_QCOM)	+= apq8016-sbc.d
+ dtb-$(CONFIG_ARCH_QCOM)	+= apq8096-db820c.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= apq8096-ifc6640.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq6018-cp01-c1.dtb
++dtb-$(CONFIG_ARCH_QCOM)	+= ipq8071-ax6.dtb
++dtb-$(CONFIG_ARCH_QCOM)	+= ipq8071-ax3600.dtb
++dtb-$(CONFIG_ARCH_QCOM)        += ipq8072-ax9000.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk01.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-longcheer-l8150.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-mtp.dtb
diff --git a/target/linux/ipq807x/patches-5.10/901-soc-qcom-Make-QMI-Helpers-user-selectable.patch b/target/linux/ipq807x/patches-5.10/901-soc-qcom-Make-QMI-Helpers-user-selectable.patch
new file mode 100644
index 0000000..a5ed332
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/901-soc-qcom-Make-QMI-Helpers-user-selectable.patch
@@ -0,0 +1,28 @@
+From b9b94712847f8fa6ca8dc03422ba9e0332b6997d Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Thu, 13 May 2021 14:54:43 +0200
+Subject: [PATCH] soc: qcom: Make QMI Helpers user selectable
+
+Wireless backports for ath11k have a different logic
+then upstream as they depend on QMI helpers instead
+of selecting them.
+
+So, to make it possible to select QMI helpers
+through KConfig add text to tristate.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ drivers/soc/qcom/Kconfig | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/soc/qcom/Kconfig
++++ b/drivers/soc/qcom/Kconfig
+@@ -92,7 +92,7 @@ config QCOM_PDR_HELPERS
+ 	select QCOM_QMI_HELPERS
+ 
+ config QCOM_QMI_HELPERS
+-	tristate
++	tristate "Qualcomm QMI helpers"
+ 	depends on NET
+ 
+ config QCOM_RMTFS_MEM
diff --git a/target/linux/ipq807x/patches-5.10/902-arm64-provide-dma-cache-routines-with-same-API-as-32.patch b/target/linux/ipq807x/patches-5.10/902-arm64-provide-dma-cache-routines-with-same-API-as-32.patch
new file mode 100644
index 0000000..a682bb2
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/902-arm64-provide-dma-cache-routines-with-same-API-as-32.patch
@@ -0,0 +1,56 @@
+From 181e506248fd24a0febbfbd794bba43a7b346115 Mon Sep 17 00:00:00 2001
+From: Kathiravan T <kathirav@codeaurora.org>
+Date: Fri, 17 Jan 2014 10:33:08 -0800
+Subject: [PATCH] arm64: provide dma cache routines with same API as 32 bit
+
+The APIs __dma_inv_range() and __dma_clean_range() were
+not exported by the third party patch. Since the functions
+starting with underscores are not to be directly used by drivers,
+related functions without the underscores are provided
+which have the same name and functionality as the 32 bit APIs.
+
+CRs-Fixed: 1053067
+Change-Id: Ie0e681614307d9d9a19e58cacfb9b5dff4528977
+
+arm64: add defines for dmac_*_range for compatibility with arm32
+
+An earlier patch created defines for dma_*_range APIs to be
+compatible with arm 32 bit, however it appears
+these API names have not (at least yet) appeared there, so
+revise the names to dmac_*_range, which is defined
+for arm 32 bit so that there is one name defined
+for both architectures.
+
+CRs-Fixed: 1053067
+Signed-off-by: Larry Bassel <lbassel@codeaurora.org>
+(cherry picked from commit 0930bab0db67cc0d91e52e385e3e061871c6be05)
+[psodagud: fixed up trivial merge conflicts and warnings]
+Signed-off-by: Prasad Sodagudi <psodagud@codeaurora.org>
+
+(cherry picked from commit a313e54567627a1fd96cd267e2c6c358d14e468c)
+[kathirav: fixed the trivial conflicts]
+
+Change-Id: I6456c02bad73fb54a874dc9925d3d43d9b8be2f2
+Signed-off-by: Kathiravan T <kathirav@codeaurora.org>
+---
+ arch/arm64/include/asm/cacheflush.h | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+--- a/arch/arm64/include/asm/cacheflush.h
++++ b/arch/arm64/include/asm/cacheflush.h
+@@ -102,6 +102,15 @@ static inline void flush_icache_range(un
+ extern void __dma_map_area(const void *, size_t, int);
+ extern void __dma_unmap_area(const void *, size_t, int);
+ extern void __dma_flush_area(const void *, size_t);
++extern void __dma_inv_area(const void *start, size_t size);
++extern void __dma_clean_area(const void *start, size_t size);
++
++#define dmac_flush_range(start, end) \
++	__dma_flush_area(start, (void *)(end) - (void *)(start))
++#define dmac_inv_range(start, end) \
++	__dma_inv_area(start, (void *)(end) - (void *)(start))
++#define dmac_clean_range(start, end) \
++	__dma_clean_area(start, (void *)(end) - (void *)(start))
+ 
+ /*
+  * Copy user data from/to a page which is mapped into a different
diff --git a/target/linux/ipq807x/patches-5.10/903-arm64-mm-export-__dma_inv_area-and-__dma_clean_area.patch b/target/linux/ipq807x/patches-5.10/903-arm64-mm-export-__dma_inv_area-and-__dma_clean_area.patch
new file mode 100644
index 0000000..865a7a9
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/903-arm64-mm-export-__dma_inv_area-and-__dma_clean_area.patch
@@ -0,0 +1,58 @@
+From da0c8f67d9aca417a441af4fb90acf65eef94585 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Thu, 13 May 2021 23:44:07 +0200
+Subject: [PATCH] arm64: mm: export __dma_inv_area and __dma_clean_area
+
+Qualcomm NSS drivers use these extensively.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm64/include/asm/cacheflush.h | 4 ++--
+ arch/arm64/mm/cache.S               | 4 ++--
+ arch/arm64/mm/flush.c               | 2 ++
+ 3 files changed, 6 insertions(+), 4 deletions(-)
+
+--- a/arch/arm64/include/asm/cacheflush.h
++++ b/arch/arm64/include/asm/cacheflush.h
+@@ -102,8 +102,8 @@ static inline void flush_icache_range(un
+ extern void __dma_map_area(const void *, size_t, int);
+ extern void __dma_unmap_area(const void *, size_t, int);
+ extern void __dma_flush_area(const void *, size_t);
+-extern void __dma_inv_area(const void *start, size_t size);
+-extern void __dma_clean_area(const void *start, size_t size);
++extern void __dma_inv_area(const void *, size_t);
++extern void __dma_clean_area(const void *, size_t);
+ 
+ #define dmac_flush_range(start, end) \
+ 	__dma_flush_area(start, (void *)(end) - (void *)(start))
+--- a/arch/arm64/mm/cache.S
++++ b/arch/arm64/mm/cache.S
+@@ -138,7 +138,7 @@ SYM_FUNC_END(__clean_dcache_area_pou)
+  *	- kaddr   - kernel address
+  *	- size    - size in question
+  */
+-SYM_FUNC_START_LOCAL(__dma_inv_area)
++SYM_FUNC_START(__dma_inv_area)
+ SYM_FUNC_START_PI(__inval_dcache_area)
+ 	/* FALLTHROUGH */
+ 
+@@ -177,7 +177,7 @@ SYM_FUNC_END(__dma_inv_area)
+  *	- kaddr   - kernel address
+  *	- size    - size in question
+  */
+-SYM_FUNC_START_LOCAL(__dma_clean_area)
++SYM_FUNC_START(__dma_clean_area)
+ SYM_FUNC_START_PI(__clean_dcache_area_poc)
+ 	/* FALLTHROUGH */
+ 
+--- a/arch/arm64/mm/flush.c
++++ b/arch/arm64/mm/flush.c
+@@ -78,6 +78,8 @@ EXPORT_SYMBOL(flush_dcache_page);
+  * Additional functions defined in assembly.
+  */
+ EXPORT_SYMBOL(__flush_icache_range);
++EXPORT_SYMBOL(__dma_inv_area);
++EXPORT_SYMBOL(__dma_clean_area);
+ 
+ #ifdef CONFIG_ARCH_HAS_PMEM_API
+ void arch_wb_cache_pmem(void *addr, size_t size)
diff --git a/target/linux/ipq807x/patches-5.10/990-clk-qcom-fix-wrong-RCG-clock-rate-for-high-parent-fr.patch b/target/linux/ipq807x/patches-5.10/990-clk-qcom-fix-wrong-RCG-clock-rate-for-high-parent-fr.patch
new file mode 100644
index 0000000..eb47341
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/990-clk-qcom-fix-wrong-RCG-clock-rate-for-high-parent-fr.patch
@@ -0,0 +1,49 @@
+From 474740fac667ccf7a6b3c748d851e5ed364d59eb Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Mon, 4 Sep 2017 15:00:10 +0530
+Subject: [PATCH 1/3] clk: qcom: fix wrong RCG clock rate for high parent freq
+
+If the parent clock rate is greater than unsigned long max
+divided by 2 then the integer overflow is happening while
+calculating the clock rate. Since RCG2 uses half integer
+dividers, the clock rate is first being multiplied by 2
+followed by division and this multiplication leads to
+overflow.
+
+Change-Id: I4e4f41b4a539446b962eb684761a3aad6f8a8977
+Signed-off-by: Abhishek Sahu <absahu@codeaurora.org>
+(cherry picked from commit 9cfedaf465eb18ef31e4d677cba5f3147fe6d430)
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+
+Change-Id: I69b78616f468bb7a9647c7994a8579b97c376d4e
+---
+ drivers/clk/qcom/clk-rcg2.c | 12 ++++++------
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+--- a/drivers/clk/qcom/clk-rcg2.c
++++ b/drivers/clk/qcom/clk-rcg2.c
+@@ -145,18 +145,18 @@ static int clk_rcg2_set_parent(struct cl
+  *            hid_div       n
+  */
+ static unsigned long
+-calc_rate(unsigned long rate, u32 m, u32 n, u32 mode, u32 hid_div)
++calc_rate(unsigned long parent_rate, u32 m, u32 n, u32 mode, u32 hid_div)
+ {
++	u64 rate = parent_rate;
++
+ 	if (hid_div) {
+ 		rate *= 2;
+-		rate /= hid_div + 1;
++		do_div(rate, hid_div + 1);
+ 	}
+ 
+ 	if (mode) {
+-		u64 tmp = rate;
+-		tmp *= m;
+-		do_div(tmp, n);
+-		rate = tmp;
++		rate *= m;
++		do_div(rate, n);
+ 	}
+ 
+ 	return rate;
diff --git a/target/linux/ipq807x/patches-5.10/991-clk-qcom-add-support-for-hw-controlled-RCG.patch b/target/linux/ipq807x/patches-5.10/991-clk-qcom-add-support-for-hw-controlled-RCG.patch
new file mode 100644
index 0000000..78d7b20
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/991-clk-qcom-add-support-for-hw-controlled-RCG.patch
@@ -0,0 +1,136 @@
+From 0245360f8e118b67f4015533cfc79314f2d848d5 Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Tue, 13 Jun 2017 15:30:39 +0530
+Subject: [PATCH 2/3] clk: qcom: add support for hw controlled RCG
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The current driver generates stack trace during RCG update if
+the RCG is off and new parent source is also disabled. For
+hardware controlled RCGs, clock is forced on during update
+process and goes back to off status once switch is completed.
+Since the new parent is in disabled state so update bit wont
+be cleared in this case. The check for update bit can be
+skipped in this case.
+
+Signed-off-by: Abhishek Sahu <absahu@codeaurora.org>
+(cherry picked from commit 84dd0e12f10eebff44a464eb8455205abc4b4178)
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+
+Change-Id: Ifb4175b02d89542baa1b758107c2ce86f7bf8599
+---
+ drivers/clk/qcom/clk-rcg.h  |  4 ++++
+ drivers/clk/qcom/clk-rcg2.c | 27 +++++++++++++++++++++------
+ 2 files changed, 25 insertions(+), 6 deletions(-)
+
+--- a/drivers/clk/qcom/clk-rcg.h
++++ b/drivers/clk/qcom/clk-rcg.h
+@@ -135,6 +135,7 @@ extern const struct clk_ops clk_dyn_rcg_
+  * @mnd_width: number of bits in m/n/d values
+  * @hid_width: number of bits in half integer divider
+  * @safe_src_index: safe src index value
++ * @flags: RCG2 specific clock flags
+  * @parent_map: map from software's parent index to hardware's src_sel field
+  * @freq_tbl: frequency table
+  * @clkr: regmap clock handle
+@@ -145,6 +146,9 @@ struct clk_rcg2 {
+ 	u8			mnd_width;
+ 	u8			hid_width;
+ 	u8			safe_src_index;
++
++#define CLK_RCG2_HW_CONTROLLED		BIT(0)
++	u8			flags;
+ 	const struct parent_map	*parent_map;
+ 	const struct freq_tbl	*freq_tbl;
+ 	struct clk_regmap	clkr;
+--- a/drivers/clk/qcom/clk-rcg2.c
++++ b/drivers/clk/qcom/clk-rcg2.c
+@@ -97,7 +97,7 @@ err:
+ 	return 0;
+ }
+ 
+-static int update_config(struct clk_rcg2 *rcg)
++static int update_config(struct clk_rcg2 *rcg, bool check_update_clear)
+ {
+ 	int count, ret;
+ 	u32 cmd;
+@@ -109,6 +109,9 @@ static int update_config(struct clk_rcg2
+ 	if (ret)
+ 		return ret;
+ 
++	if (!check_update_clear)
++		return 0;
++
+ 	/* Wait for update to take effect */
+ 	for (count = 500; count > 0; count--) {
+ 		ret = regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG, &cmd);
+@@ -127,14 +130,19 @@ static int clk_rcg2_set_parent(struct cl
+ {
+ 	struct clk_rcg2 *rcg = to_clk_rcg2(hw);
+ 	int ret;
++	bool check_update_clear = true;
+ 	u32 cfg = rcg->parent_map[index].cfg << CFG_SRC_SEL_SHIFT;
+ 
++	if ((rcg->flags & CLK_RCG2_HW_CONTROLLED) &&
++	    !clk_hw_is_enabled(clk_hw_get_parent_by_index(hw, index)))
++		check_update_clear = false;
++
+ 	ret = regmap_update_bits(rcg->clkr.regmap, RCG_CFG_OFFSET(rcg),
+ 				 CFG_SRC_SEL_MASK, cfg);
+ 	if (ret)
+ 		return ret;
+ 
+-	return update_config(rcg);
++	return update_config(rcg, check_update_clear);
+ }
+ 
+ /*
+@@ -302,12 +310,19 @@ static int __clk_rcg2_configure(struct c
+ static int clk_rcg2_configure(struct clk_rcg2 *rcg, const struct freq_tbl *f)
+ {
+ 	int ret;
++	bool check_update_clear = true;
++	struct clk_hw *hw = &rcg->clkr.hw;
++	int index = qcom_find_src_index(hw, rcg->parent_map, f->src);
+ 
+ 	ret = __clk_rcg2_configure(rcg, f);
+ 	if (ret)
+ 		return ret;
+ 
+-	return update_config(rcg);
++	if ((rcg->flags & CLK_RCG2_HW_CONTROLLED) &&
++	    !clk_hw_is_enabled(clk_hw_get_parent_by_index(hw, index)))
++		check_update_clear = false;
++
++	return update_config(rcg, check_update_clear);
+ }
+ 
+ static int __clk_rcg2_set_rate(struct clk_hw *hw, unsigned long rate,
+@@ -786,7 +801,7 @@ static int clk_gfx3d_set_rate_and_parent
+ 	if (ret)
+ 		return ret;
+ 
+-	return update_config(rcg);
++	return update_config(rcg, true);
+ }
+ 
+ static int clk_gfx3d_set_rate(struct clk_hw *hw, unsigned long rate,
+@@ -898,7 +913,7 @@ static int clk_rcg2_shared_enable(struct
+ 	if (ret)
+ 		return ret;
+ 
+-	ret = update_config(rcg);
++	ret = update_config(rcg, true);
+ 	if (ret)
+ 		return ret;
+ 
+@@ -929,7 +944,7 @@ static void clk_rcg2_shared_disable(stru
+ 	regmap_write(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG,
+ 		     rcg->safe_src_index << CFG_SRC_SEL_SHIFT);
+ 
+-	update_config(rcg);
++	update_config(rcg, true);
+ 
+ 	clk_rcg2_clear_force_enable(hw);
+ 
diff --git a/target/linux/ipq807x/patches-5.10/992-clk-qcom-ipq8074-add-hw-controlled-flag.patch b/target/linux/ipq807x/patches-5.10/992-clk-qcom-ipq8074-add-hw-controlled-flag.patch
new file mode 100644
index 0000000..971a255
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/992-clk-qcom-ipq8074-add-hw-controlled-flag.patch
@@ -0,0 +1,38 @@
+From 18d04f5cae30725ffa0c1c025f6beb1821c46857 Mon Sep 17 00:00:00 2001
+From: Praveenkumar I <ipkumar@codeaurora.org>
+Date: Tue, 13 Jun 2017 15:31:34 +0530
+Subject: [PATCH 3/3] clk: qcom: ipq8074: add hw controlled flag
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+These RCGs are hw controlled so add the
+CLK_RCG2_HW_CONTROLLED flag.
+
+Signed-off-by: Abhishek Sahu <absahu@codeaurora.org>
+(cherry picked from commit 9a025b8271a95a80e9e769b89154b98b263be860)
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+
+Change-Id: Ic5da1551bf46921890955312026b9175a42fe14e
+---
+ drivers/clk/qcom/gcc-ipq8074.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/clk/qcom/gcc-ipq8074.c
++++ b/drivers/clk/qcom/gcc-ipq8074.c
+@@ -648,6 +648,7 @@ static struct clk_rcg2 pcnoc_bfdcd_clk_s
+ 	.freq_tbl = ftbl_pcnoc_bfdcd_clk_src,
+ 	.hid_width = 5,
+ 	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.flags = CLK_RCG2_HW_CONTROLLED,
+ 	.clkr.hw.init = &(struct clk_init_data){
+ 		.name = "pcnoc_bfdcd_clk_src",
+ 		.parent_names = gcc_xo_gpll0_gpll0_out_main_div2,
+@@ -1317,6 +1318,7 @@ static struct clk_rcg2 system_noc_bfdcd_
+ 	.freq_tbl = ftbl_system_noc_bfdcd_clk_src,
+ 	.hid_width = 5,
+ 	.parent_map = gcc_xo_gpll0_gpll6_gpll0_out_main_div2_map,
++	.flags = CLK_RCG2_HW_CONTROLLED,
+ 	.clkr.hw.init = &(struct clk_init_data){
+ 		.name = "system_noc_bfdcd_clk_src",
+ 		.parent_names = gcc_xo_gpll0_gpll6_gpll0_out_main_div2,
diff --git a/target/linux/ipq807x/patches-5.10/997-device_tree_cmdline.patch b/target/linux/ipq807x/patches-5.10/997-device_tree_cmdline.patch
new file mode 100644
index 0000000..27d4d7f
--- /dev/null
+++ b/target/linux/ipq807x/patches-5.10/997-device_tree_cmdline.patch
@@ -0,0 +1,12 @@
+--- a/drivers/of/fdt.c
++++ b/drivers/of/fdt.c
+@@ -1055,6 +1055,9 @@ int __init early_init_dt_scan_chosen(uns
+ 	p = of_get_flat_dt_prop(node, "bootargs", &l);
+ 	if (p != NULL && l > 0)
+ 		strlcpy(data, p, min(l, COMMAND_LINE_SIZE));
++	p = of_get_flat_dt_prop(node, "bootargs-append", &l);
++	if (p != NULL && l > 0)
++		strlcat(data, p, min_t(int, strlen(data) + (int)l, COMMAND_LINE_SIZE));
+ 
+ 	/*
+ 	 * CONFIG_CMDLINE is meant to be a default in case nothing else
diff --git a/target/linux/ipq807x/profiles/default.mk b/target/linux/ipq807x/profiles/default.mk
deleted file mode 100644
index 44935d6..0000000
--- a/target/linux/ipq807x/profiles/default.mk
+++ /dev/null
@@ -1,8 +0,0 @@
-define Profile/Default
-	NAME:=Default Profile (minimum package set)
-endef
-
-define Profile/Default/Description
-	Default package set compatible with most boards.
-endef
-$(eval $(call Profile,Default))
